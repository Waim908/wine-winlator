--- wine_proton10/dlls/ntdll/unix/file.c	2025-11-05 17:27:19.685952090 +0800
+++ wine-10.0/dlls/ntdll/unix/file.c	2025-01-22 00:42:16.000000000 +0800
@@ -1698,24 +1698,9 @@
     else return xattr_fremove( fd, SAMBA_XATTR_DOS_ATTRIB );
 }
 
-static unsigned int server_get_unix_name( HANDLE handle, char **unix_name );
-
-/* return TRUE if this is a file owned by Wine which applications should not try to mess with. */
-static BOOL is_wine_file( HANDLE handle )
-{
-    char *unix_name;
-    BOOL ret;
-
-    if (server_get_unix_name( handle, &unix_name ))
-        return FALSE;
-    ret = strstr(unix_name, "/lib/wine/" ) || strstr( unix_name, "/lib64/wine/" ) ||strstr( unix_name, "/share/wine/" );
-    free(unix_name);
-    return ret;
-}
-
 
 /* set the stat info and file attributes for a file (by file descriptor) */
-static NTSTATUS fd_set_file_info( int fd, HANDLE handle, UINT attr, BOOL force_set_xattr )
+static NTSTATUS fd_set_file_info( int fd, UINT attr, BOOL force_set_xattr )
 {
     struct stat st;
 
@@ -1729,16 +1714,8 @@
     }
     else
     {
-        if (is_wine_file( handle ))
-        {
-            TRACE("HACK: Not giving write permission to wine file!\n");
-            return STATUS_ACCESS_DENIED;
-        }
-        else
-        {
-            /* add write permission only where we already have read permission */
-            st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~start_umask);
-        }
+        /* add write permission only where we already have read permission */
+        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~start_umask);
     }
     if (fchmod( fd, st.st_mode ) == -1) return errno_to_status( errno );
 
@@ -2145,31 +2122,6 @@
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS get_full_size_info_ex(int fd, FILE_FS_FULL_SIZE_INFORMATION_EX *info)
-{
-    FILE_FS_FULL_SIZE_INFORMATION full_info;
-    NTSTATUS status;
-
-    if ((status = get_full_size_info(fd, &full_info)) != STATUS_SUCCESS)
-        return status;
-
-    info->ActualTotalAllocationUnits = full_info.TotalAllocationUnits.QuadPart;
-    info->ActualAvailableAllocationUnits = full_info.ActualAvailableAllocationUnits.QuadPart;
-    info->ActualPoolUnavailableAllocationUnits = 0;
-    info->CallerAvailableAllocationUnits = full_info.CallerAvailableAllocationUnits.QuadPart;
-    info->CallerPoolUnavailableAllocationUnits = 0;
-    info->UsedAllocationUnits = info->ActualTotalAllocationUnits - info->ActualAvailableAllocationUnits;
-    info->CallerTotalAllocationUnits = info->CallerAvailableAllocationUnits + info->UsedAllocationUnits;
-    info->TotalReservedAllocationUnits = 0;
-    info->VolumeStorageReserveAllocationUnits = 0;
-    info->AvailableCommittedAllocationUnits = 0;
-    info->PoolAvailableAllocationUnits = 0;
-    info->SectorsPerAllocationUnit = full_info.SectorsPerAllocationUnit;
-    info->BytesPerSector = full_info.BytesPerSector;
-
-    return STATUS_SUCCESS;
-}
-
 
 static NTSTATUS server_get_file_info( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer,
                                       ULONG length, FILE_INFORMATION_CLASS info_class )
@@ -2730,57 +2682,6 @@
     return status;
 }
 
-static NTSTATUS server_query_directory_file( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer, ULONG length,
-                                             FILE_INFORMATION_CLASS info_class, BOOLEAN single_entry,
-                                             BOOLEAN restart_scan )
-{
-    FILE_DIRECTORY_INFORMATION *info = (FILE_DIRECTORY_INFORMATION *)buffer;
-    struct directory_file_entry *entries;
-    unsigned int total_len;
-    NTSTATUS status;
-
-    if (!(entries = malloc( length ))) return STATUS_NO_MEMORY;
-
-    SERVER_START_REQ( query_directory_file )
-    {
-        req->handle = wine_server_obj_handle( handle );;
-        req->restart_scan = restart_scan;
-        wine_server_set_reply( req, entries, length );
-        status = wine_server_call( req );
-        total_len = reply->total_len;
-        if (status == STATUS_OBJECT_TYPE_MISMATCH) status = STATUS_BAD_DEVICE_TYPE;
-    }
-    SERVER_END_REQ;
-
-    if (!status && offsetof(FILE_DIRECTORY_INFORMATION, FileName) + total_len > length)
-        status = STATUS_INFO_LENGTH_MISMATCH;
-
-    io->Status = status;
-    io->Information = 0;
-    if (!status)
-    {
-        static int once;
-
-        if (info_class != FileDirectoryInformation)
-        {
-            FIXME( "Unsupprted info_class %d.\n", info_class );
-            free( entries );
-            return STATUS_NOT_SUPPORTED;
-        }
-        if (!single_entry) FIXME( "Multiple entries not supported.\n" );
-
-        memset( info, 0, sizeof(*info) );
-        if (!once++) FIXME( "Not filling attributes." );
-        info->FileNameLength = entries->name_len;
-        memcpy( info->FileName, entries + 1, entries->name_len );
-        io->Information = offsetof(FILE_DIRECTORY_INFORMATION, FileName) + total_len;
-        TRACE( "-> %s.\n", debugstr_wn(info->FileName, info->FileNameLength / 2) );
-    }
-    else TRACE( "-> status %#x.\n", (int)status );
-
-    free( entries );
-    return status;
-}
 
 /******************************************************************************
  *              NtQueryDirectoryFile   (NTDLL.@)
@@ -2831,11 +2732,7 @@
     if (!buffer) return STATUS_ACCESS_VIOLATION;
 
     if ((status = server_get_unix_fd( handle, FILE_LIST_DIRECTORY, &fd, &needs_close, &type, NULL )))
-    {
-        if (status == STATUS_BAD_DEVICE_TYPE)
-            return server_query_directory_file( handle, io, buffer, length, info_class, single_entry, restart_scan);
         return status;
-    }
 
     if (type != FD_TYPE_DIR)
     {
@@ -3005,67 +2902,6 @@
     return STATUS_OBJECT_NAME_NOT_FOUND;
 }
 
-/* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
-static BOOL replace_steam_input_path( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *redir )
-{
-    static const WCHAR pipe_prefixW[] =
-    {
-        '\\','?','?','\\','p','i','p','e','\\','H','I','D','#','V','I','D','_','0','4','5','E',
-        '&','P','I','D','_','0','2','8','E','&','I','G','_','0','0',
-    };
-    static const WCHAR hid_prefixW[] =
-    {
-        '\\','?','?','\\','h','i','d','#','v','i','d','_','2','8','d','e',
-        '&','p','i','d','_','1','1','f','f','&','i','g','_','0'
-    };
-    static const WCHAR hid_midW[] =
-    {
-        '#','0',
-    };
-    static const WCHAR hid_tailW[] =
-    {
-        '&','0','&','0','&','1','#','{','4','d','1','e','5','5','b','2','-','f','1','6','f','-',
-        '1','1','c','f','-','8','8','c','b','-','0','0','1','1','1','1','0','0','0','0','3','0','}'
-    };
-    UNICODE_STRING *path = attr->ObjectName;
-    const WCHAR *slot = NULL, *slot_end = NULL, *serial, *serial_end = NULL;
-    UINT len = 0;
-
-    if (!path || !path->Buffer || path->Length <= sizeof(pipe_prefixW)) return FALSE;
-    if (wcsnicmp( path->Buffer, pipe_prefixW, ARRAY_SIZE(pipe_prefixW) )) return FALSE;
-
-    serial = path->Buffer + path->Length / sizeof(WCHAR);
-    while (serial > path->Buffer && *serial != '&')
-    {
-        if (*serial == '#')
-        {
-            slot_end = serial_end;
-            serial_end = serial;
-            slot = serial_end + 1;
-        }
-        serial--;
-    }
-    if (serial == path->Buffer || *serial != '&' || !slot_end || !serial_end) return FALSE;
-
-    redir->Length = sizeof(hid_prefixW) + sizeof(hid_midW) + sizeof(hid_tailW);
-    redir->Length += (serial_end - serial + slot_end - slot) * sizeof(WCHAR);
-    redir->MaximumLength = redir->Length + sizeof(WCHAR);
-    if (!(redir->Buffer = malloc( redir->MaximumLength ))) return FALSE;
-
-    memcpy( redir->Buffer, hid_prefixW, sizeof(hid_prefixW) );
-    len += ARRAY_SIZE(hid_prefixW);
-    memcpy( redir->Buffer + len, slot, (slot_end - slot) * sizeof(WCHAR) );
-    len += slot_end - slot;
-    memcpy( redir->Buffer + len, hid_midW, sizeof(hid_midW) );
-    len += ARRAY_SIZE(hid_midW);
-    memcpy( redir->Buffer + len, serial, (serial_end - serial) * sizeof(WCHAR) );
-    len += serial_end - serial;
-    memcpy( redir->Buffer + len, hid_tailW, sizeof(hid_tailW) );
-
-    TRACE( "HACK: %s -> %s\n", debugstr_us(attr->ObjectName), debugstr_us(redir) );
-    attr->ObjectName = redir;
-    return TRUE;
-}
 
 #ifndef _WIN64
 
@@ -3167,10 +3003,6 @@
     unsigned int i, prefix_len = 0, len = attr->ObjectName->Length / sizeof(WCHAR);
 
     redir->Buffer = NULL;
-
-    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
-    if (replace_steam_input_path( attr, redir )) return TRUE;
-
     if (!NtCurrentTeb64()) return FALSE;
     if (!len) return FALSE;
 
@@ -3230,8 +3062,7 @@
 BOOL get_redirect( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *redir )
 {
     redir->Buffer = NULL;
-    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
-    return replace_steam_input_path( attr, redir );
+    return FALSE;
 }
 
 #endif
@@ -3337,31 +3168,16 @@
 {
     static const WCHAR nt_prefixW[] = {'\\','?','?','\\'};
     static const WCHAR dosdev_prefixW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\'};
-    static const WCHAR globalrootW[] = {'\\','?','?','\\','G','l','o','b','a','l','R','o','o','t'};
-    int prefix_len = 0;
-    WCHAR *prefix;
-    USHORT length;
-
-    prefix = name->Buffer;
-    length = name->Length;
-
-    if (length >= ARRAY_SIZE( globalrootW ) &&
-        !wcsnicmp( prefix, globalrootW, ARRAY_SIZE( globalrootW )))
-    {
-        WARN("Stripping off GlobalRoot prefix.\n");
-        prefix += ARRAY_SIZE( globalrootW );
-        prefix_len += ARRAY_SIZE( globalrootW );
-        length -= ARRAY_SIZE( globalrootW );
-    }
-
-    if (length >= sizeof(nt_prefixW) &&
-        !memcmp( prefix, nt_prefixW, sizeof(nt_prefixW) ))
-        prefix_len += ARRAY_SIZE( nt_prefixW );
-    else if (length >= sizeof(dosdev_prefixW) &&
-        !wcsnicmp( prefix, dosdev_prefixW, ARRAY_SIZE( dosdev_prefixW )))
-        prefix_len += ARRAY_SIZE( dosdev_prefixW );
 
-    return prefix_len;
+    if (name->Length >= sizeof(nt_prefixW) &&
+        !memcmp( name->Buffer, nt_prefixW, sizeof(nt_prefixW) ))
+        return ARRAY_SIZE( nt_prefixW );
+
+    if (name->Length >= sizeof(dosdev_prefixW) &&
+        !wcsnicmp( name->Buffer, dosdev_prefixW, ARRAY_SIZE( dosdev_prefixW )))
+        return ARRAY_SIZE( dosdev_prefixW );
+
+    return 0;
 }
 
 
@@ -3741,7 +3557,7 @@
     name     = nameW->Buffer;
     name_len = nameW->Length / sizeof(WCHAR);
 
-    if (!name || !name_len || name[0] != '\\') return STATUS_OBJECT_PATH_SYNTAX_BAD;
+    if (!name_len || name[0] != '\\') return STATUS_OBJECT_PATH_SYNTAX_BAD;
 
     if (!(pos = get_dos_prefix_len( nameW )))
         return STATUS_BAD_DEVICE_TYPE;  /* no DOS prefix, assume NT native name */
@@ -3835,7 +3651,7 @@
 
 
 /******************************************************************************
- *           nt_to_unix_file_name_internal
+ *           nt_to_unix_file_name
  *
  * Convert a file name from NT namespace to Unix namespace.
  *
@@ -3843,7 +3659,7 @@
  * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
  * returned, but the unix name is still filled in properly.
  */
-NTSTATUS nt_to_unix_file_name_internal( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
+NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
 {
     enum server_fd_type type;
     int old_cwd, root_fd, needs_close;
@@ -3852,9 +3668,6 @@
     int name_len, unix_len;
     NTSTATUS status;
 
-    if (!attr->ObjectName->Buffer && attr->ObjectName->Length)
-        return STATUS_ACCESS_VIOLATION;
-
     if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
         return nt_to_unix_file_name_no_root( attr->ObjectName, name_ret, disposition );
 
@@ -3904,136 +3717,6 @@
 }
 
 
-/* read the contents of an NT symlink object */
-static NTSTATUS read_nt_symlink( HANDLE root, UNICODE_STRING *name, WCHAR *target, size_t length )
-{
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING targetW;
-    NTSTATUS status;
-    HANDLE handle;
-
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = root;
-    attr.Attributes = OBJ_CASE_INSENSITIVE;
-    attr.ObjectName = name;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-
-    if (!(status = NtOpenSymbolicLinkObject( &handle, SYMBOLIC_LINK_QUERY, &attr )))
-    {
-        targetW.Buffer = target;
-        targetW.MaximumLength = (length - 1) * sizeof(WCHAR);
-        status = NtQuerySymbolicLinkObject( handle, &targetW, NULL );
-        NtClose( handle );
-    }
-
-    return status;
-}
-
-/* try to find dos device based on nt device name */
-static NTSTATUS nt_to_dos_device( WCHAR *name, size_t length, WCHAR *device_ret )
-{
-    static const WCHAR dosdevicesW[] = {'\\','D','o','s','D','e','v','i','c','e','s',0};
-    UNICODE_STRING dosdevW = { sizeof(dosdevicesW) - sizeof(WCHAR), sizeof(dosdevicesW), (WCHAR *)dosdevicesW };
-    WCHAR symlinkW[MAX_DIR_ENTRY_LEN];
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-    char data[1024];
-    HANDLE handle;
-    ULONG ctx = 0;
-
-    DIRECTORY_BASIC_INFORMATION *info = (DIRECTORY_BASIC_INFORMATION *)data;
-
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = 0;
-    attr.ObjectName = &dosdevW;
-    attr.Attributes = OBJ_CASE_INSENSITIVE;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-
-    status = NtOpenDirectoryObject( &handle, FILE_LIST_DIRECTORY, &attr );
-    if (status) return STATUS_BAD_DEVICE_TYPE;
-
-    while (!NtQueryDirectoryObject( handle, info, sizeof(data), TRUE, FALSE, &ctx, NULL ))
-    {
-        if (read_nt_symlink( handle, &info->ObjectName, symlinkW, MAX_DIR_ENTRY_LEN )) continue;
-        if (wcsnicmp( symlinkW, name, length )) continue;
-        if (info->ObjectName.Length != 2 * sizeof(WCHAR) || info->ObjectName.Buffer[1] != ':') continue;
-
-        *device_ret = info->ObjectName.Buffer[0];
-        NtClose( handle );
-        return STATUS_SUCCESS;
-    }
-
-    NtClose( handle );
-    return STATUS_BAD_DEVICE_TYPE;
-}
-
-/******************************************************************************
- *           nt_to_unix_file_name
- *
- * Convert a file name from NT namespace to Unix namespace.
- *
- * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
- * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
- * returned, but the unix name is still filled in properly.
- */
-NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
-{
-    static const WCHAR systemrootW[] = {'\\','S','y','s','t','e','m','R','o','o','t','\\',0};
-    static const WCHAR dosprefixW[] = {'\\','?','?','\\'};
-    static const WCHAR deviceW[] = {'\\','D','e','v','i','c','e','\\',0};
-    WCHAR *name, *ptr, *prefix, buffer[3] = {'c',':',0};
-    UNICODE_STRING dospathW, *nameW;
-    OBJECT_ATTRIBUTES attr_copy;
-    size_t offset, name_len;
-    NTSTATUS status;
-
-    if (attr->RootDirectory) return nt_to_unix_file_name_internal( attr, name_ret, disposition );
-
-    nameW = attr->ObjectName;
-
-    if (nameW->Length >= sizeof(deviceW) - sizeof(WCHAR)
-        && !wcsnicmp( nameW->Buffer, deviceW, ARRAY_SIZE(deviceW) - 1 ))
-    {
-        offset = sizeof(deviceW) / sizeof(WCHAR);
-        while (offset * sizeof(WCHAR) < nameW->Length && nameW->Buffer[ offset ] != '\\') offset++;
-        if ((status = nt_to_dos_device( nameW->Buffer, offset, buffer ))) return status;
-        prefix = buffer;
-    }
-    else if (nameW->Length >= sizeof(systemrootW) - sizeof(WCHAR) &&
-             !wcsnicmp( nameW->Buffer, systemrootW, ARRAY_SIZE(systemrootW) - 1 ))
-    {
-        offset = (sizeof(systemrootW) - 1) / sizeof(WCHAR);
-        prefix = user_shared_data->NtSystemRoot;
-    }
-    else
-        return nt_to_unix_file_name_internal( attr, name_ret, disposition );
-
-    name_len = sizeof(dosprefixW) + wcslen(prefix) * sizeof(WCHAR)
-               + sizeof(WCHAR) /* '\\' */ + nameW->Length - offset * sizeof(WCHAR) + sizeof(WCHAR);
-    if (!(name = malloc( name_len )))
-        return STATUS_NO_MEMORY;
-
-    ptr = name;
-    memcpy( ptr, dosprefixW, sizeof(dosprefixW) );
-    ptr += sizeof(dosprefixW) / sizeof(WCHAR);
-    wcscpy( ptr, prefix );
-    ptr += wcslen(ptr);
-    *ptr++ = '\\';
-    memcpy( ptr, nameW->Buffer + offset, nameW->Length - offset * sizeof(WCHAR) );
-    ptr[ nameW->Length / sizeof(WCHAR) - offset ] = 0;
-
-    dospathW.Buffer = name;
-    dospathW.Length = wcslen( name ) * sizeof(WCHAR);
-    attr_copy = *attr;
-    attr_copy.ObjectName = &dospathW;
-    status = nt_to_unix_file_name_internal( &attr_copy, name_ret, disposition );
-
-    free( name );
-    return status;
-}
-
 /******************************************************************************
  *           wine_nt_to_unix_file_name
  *
@@ -4976,8 +4659,8 @@
                 status = set_file_times( fd, &mtime, &atime );
 
             if (status == STATUS_SUCCESS)
-                status = fd_set_file_info( fd, handle, info->FileAttributes,
-                                           unix_name && is_hidden_file( unix_name ) );
+                status = fd_set_file_info( fd, info->FileAttributes,
+                                           unix_name && is_hidden_file( unix_name ));
 
             if (needs_close) close( fd );
             free( unix_name );
@@ -5017,15 +4700,6 @@
         else status = STATUS_INVALID_PARAMETER_3;
         break;
 
-    case FileAllocationInformation:
-    {
-        const FILE_ALLOCATION_INFORMATION *info = ptr;
-
-        FIXME("FileAllocationInformation AllocationSize %p stub.\n", (void *)(ULONG_PTR)info->AllocationSize.QuadPart);
-        io->Status = STATUS_SUCCESS;
-        break;
-    }
-
     case FilePipeInformation:
         if (len >= sizeof(FILE_PIPE_INFORMATION))
         {
@@ -5804,243 +5478,6 @@
     return status;
 }
 
-static pthread_mutex_t async_file_read_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t async_file_read_cond = PTHREAD_COND_INITIALIZER;
-
-struct async_file_read_job
-{
-    HANDLE handle;
-    int unix_handle;
-    int needs_close;
-    HANDLE event;
-    IO_STATUS_BLOCK *io;
-    void *buffer;
-    ULONG length;
-    LARGE_INTEGER offset;
-    DWORD thread_id;
-    LONG  cancelled;
-    struct list queue_entry;
-    struct async_file_read_job *next;
-    ULONG64 queue_time_mcs;
-};
-
-
-static struct list async_file_read_queue = LIST_INIT( async_file_read_queue );
-static struct async_file_read_job *async_file_read_running, *async_file_read_free;
-
-static void async_file_complete_io( struct async_file_read_job *job, NTSTATUS status, ULONG total )
-{
-    job->io->Status = status;
-    job->io->Information = total;
-
-    if (job->event) NtSetEvent( job->event, NULL );
-}
-
-static void *async_file_read_thread(void *dummy)
-{
-    struct async_file_read_job *job, *ptr;
-    ULONG buffer_length = 0;
-    void *buffer = NULL;
-    struct list *entry;
-    struct timespec ts;
-    NTSTATUS status;
-    ULONG64 delay;
-    ULONG total;
-    int result;
-
-    pthread_mutex_lock( &async_file_read_mutex );
-    while (1)
-    {
-        while (!(entry = list_head( &async_file_read_queue )))
-        {
-            pthread_cond_wait( &async_file_read_cond, &async_file_read_mutex );
-            continue;
-        }
-
-        job = LIST_ENTRY( entry, struct async_file_read_job, queue_entry );
-        list_remove( entry );
-
-        total = 0;
-
-        if ( job->cancelled )
-        {
-            pthread_mutex_unlock( &async_file_read_mutex );
-            status = STATUS_CANCELLED;
-            goto done;
-        }
-
-        job->next = async_file_read_running;
-        async_file_read_running = job;
-        pthread_mutex_unlock( &async_file_read_mutex );
-
-        if (!buffer_length)
-        {
-            buffer = malloc(job->length);
-            buffer_length = job->length;
-        }
-        else if (buffer_length < job->length)
-        {
-            buffer = realloc(buffer, job->length);
-            buffer_length = job->length;
-        }
-
-        while ((result = pread( job->unix_handle, buffer, job->length, job->offset.QuadPart )) == -1)
-        {
-            if (errno != EINTR)
-            {
-                status = errno_to_status( errno );
-                goto done;
-            }
-            if (job->cancelled)
-                break;
-        }
-
-        clock_gettime( CLOCK_MONOTONIC, &ts );
-        delay = ts.tv_sec * (ULONG64)1000000 + ts.tv_nsec / 1000 - job->queue_time_mcs;
-        if (delay < 1000)
-            usleep( 1000 - delay );
-        else
-            usleep( 50 );
-
-        total = result;
-        status = (total || !job->length) ? STATUS_SUCCESS : STATUS_END_OF_FILE;
-done:
-        if (job->needs_close) close( job->unix_handle );
-
-        if (!InterlockedCompareExchange(&job->cancelled, 1, 0))
-        {
-            if (status == STATUS_SUCCESS)
-                memcpy( job->buffer, buffer, total );
-
-            async_file_complete_io( job, status, total );
-        }
-
-        pthread_mutex_lock( &async_file_read_mutex );
-
-        if (status != STATUS_CANCELLED)
-        {
-            ptr = async_file_read_running;
-            if (job == ptr)
-            {
-                async_file_read_running = job->next;
-            }
-            else
-            {
-                while (ptr && ptr->next != job)
-                    ptr = ptr->next;
-
-                assert( ptr );
-                ptr->next = job->next;
-            }
-        }
-
-        job->next = async_file_read_free;
-        async_file_read_free = job;
-    }
-
-    return NULL;
-}
-
-static pthread_once_t async_file_read_once = PTHREAD_ONCE_INIT;
-
-static void async_file_read_init(void)
-{
-    pthread_t async_file_read_thread_id;
-    pthread_attr_t pthread_attr;
-
-    ERR("HACK: AC Odyssey async read workaround.\n");
-
-    pthread_attr_init( &pthread_attr );
-    pthread_attr_setscope( &pthread_attr, PTHREAD_SCOPE_SYSTEM );
-    pthread_attr_setdetachstate( &pthread_attr, PTHREAD_CREATE_DETACHED );
-
-    pthread_create( &async_file_read_thread_id, &pthread_attr, (void * (*)(void *))async_file_read_thread, NULL);
-    pthread_attr_destroy( &pthread_attr );
-}
-
-static NTSTATUS queue_async_file_read( HANDLE handle, int unix_handle, int needs_close, HANDLE event,
-                            IO_STATUS_BLOCK *io, void *buffer, ULONG length, LARGE_INTEGER *offset )
-{
-    struct async_file_read_job *job;
-    struct timespec ts;
-
-    pthread_once( &async_file_read_once, async_file_read_init );
-
-    NtResetEvent( event, NULL );
-
-    pthread_mutex_lock( &async_file_read_mutex );
-
-    if (async_file_read_free)
-    {
-        job = async_file_read_free;
-        async_file_read_free = async_file_read_free->next;
-    }
-    else
-    {
-        if (!(job = malloc( sizeof(*job) )))
-        {
-            pthread_mutex_unlock( &async_file_read_mutex );
-            return STATUS_NO_MEMORY;
-        }
-    }
-
-    job->handle = handle;
-    job->unix_handle = unix_handle;
-    job->needs_close = needs_close;
-    job->event = event;
-    job->io = io;
-    job->buffer = buffer;
-    job->length = length;
-    job->offset = *offset;
-    job->thread_id = GetCurrentThreadId();
-    job->cancelled = 0;
-    clock_gettime( CLOCK_MONOTONIC, &ts );
-    job->queue_time_mcs = ts.tv_sec * (ULONG64)1000000 + ts.tv_nsec / 1000;
-
-    list_add_tail( &async_file_read_queue, &job->queue_entry );
-
-    pthread_cond_signal( &async_file_read_cond );
-    pthread_mutex_unlock( &async_file_read_mutex );
-
-    return STATUS_PENDING;
-}
-
-static NTSTATUS cancel_async_file_read( HANDLE handle, IO_STATUS_BLOCK *io )
-{
-    DWORD thread_id = GetCurrentThreadId();
-    struct async_file_read_job *job;
-    unsigned int count = 0;
-
-    TRACE( "handle %p, io %p.\n", handle, io );
-
-    pthread_mutex_lock( &async_file_read_mutex );
-    job = async_file_read_running;
-    while (job)
-    {
-        if (((io && job->io == io)
-                || (!io && job->handle == handle && job->thread_id == thread_id))
-                && !InterlockedCompareExchange(&job->cancelled, 1, 0))
-        {
-            async_file_complete_io( job, STATUS_CANCELLED, 0 );
-            ++count;
-        }
-        job = job->next;
-    }
-
-    LIST_FOR_EACH_ENTRY( job, &async_file_read_queue, struct async_file_read_job, queue_entry )
-    {
-        if (((io && job->io == io)
-                || (!io && job->handle == handle && job->thread_id == thread_id))
-                && !InterlockedCompareExchange(&job->cancelled, 1, 0))
-        {
-            async_file_complete_io( job, STATUS_CANCELLED, 0 );
-            ++count;
-        }
-    }
-
-    pthread_mutex_unlock( &async_file_read_mutex );
-    return count ? STATUS_SUCCESS : STATUS_NOT_FOUND;
-}
 
 /******************************************************************************
  *              NtReadFile   (NTDLL.@)
@@ -6082,13 +5519,6 @@
             goto done;
         }
 
-        if (ac_odyssey && async_read && length && event && !apc)
-        {
-            status = queue_async_file_read( handle, unix_handle, needs_close, event, io, buffer, length, offset );
-            needs_close = 0;
-            goto err;
-        }
-
         if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
         {
             /* async I/O doesn't make sense on regular files */
@@ -6912,9 +6342,6 @@
 
     TRACE( "%p %p\n", handle, io_status );
 
-    if (ac_odyssey && !cancel_async_file_read( handle, NULL ))
-        return (io_status->Status = STATUS_SUCCESS);
-
     SERVER_START_REQ( cancel_async )
     {
         req->handle      = wine_server_obj_handle( handle );
@@ -6940,9 +6367,6 @@
 
     TRACE( "%p %p %p\n", handle, io, io_status );
 
-    if (ac_odyssey && !cancel_async_file_read( handle, io ))
-        return (io_status->Status = STATUS_SUCCESS);
-
     SERVER_START_REQ( cancel_async )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -7292,7 +6716,7 @@
     }
     else if (S_ISFIFO( st.st_mode ) || S_ISSOCK( st.st_mode ))
     {
-        info->DeviceType = FILE_DEVICE_UNKNOWN;
+        info->DeviceType = FILE_DEVICE_NAMED_PIPE;
     }
     else if (is_device_placeholder( fd ))
     {
@@ -7401,11 +6825,10 @@
                                               void *buffer, ULONG length,
                                               FS_INFORMATION_CLASS info_class )
 {
-    enum server_fd_type fd_type;
     int fd, needs_close;
     unsigned int status;
 
-    status = server_get_unix_fd( handle, 0, &fd, &needs_close, &fd_type, NULL );
+    status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
     if (status == STATUS_BAD_DEVICE_TYPE)
     {
         struct async_irp *async;
@@ -7472,15 +6895,7 @@
         {
             FILE_FS_DEVICE_INFORMATION *info = buffer;
 
-            if (fd_type == FD_TYPE_SOCKET)
-            {
-                info->Characteristics = 0;
-                info->DeviceType = FILE_DEVICE_NAMED_PIPE;
-                status = STATUS_SUCCESS;
-            }
-            else status = get_device_info( fd, info );
-
-            if (!status)
+            if ((status = get_device_info( fd, info )) == STATUS_SUCCESS)
                 io->Information = sizeof(*info);
         }
         break;
@@ -7621,17 +7036,6 @@
                 io->Information = sizeof(*info);
         }
         break;
-
-    case FileFsFullSizeInformationEx:
-        if (length < sizeof(FILE_FS_FULL_SIZE_INFORMATION_EX))
-            status = STATUS_BUFFER_TOO_SMALL;
-        else
-        {
-            FILE_FS_FULL_SIZE_INFORMATION_EX *info = buffer;
-            if ((status = get_full_size_info_ex(fd, info)) == STATUS_SUCCESS)
-                io->Information = sizeof(*info);
-        }
-        break;
 
     case FileFsObjectIdInformation:
         FIXME( "%p: object id info not supported\n", handle );
