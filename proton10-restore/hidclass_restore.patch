diff -urN wine_proton10/dlls/hidclass.sys/device.c wine-10.0/dlls/hidclass.sys/device.c
--- wine_proton10/dlls/hidclass.sys/device.c	2025-11-05 17:27:18.791953638 +0800
+++ wine-10.0/dlls/hidclass.sys/device.c	2025-01-22 00:42:16.000000000 +0800
@@ -216,23 +216,20 @@
     return report;
 }
 
-static void hid_device_queue_input( struct phys_device *pdo, HID_XFER_PACKET *packet, BOOL polled )
+static void hid_device_queue_input( DEVICE_OBJECT *device, HID_XFER_PACKET *packet, BOOL polled )
 {
-    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    HIDP_COLLECTION_DESC *desc = ext->u.pdo.collection_desc;
     ULONG size, report_len = polled ? packet->reportBufferLen : desc->InputLength;
     struct hid_report *last_report, *report;
-    BOOL steam_overlay_open = FALSE;
     struct hid_queue *queue;
     LIST_ENTRY completed, *entry;
     KIRQL irql;
     IRP *irp;
 
-    TRACE( "pdo %p, packet %p\n", pdo, packet );
+    TRACE("device %p, packet %p\n", device, packet);
 
-    if (WaitForSingleObject( pdo->base.steam_overlay_event, 0 ) == WAIT_OBJECT_0) /* steam overlay is open */
-        steam_overlay_open = TRUE;
-
-    if (IsEqualGUID( pdo->base.class_guid, &GUID_DEVINTERFACE_HID ) && !steam_overlay_open)
+    if (IsEqualGUID( ext->class_guid, &GUID_DEVINTERFACE_HID ))
     {
         struct hid_packet *hid;
 
@@ -246,7 +243,7 @@
             input.hi.wParamH = HIWORD(RIM_INPUT);
             input.hi.wParamL = LOWORD(RIM_INPUT);
 
-            hid->head.device = pdo->rawinput_handle;
+            hid->head.device = ext->u.pdo.rawinput_handle;
             hid->head.usage = MAKELONG(desc->Usage, desc->UsagePage);
 
             hid->head.count = 1;
@@ -267,9 +264,9 @@
 
     InitializeListHead( &completed );
 
-    KeAcquireSpinLock( &pdo->lock, &irql );
-    if (pdo->removed) WARN( "Device has been removed, dropping report\n" );
-    else LIST_FOR_EACH_ENTRY( queue, &pdo->queues, struct hid_queue, entry )
+    KeAcquireSpinLock( &ext->u.pdo.lock, &irql );
+    if (ext->u.pdo.removed) WARN( "Device has been removed, dropping report\n" );
+    else LIST_FOR_EACH_ENTRY( queue, &ext->u.pdo.queues, struct hid_queue, entry )
     {
         if (!polled) hid_queue_push_report( queue, last_report );
 
@@ -287,7 +284,7 @@
         }
         while (polled);
     }
-    KeReleaseSpinLock( &pdo->lock, irql );
+    KeReleaseSpinLock( &ext->u.pdo.lock, irql );
 
     while ((entry = RemoveHeadList( &completed )) != &completed)
     {
@@ -298,7 +295,7 @@
     hid_report_decref( last_report );
 }
 
-HIDP_REPORT_IDS *find_report_with_type_and_id( HIDP_DEVICE_DESC *desc, UCHAR collection, BYTE type, BYTE id, BOOL any_id )
+static HIDP_REPORT_IDS *find_report_with_type_and_id( HIDP_DEVICE_DESC *desc, UCHAR collection, BYTE type, BYTE id, BOOL any_id )
 {
     HIDP_REPORT_IDS *report, *reports = desc->ReportIDs;
     ULONG report_count = desc->ReportIDsLength;
@@ -318,55 +315,75 @@
 DWORD CALLBACK hid_device_thread(void *args)
 {
     DEVICE_OBJECT *device = (DEVICE_OBJECT*)args;
-    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    ULONG i, input_length = 0, report_id = 0;
     HIDP_REPORT_IDS *report;
+    HID_XFER_PACKET *packet;
+    HIDP_DEVICE_DESC *desc;
+    IO_STATUS_BLOCK io;
     NTSTATUS status;
+    BYTE *buffer;
+    IRP *irp;
+
+    for (i = 0; i < ext->u.fdo.device_desc.CollectionDescLength; i++)
+    {
+        HIDP_COLLECTION_DESC *desc = ext->u.fdo.device_desc.CollectionDesc + i;
+        input_length = max(input_length, desc->InputLength);
+    }
+
+    packet = malloc( sizeof(*packet) + input_length );
+    buffer = (BYTE *)(packet + 1);
+
+    desc = &ext->u.fdo.device_desc;
+    report = find_report_with_type_and_id( desc, 0, HidP_Input, 0, TRUE );
+    if (!report) WARN("no input report found.\n");
+    else report_id = report->ReportID;
 
     do
     {
-        LARGE_INTEGER delay = {.QuadPart = (LONGLONG)fdo->poll_interval * -10000};
-        HID_XFER_PACKET packet = *fdo->io_packet;
-        BYTE *buffer = packet.reportBuffer;
-        KEVENT *io_event = &fdo->io_event;
-        IO_STATUS_BLOCK *io = &fdo->io;
+        LARGE_INTEGER delay = {.QuadPart = (LONGLONG)ext->u.fdo.poll_interval * -10000};
+        KEVENT irp_event;
+
+        packet->reportId = buffer[0] = report_id;
+        packet->reportBuffer = buffer;
+        packet->reportBufferLen = input_length;
 
-        if (!(packet.reportBuffer[0] = packet.reportId))
+        if (!report_id)
         {
-            packet.reportBuffer++;
-            packet.reportBufferLen--;
+            packet->reportBuffer++;
+            packet->reportBufferLen--;
         }
 
-        KeInitializeEvent( io_event, NotificationEvent, FALSE );
-        fdo->io_irp = IoBuildDeviceIoControlRequest( IOCTL_HID_READ_REPORT, device, NULL, 0, packet.reportBuffer,
-                                                     packet.reportBufferLen, TRUE, io_event, io );
-        if (IoCallDriver( device, fdo->io_irp ) == STATUS_PENDING)
+        KeInitializeEvent( &irp_event, NotificationEvent, FALSE );
+        irp = IoBuildDeviceIoControlRequest( IOCTL_HID_READ_REPORT, device, NULL, 0, packet->reportBuffer,
+                                             packet->reportBufferLen, TRUE, &irp_event, &io );
+        if (IoCallDriver( device, irp ) == STATUS_PENDING)
         {
-            void *events[2] = {io_event, &fdo->halt_event};
+            void *events[2] = {&irp_event, &ext->u.fdo.halt_event};
             status = KeWaitForMultipleObjects( 2, events, WaitAny, Executive, KernelMode, FALSE, NULL, NULL );
             if (status) break;
         }
-        fdo->io_irp = NULL;
 
-        if (io->Status == STATUS_SUCCESS)
+        if (io.Status == STATUS_SUCCESS)
         {
-            if (!packet.reportId) io->Information++;
-            if (!(report = find_report_with_type_and_id( &fdo->device_desc, 0, HidP_Input, buffer[0], FALSE )))
+            if (!report_id) io.Information++;
+            if (!(report = find_report_with_type_and_id( desc, 0, HidP_Input, buffer[0], FALSE )))
                 ERR( "dropping unknown input id %u\n", buffer[0] );
-            else if (!fdo->poll_interval && io->Information < report->InputLength)
-                ERR( "dropping short report, len %Iu expected %u\n", io->Information, report->InputLength );
-            else if (!report->CollectionNumber || report->CollectionNumber > fdo->child_count)
+            else if (!ext->u.fdo.poll_interval && io.Information < report->InputLength)
+                ERR( "dropping short report, len %Iu expected %u\n", io.Information, report->InputLength );
+            else if (!report->CollectionNumber || report->CollectionNumber > ext->u.fdo.child_count)
                 ERR( "dropping report for unknown child %u\n", report->CollectionNumber );
             else
             {
-                struct phys_device *pdo = pdo_from_DEVICE_OBJECT( fdo->child_pdos[report->CollectionNumber - 1] );
-                packet.reportId = buffer[0];
-                packet.reportBuffer = buffer;
-                packet.reportBufferLen = io->Information;
-                hid_device_queue_input( pdo, &packet, !!fdo->poll_interval );
+                DEVICE_OBJECT *pdo = ext->u.fdo.child_pdos[report->CollectionNumber - 1];
+                packet->reportId = buffer[0];
+                packet->reportBuffer = buffer;
+                packet->reportBufferLen = io.Information;
+                hid_device_queue_input( pdo, packet, !!ext->u.fdo.poll_interval );
             }
         }
 
-        status = KeWaitForSingleObject( &fdo->halt_event, Executive, KernelMode, FALSE, &delay );
+        status = KeWaitForSingleObject( &ext->u.fdo.halt_event, Executive, KernelMode, FALSE, &delay );
     } while (status == STATUS_TIMEOUT);
 
     if (status) WARN( "device thread exiting with status %#lx\n", status );
@@ -382,8 +399,6 @@
 
 static const struct device_strings device_strings[] =
 {
-    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
-    { .id = L"VID_28DE&PID_11FF", .product = L"Controller (XBOX 360 For Windows)" },
     /* Microsoft controllers */
     { .id = L"VID_045E&PID_028E", .product = L"Controller (XBOX 360 For Windows)" },
     { .id = L"VID_045E&PID_028F", .product = L"Controller (XBOX 360 For Windows)" },
@@ -441,12 +456,12 @@
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS hid_device_xfer_report( struct phys_device *pdo, ULONG code, IRP *irp )
+static NTSTATUS hid_device_xfer_report( BASE_DEVICE_EXTENSION *ext, ULONG code, IRP *irp )
 {
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
-    ULONG offset, report_len = 0, buffer_len = 0, collection = pdo->collection_desc->CollectionNumber;
-    struct func_device *fdo = fdo_from_DEVICE_OBJECT( pdo->parent_fdo );
-    HIDP_DEVICE_DESC *desc = &fdo->device_desc;
+    ULONG offset, report_len = 0, buffer_len = 0, collection = ext->u.pdo.collection_desc->CollectionNumber;
+    BASE_DEVICE_EXTENSION *fdo_ext = ext->u.pdo.parent_fdo->DeviceExtension;
+    HIDP_DEVICE_DESC *desc = &fdo_ext->u.fdo.device_desc;
     struct completion_params *params;
     HIDP_REPORT_IDS *report = NULL;
     BYTE *buffer = NULL;
@@ -500,7 +515,7 @@
     case IOCTL_HID_GET_FEATURE:
     case IOCTL_HID_GET_INPUT_REPORT:
         params->packet.reportBufferLen = buffer_len - offset;
-        irp = IoBuildDeviceIoControlRequest( code, pdo->parent_fdo, NULL, 0, &params->packet,
+        irp = IoBuildDeviceIoControlRequest( code, ext->u.pdo.parent_fdo, NULL, 0, &params->packet,
                                              sizeof(params->packet), TRUE, NULL, NULL );
         break;
     case IOCTL_HID_WRITE_REPORT:
@@ -509,7 +524,7 @@
     case IOCTL_HID_SET_FEATURE:
     case IOCTL_HID_SET_OUTPUT_REPORT:
         params->packet.reportBufferLen = report_len - offset;
-        irp = IoBuildDeviceIoControlRequest( code, pdo->parent_fdo, NULL, sizeof(params->packet),
+        irp = IoBuildDeviceIoControlRequest( code, ext->u.pdo.parent_fdo, NULL, sizeof(params->packet),
                                              &params->packet, 0, TRUE, NULL, NULL );
         break;
     }
@@ -522,14 +537,14 @@
 
     IoMarkIrpPending( params->irp );
     IoSetCompletionRoutine( irp, xfer_completion, params, TRUE, TRUE, TRUE );
-    IoCallDriver( pdo->parent_fdo, irp );
+    IoCallDriver( ext->u.pdo.parent_fdo, irp );
     return STATUS_PENDING;
 }
 
-NTSTATUS WINAPI pdo_ioctl( DEVICE_OBJECT *device, IRP *irp )
+NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
 {
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
-    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     NTSTATUS status = irp->IoStatus.Status;
     ULONG code, index;
     const WCHAR *str;
@@ -540,9 +555,9 @@
 
     TRACE( "device %p code %#lx\n", device, irpsp->Parameters.DeviceIoControl.IoControlCode );
 
-    KeAcquireSpinLock( &pdo->lock, &irql );
-    removed = pdo->removed;
-    KeReleaseSpinLock( &pdo->lock, irql );
+    KeAcquireSpinLock(&ext->u.pdo.lock, &irql);
+    removed = ext->u.pdo.removed;
+    KeReleaseSpinLock(&ext->u.pdo.lock, irql);
 
     if (removed)
     {
@@ -558,8 +573,7 @@
                 status = STATUS_BUFFER_OVERFLOW;
             else
             {
-                struct func_device *fdo = fdo_from_DEVICE_OBJECT( pdo->parent_fdo );
-                *(ULONG *)irp->AssociatedIrp.SystemBuffer = fdo->poll_interval;
+                *(ULONG *)irp->AssociatedIrp.SystemBuffer = ext->u.fdo.poll_interval;
                 irp->IoStatus.Information = sizeof(ULONG);
                 status = STATUS_SUCCESS;
             }
@@ -571,9 +585,8 @@
                 status = STATUS_BUFFER_TOO_SMALL;
             else
             {
-                struct func_device *fdo = fdo_from_DEVICE_OBJECT( pdo->parent_fdo );
                 poll_interval = *(ULONG *)irp->AssociatedIrp.SystemBuffer;
-                if (poll_interval) fdo->poll_interval = min( poll_interval, MAX_POLL_INTERVAL_MSEC );
+                if (poll_interval) ext->u.fdo.poll_interval = min( poll_interval, MAX_POLL_INTERVAL_MSEC );
                 status = STATUS_SUCCESS;
             }
             break;
@@ -589,7 +602,7 @@
             if (code == IOCTL_HID_GET_SERIALNUMBER_STRING) index = HID_STRING_ID_ISERIALNUMBER;
             if (code == IOCTL_HID_GET_MANUFACTURER_STRING) index = HID_STRING_ID_IMANUFACTURER;
 
-            if ((str = find_device_string( pdo->base.device_id, index )))
+            if ((str = find_device_string( ext->device_id, index )))
             {
                 irp->IoStatus.Information = (wcslen( str ) + 1) * sizeof(WCHAR);
                 if (irp->IoStatus.Information > output_len)
@@ -602,7 +615,7 @@
                 break;
             }
 
-            call_minidriver( IOCTL_HID_GET_STRING, pdo->parent_fdo, ULongToPtr( index ),
+            call_minidriver( IOCTL_HID_GET_STRING, ext->u.pdo.parent_fdo, ULongToPtr( index ),
                              sizeof(index), output_buf, output_len, &irp->IoStatus );
             status = irp->IoStatus.Status;
             break;
@@ -614,7 +627,7 @@
                 status = STATUS_BUFFER_OVERFLOW;
             else
             {
-                memcpy( irp->AssociatedIrp.SystemBuffer, &pdo->information,
+                memcpy( irp->AssociatedIrp.SystemBuffer, &ext->u.pdo.information,
                         sizeof(HID_COLLECTION_INFORMATION) );
                 status = STATUS_SUCCESS;
             }
@@ -622,7 +635,7 @@
         }
         case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
         {
-            HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+            HIDP_COLLECTION_DESC *desc = ext->u.pdo.collection_desc;
 
             irp->IoStatus.Information = desc->PreparsedDataLength;
             if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < desc->PreparsedDataLength)
@@ -662,7 +675,7 @@
         case IOCTL_HID_SET_FEATURE:
         case IOCTL_HID_GET_INPUT_REPORT:
         case IOCTL_HID_SET_OUTPUT_REPORT:
-            status = hid_device_xfer_report( pdo, code, irp );
+            status = hid_device_xfer_report( ext, code, irp );
             break;
 
         case IOCTL_HID_GET_WINE_RAWINPUT_HANDLE:
@@ -670,7 +683,7 @@
                 status = STATUS_BUFFER_OVERFLOW;
             else
             {
-                *(ULONG *)irp->AssociatedIrp.SystemBuffer = pdo->rawinput_handle;
+                *(ULONG *)irp->AssociatedIrp.SystemBuffer = ext->u.pdo.rawinput_handle;
                 irp->IoStatus.Information = sizeof(ULONG);
                 status = STATUS_SUCCESS;
             }
@@ -694,19 +707,19 @@
     return status;
 }
 
-NTSTATUS WINAPI pdo_read( DEVICE_OBJECT *device, IRP *irp )
+NTSTATUS WINAPI pdo_read(DEVICE_OBJECT *device, IRP *irp)
 {
     struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
-    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
-    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    HIDP_COLLECTION_DESC *desc = ext->u.pdo.collection_desc;
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation(irp);
     struct hid_report *report;
     BOOL removed;
     KIRQL irql;
 
-    KeAcquireSpinLock( &pdo->lock, &irql );
-    removed = pdo->removed;
-    KeReleaseSpinLock( &pdo->lock, irql );
+    KeAcquireSpinLock(&ext->u.pdo.lock, &irql);
+    removed = ext->u.pdo.removed;
+    KeReleaseSpinLock(&ext->u.pdo.lock, irql);
 
     if (removed)
     {
@@ -738,10 +751,10 @@
 
 }
 
-NTSTATUS WINAPI pdo_write( DEVICE_OBJECT *device, IRP *irp )
+NTSTATUS WINAPI pdo_write(DEVICE_OBJECT *device, IRP *irp)
 {
-    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
-    NTSTATUS status = hid_device_xfer_report( pdo, IOCTL_HID_WRITE_REPORT, irp );
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    NTSTATUS status = hid_device_xfer_report( ext, IOCTL_HID_WRITE_REPORT, irp );
     if (status != STATUS_PENDING)
     {
         irp->IoStatus.Status = status;
@@ -750,18 +763,18 @@
     return status;
 }
 
-NTSTATUS WINAPI pdo_create( DEVICE_OBJECT *device, IRP *irp )
+NTSTATUS WINAPI pdo_create(DEVICE_OBJECT *device, IRP *irp)
 {
-    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     struct hid_queue *queue;
     BOOL removed;
     KIRQL irql;
 
     TRACE("Open handle on device %p\n", device);
 
-    KeAcquireSpinLock( &pdo->lock, &irql );
-    removed = pdo->removed;
-    KeReleaseSpinLock( &pdo->lock, irql );
+    KeAcquireSpinLock( &ext->u.pdo.lock, &irql );
+    removed = ext->u.pdo.removed;
+    KeReleaseSpinLock( &ext->u.pdo.lock, irql );
 
     if (removed)
     {
@@ -773,9 +786,9 @@
     if (!(queue = hid_queue_create())) irp->IoStatus.Status = STATUS_NO_MEMORY;
     else
     {
-        KeAcquireSpinLock( &pdo->lock, &irql );
-        list_add_tail( &pdo->queues, &queue->entry );
-        KeReleaseSpinLock( &pdo->lock, irql );
+        KeAcquireSpinLock( &ext->u.pdo.lock, &irql );
+        list_add_tail( &ext->u.pdo.queues, &queue->entry );
+        KeReleaseSpinLock( &ext->u.pdo.lock, irql );
 
         irp->Tail.Overlay.OriginalFileObject->FsContext = queue;
         irp->IoStatus.Status = STATUS_SUCCESS;
@@ -785,18 +798,18 @@
     return STATUS_SUCCESS;
 }
 
-NTSTATUS WINAPI pdo_close( DEVICE_OBJECT *device, IRP *irp )
+NTSTATUS WINAPI pdo_close(DEVICE_OBJECT *device, IRP *irp)
 {
     struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
-    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     BOOL removed;
     KIRQL irql;
 
     TRACE("Close handle on device %p\n", device);
 
-    KeAcquireSpinLock( &pdo->lock, &irql );
-    removed = pdo->removed;
-    KeReleaseSpinLock( &pdo->lock, irql );
+    KeAcquireSpinLock( &ext->u.pdo.lock, &irql );
+    removed = ext->u.pdo.removed;
+    KeReleaseSpinLock( &ext->u.pdo.lock, irql );
 
     if (removed)
     {
@@ -807,9 +820,9 @@
 
     if (queue)
     {
-        KeAcquireSpinLock( &pdo->lock, &irql );
+        KeAcquireSpinLock( &ext->u.pdo.lock, &irql );
         list_remove( &queue->entry );
-        KeReleaseSpinLock( &pdo->lock, irql );
+        KeReleaseSpinLock( &ext->u.pdo.lock, irql );
         hid_queue_destroy( queue );
     }
 
diff -urN wine_proton10/dlls/hidclass.sys/hid.h wine-10.0/dlls/hidclass.sys/hid.h
--- wine_proton10/dlls/hidclass.sys/hid.h	2025-11-05 17:27:18.791953638 +0800
+++ wine-10.0/dlls/hidclass.sys/hid.h	2025-01-22 00:42:16.000000000 +0800
@@ -39,73 +39,57 @@
 /* Ring buffer functions */
 struct ReportRingBuffer;
 
-struct device
+typedef struct _BASE_DEVICE_EXTENSION
 {
-    HID_DEVICE_EXTENSION hid; /* must be first */
+    union
+    {
+        struct
+        {
+            /* this must be the first member */
+            HID_DEVICE_EXTENSION hid_ext;
+
+            HID_DEVICE_ATTRIBUTES attrs;
+            HIDP_DEVICE_DESC device_desc;
+            WCHAR serial[256];
+
+            ULONG poll_interval;
+            KEVENT halt_event;
+            HANDLE thread;
+
+            DEVICE_OBJECT **child_pdos;
+            UINT child_count;
+        } fdo;
+
+        struct
+        {
+            DEVICE_OBJECT *parent_fdo;
+
+            HIDP_COLLECTION_DESC *collection_desc;
+            HID_COLLECTION_INFORMATION information;
+
+            UINT32 rawinput_handle;
+            UNICODE_STRING link_name;
+
+            KSPIN_LOCK lock;
+            struct list queues;
+            BOOL removed;
+
+            BOOL is_mouse;
+            UNICODE_STRING mouse_link_name;
+            BOOL is_keyboard;
+            UNICODE_STRING keyboard_link_name;
+        } pdo;
+    } u;
 
+    /* These are unique to the parent FDO, but stored in the children as well
+     * for convenience. */
     WCHAR device_id[MAX_DEVICE_ID_LEN];
     WCHAR instance_id[MAX_DEVICE_ID_LEN];
     WCHAR container_id[MAX_GUID_STRING_LEN];
     const GUID *class_guid;
 
-    HANDLE steam_overlay_event;
-
     BOOL is_fdo;
-};
-
-struct func_device
-{
-    struct device base;
-    HID_DEVICE_ATTRIBUTES attrs;
-    HIDP_DEVICE_DESC device_desc;
-    WCHAR serial[256];
-
-    ULONG poll_interval;
-    KEVENT halt_event;
-    HANDLE thread;
-
-    HID_XFER_PACKET *io_packet;
-    IO_STATUS_BLOCK io;
-    KEVENT io_event;
-    IRP *io_irp;
-
-    DEVICE_OBJECT **child_pdos;
-    UINT child_count;
-};
-
-struct phys_device
-{
-    struct device base;
-    DEVICE_OBJECT *parent_fdo;
-
-    HIDP_COLLECTION_DESC *collection_desc;
-    HID_COLLECTION_INFORMATION information;
-
-    UINT32 rawinput_handle;
-    UNICODE_STRING link_name;
-
-    KSPIN_LOCK lock;
-    struct list queues;
-    BOOL removed;
-
-    BOOL is_mouse;
-    UNICODE_STRING mouse_link_name;
-    BOOL is_keyboard;
-    UNICODE_STRING keyboard_link_name;
-};
-
-static inline struct phys_device *pdo_from_DEVICE_OBJECT( DEVICE_OBJECT *device )
-{
-    struct device *impl = device->DeviceExtension;
-    return CONTAINING_RECORD( impl, struct phys_device, base );
-}
-
-static inline struct func_device *fdo_from_DEVICE_OBJECT( DEVICE_OBJECT *device )
-{
-    struct device *impl = device->DeviceExtension;
-    if (!impl->is_fdo) impl = pdo_from_DEVICE_OBJECT( device )->parent_fdo->DeviceExtension;
-    return CONTAINING_RECORD( impl, struct func_device, base );
-}
+} BASE_DEVICE_EXTENSION;
 
 struct hid_report
 {
@@ -135,14 +119,10 @@
 
     PDRIVER_ADD_DEVICE AddDevice;
     PDRIVER_DISPATCH PNPDispatch;
-
-    HANDLE steam_overlay_event;
 } minidriver;
 
 void call_minidriver( ULONG code, DEVICE_OBJECT *device, void *in_buff, ULONG in_size,
                       void *out_buff, ULONG out_size, IO_STATUS_BLOCK *io );
-HIDP_REPORT_IDS *find_report_with_type_and_id( HIDP_DEVICE_DESC *desc, UCHAR collection,
-                                               BYTE type, BYTE id, BOOL any_id );
 
 /* Internal device functions */
 DWORD CALLBACK hid_device_thread(void *args);
diff -urN wine_proton10/dlls/hidclass.sys/pnp.c wine-10.0/dlls/hidclass.sys/pnp.c
--- wine_proton10/dlls/hidclass.sys/pnp.c	2025-11-05 17:27:18.792953637 +0800
+++ wine-10.0/dlls/hidclass.sys/pnp.c	2025-01-22 00:42:16.000000000 +0800
@@ -111,21 +111,21 @@
 /* make sure bRawData can hold UsagePage and Usage without requiring additional allocation */
 C_ASSERT(offsetof(RAWINPUT, data.hid.bRawData[2 * sizeof(USAGE)]) < sizeof(RAWINPUT));
 
-static void send_wm_input_device_change( struct phys_device *pdo, LPARAM param )
+static void send_wm_input_device_change(BASE_DEVICE_EXTENSION *ext, LPARAM param)
 {
-    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    HIDP_COLLECTION_DESC *desc = ext->u.pdo.collection_desc;
     INPUT input = {.type = INPUT_HARDWARE};
     struct hid_packet hid = {0};
 
-    TRACE( "pdo %p, lparam %p\n", pdo, (void *)param );
+    TRACE("ext %p, lparam %p\n", ext, (void *)param);
 
-    if (!IsEqualGUID( pdo->base.class_guid, &GUID_DEVINTERFACE_HID )) return;
+    if (!IsEqualGUID( ext->class_guid, &GUID_DEVINTERFACE_HID )) return;
 
     input.hi.uMsg = WM_INPUT_DEVICE_CHANGE;
     input.hi.wParamH = HIWORD(param);
     input.hi.wParamL = LOWORD(param);
 
-    hid.head.device = pdo->rawinput_handle;
+    hid.head.device = ext->u.pdo.rawinput_handle;
     hid.head.usage = MAKELONG(desc->Usage, desc->UsagePage);
     NtUserSendHardwareInput(0, 0, &input, (LPARAM)&hid);
 }
@@ -133,9 +133,9 @@
 static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *bus_pdo)
 {
     WCHAR device_id[MAX_DEVICE_ID_LEN], instance_id[MAX_DEVICE_ID_LEN];
-    struct func_device *fdo;
+    BASE_DEVICE_EXTENSION *ext;
     BOOL is_xinput_class;
-    DEVICE_OBJECT *device;
+    DEVICE_OBJECT *fdo;
     NTSTATUS status;
     minidriver *minidriver;
 
@@ -154,39 +154,37 @@
     TRACE("Adding device to PDO %p, id %s\\%s.\n", bus_pdo, debugstr_w(device_id), debugstr_w(instance_id));
     minidriver = find_minidriver(driver);
 
-    if ((status = IoCreateDevice( driver, sizeof(*fdo) + minidriver->minidriver.DeviceExtensionSize,
-                                  NULL, FILE_DEVICE_BUS_EXTENDER, 0, FALSE, &device )))
+    if ((status = IoCreateDevice(driver, sizeof(*ext) + minidriver->minidriver.DeviceExtensionSize,
+            NULL, FILE_DEVICE_BUS_EXTENDER, 0, FALSE, &fdo)))
     {
         ERR( "Failed to create bus FDO, status %#lx.\n", status );
         return status;
     }
-    fdo = device->DeviceExtension;
-    fdo->base.is_fdo = TRUE;
-    fdo->base.hid.MiniDeviceExtension = fdo + 1;
-    fdo->base.hid.PhysicalDeviceObject = bus_pdo;
-    fdo->base.hid.NextDeviceObject = bus_pdo;
-    swprintf( fdo->base.device_id, ARRAY_SIZE(fdo->base.device_id), L"HID\\%s", wcsrchr( device_id, '\\' ) + 1 );
-    wcscpy( fdo->base.instance_id, instance_id );
+    ext = fdo->DeviceExtension;
+    ext->is_fdo = TRUE;
+    ext->u.fdo.hid_ext.MiniDeviceExtension = ext + 1;
+    ext->u.fdo.hid_ext.PhysicalDeviceObject = bus_pdo;
+    ext->u.fdo.hid_ext.NextDeviceObject = bus_pdo;
+    swprintf(ext->device_id, ARRAY_SIZE(ext->device_id), L"HID\\%s", wcsrchr(device_id, '\\') + 1);
+    wcscpy(ext->instance_id, instance_id);
 
-    if (get_device_id( bus_pdo, BusQueryContainerID, fdo->base.container_id ))
-        fdo->base.container_id[0] = 0;
-
-    fdo->base.steam_overlay_event = minidriver->steam_overlay_event;
+    if (get_device_id(bus_pdo, BusQueryContainerID, ext->container_id))
+        ext->container_id[0] = 0;
 
     is_xinput_class = !wcsncmp(device_id, L"WINEXINPUT\\", 7) && wcsstr(device_id, L"&XI_") != NULL;
-    if (is_xinput_class) fdo->base.class_guid = &GUID_DEVINTERFACE_WINEXINPUT;
-    else fdo->base.class_guid = &GUID_DEVINTERFACE_HID;
+    if (is_xinput_class) ext->class_guid = &GUID_DEVINTERFACE_WINEXINPUT;
+    else ext->class_guid = &GUID_DEVINTERFACE_HID;
 
-    status = minidriver->AddDevice( minidriver->minidriver.DriverObject, device );
+    status = minidriver->AddDevice(minidriver->minidriver.DriverObject, fdo);
     if (status != STATUS_SUCCESS)
     {
         ERR( "Minidriver AddDevice failed (%lx)\n", status );
-        IoDeleteDevice( device );
+        IoDeleteDevice(fdo);
         return status;
     }
 
-    IoAttachDeviceToDeviceStack( device, bus_pdo );
-    device->Flags &= ~DO_DEVICE_INITIALIZING;
+    IoAttachDeviceToDeviceStack(fdo, bus_pdo);
+    fdo->Flags &= ~DO_DEVICE_INITIALIZING;
 
     return STATUS_SUCCESS;
 }
@@ -219,13 +217,13 @@
 
 static NTSTATUS initialize_device( minidriver *minidriver, DEVICE_OBJECT *device )
 {
-    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     ULONG index = HID_STRING_ID_ISERIALNUMBER;
     IO_STATUS_BLOCK io;
     NTSTATUS status;
 
-    call_minidriver( IOCTL_HID_GET_DEVICE_ATTRIBUTES, device, NULL, 0, &fdo->attrs,
-                     sizeof(fdo->attrs), &io );
+    call_minidriver( IOCTL_HID_GET_DEVICE_ATTRIBUTES, device, NULL, 0, &ext->u.fdo.attrs,
+                     sizeof(ext->u.fdo.attrs), &io );
     if (io.Status != STATUS_SUCCESS)
     {
         ERR( "Minidriver failed to get attributes, status %#lx.\n", io.Status );
@@ -233,127 +231,100 @@
     }
 
     call_minidriver( IOCTL_HID_GET_STRING, device, ULongToPtr(index), sizeof(index),
-                     &fdo->serial, sizeof(fdo->serial), &io );
+                     &ext->u.fdo.serial, sizeof(ext->u.fdo.serial), &io );
     if (io.Status != STATUS_SUCCESS)
     {
         ERR( "Minidriver failed to get serial number, status %#lx.\n", io.Status );
         return io.Status;
     }
 
-    if ((status = get_hid_device_desc( minidriver, device, &fdo->device_desc )))
+    if ((status = get_hid_device_desc( minidriver, device, &ext->u.fdo.device_desc )))
     {
         ERR( "Failed to get HID device description, status %#lx\n", status );
         return status;
     }
 
-    if (!(fdo->child_pdos = malloc( fdo->device_desc.CollectionDescLength * sizeof(*fdo->child_pdos) )))
+    if (!(ext->u.fdo.child_pdos = malloc( ext->u.fdo.device_desc.CollectionDescLength * sizeof(*ext->u.fdo.child_pdos) )))
     {
         ERR( "Cannot allocate child PDOs array\n" );
         return STATUS_NO_MEMORY;
     }
 
-    fdo->poll_interval = minidriver->minidriver.DevicesArePolled ? DEFAULT_POLL_INTERVAL : 0;
-    KeInitializeEvent( &fdo->halt_event, NotificationEvent, FALSE );
+    ext->u.fdo.poll_interval = minidriver->minidriver.DevicesArePolled ? DEFAULT_POLL_INTERVAL : 0;
+    KeInitializeEvent( &ext->u.fdo.halt_event, NotificationEvent, FALSE );
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS create_child_pdos( minidriver *minidriver, DEVICE_OBJECT *device )
 {
-    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
-    DEVICE_OBJECT *child_device;
-    struct phys_device *pdo;
+    BASE_DEVICE_EXTENSION *fdo_ext = device->DeviceExtension, *pdo_ext;
+    DEVICE_OBJECT *child_pdo;
     UNICODE_STRING string;
     WCHAR pdo_name[255];
     USAGE page, usage;
     NTSTATUS status;
     INT i;
 
-    for (i = 0; i < fdo->device_desc.CollectionDescLength; ++i)
+    for (i = 0; i < fdo_ext->u.fdo.device_desc.CollectionDescLength; ++i)
     {
-        if (fdo->device_desc.CollectionDescLength > 1)
+        if (fdo_ext->u.fdo.device_desc.CollectionDescLength > 1)
             swprintf( pdo_name, ARRAY_SIZE(pdo_name), L"\\Device\\HID#%p&%p&%d", device->DriverObject,
-                      fdo->base.hid.PhysicalDeviceObject, i );
+                      fdo_ext->u.fdo.hid_ext.PhysicalDeviceObject, i );
         else
             swprintf( pdo_name, ARRAY_SIZE(pdo_name), L"\\Device\\HID#%p&%p", device->DriverObject,
-                      fdo->base.hid.PhysicalDeviceObject );
+                      fdo_ext->u.fdo.hid_ext.PhysicalDeviceObject );
 
         RtlInitUnicodeString(&string, pdo_name);
-        if ((status = IoCreateDevice( device->DriverObject, sizeof(*pdo), &string, 0, 0, FALSE, &child_device )))
+        if ((status = IoCreateDevice( device->DriverObject, sizeof(*pdo_ext), &string, 0, 0, FALSE, &child_pdo )))
         {
             ERR( "Failed to create child PDO, status %#lx.\n", status );
             return status;
         }
 
-        fdo->child_pdos[i] = child_device;
-        fdo->child_count++;
+        fdo_ext->u.fdo.child_pdos[i] = child_pdo;
+        fdo_ext->u.fdo.child_count++;
 
-        pdo = pdo_from_DEVICE_OBJECT( child_device );
-        pdo->base.hid = fdo->base.hid;
-        pdo->parent_fdo = device;
-        list_init( &pdo->queues );
-        KeInitializeSpinLock( &pdo->lock );
+        pdo_ext = child_pdo->DeviceExtension;
+        pdo_ext->u.pdo.parent_fdo = device;
+        list_init( &pdo_ext->u.pdo.queues );
+        KeInitializeSpinLock( &pdo_ext->u.pdo.lock );
 
-        pdo->collection_desc = fdo->device_desc.CollectionDesc + i;
+        pdo_ext->u.pdo.collection_desc = fdo_ext->u.fdo.device_desc.CollectionDesc + i;
 
-        if (fdo->device_desc.CollectionDescLength > 1)
+        if (fdo_ext->u.fdo.device_desc.CollectionDescLength > 1)
         {
-            swprintf( pdo->base.device_id, ARRAY_SIZE(pdo->base.device_id), L"%s&Col%02d",
-                      fdo->base.device_id, pdo->collection_desc->CollectionNumber );
-            swprintf( pdo->base.instance_id, ARRAY_SIZE(pdo->base.instance_id), L"%u&%s&%x&%u&%04u",
-                      fdo->attrs.VersionNumber, fdo->serial, 0, 0, i );
+            swprintf( pdo_ext->device_id, ARRAY_SIZE(pdo_ext->device_id), L"%s&Col%02d",
+                      fdo_ext->device_id, pdo_ext->u.pdo.collection_desc->CollectionNumber );
+            swprintf( pdo_ext->instance_id, ARRAY_SIZE(pdo_ext->instance_id), L"%u&%s&%x&%u&%04u",
+                      fdo_ext->u.fdo.attrs.VersionNumber, fdo_ext->u.fdo.serial, 0, 0, i );
         }
         else
         {
-            wcscpy( pdo->base.device_id, fdo->base.device_id );
-            wcscpy( pdo->base.instance_id, fdo->base.instance_id );
+            wcscpy( pdo_ext->device_id, fdo_ext->device_id );
+            wcscpy( pdo_ext->instance_id, fdo_ext->instance_id );
         }
-        wcscpy( pdo->base.container_id, fdo->base.container_id );
-        pdo->base.class_guid = fdo->base.class_guid;
-
-        pdo->information.VendorID = fdo->attrs.VendorID;
-        pdo->information.ProductID = fdo->attrs.ProductID;
-        pdo->information.VersionNumber = fdo->attrs.VersionNumber;
-        pdo->information.Polled = minidriver->minidriver.DevicesArePolled;
-        pdo->information.DescriptorSize = pdo->collection_desc->PreparsedDataLength;
+        wcscpy(pdo_ext->container_id, fdo_ext->container_id);
+        pdo_ext->class_guid = fdo_ext->class_guid;
 
-        pdo->base.steam_overlay_event = minidriver->steam_overlay_event;
+        pdo_ext->u.pdo.information.VendorID = fdo_ext->u.fdo.attrs.VendorID;
+        pdo_ext->u.pdo.information.ProductID = fdo_ext->u.fdo.attrs.ProductID;
+        pdo_ext->u.pdo.information.VersionNumber = fdo_ext->u.fdo.attrs.VersionNumber;
+        pdo_ext->u.pdo.information.Polled = minidriver->minidriver.DevicesArePolled;
+        pdo_ext->u.pdo.information.DescriptorSize = pdo_ext->u.pdo.collection_desc->PreparsedDataLength;
 
-        page = pdo->collection_desc->UsagePage;
-        usage = pdo->collection_desc->Usage;
+        page = pdo_ext->u.pdo.collection_desc->UsagePage;
+        usage = pdo_ext->u.pdo.collection_desc->Usage;
         if (page == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_MOUSE)
-            pdo->rawinput_handle = WINE_MOUSE_HANDLE;
+            pdo_ext->u.pdo.rawinput_handle = WINE_MOUSE_HANDLE;
         else if (page == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_KEYBOARD)
-            pdo->rawinput_handle = WINE_KEYBOARD_HANDLE;
+            pdo_ext->u.pdo.rawinput_handle = WINE_KEYBOARD_HANDLE;
         else
-            pdo->rawinput_handle = alloc_rawinput_handle();
+            pdo_ext->u.pdo.rawinput_handle = alloc_rawinput_handle();
 
-        TRACE( "created pdo %p, rawinput handle %#x\n", pdo, pdo->rawinput_handle );
+        TRACE( "created device %p, rawinput handle %#x\n", pdo_ext, pdo_ext->u.pdo.rawinput_handle );
     }
 
-    IoInvalidateDeviceRelations( fdo->base.hid.PhysicalDeviceObject, BusRelations );
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS create_device_thread( DEVICE_OBJECT *device )
-{
-    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
-    ULONG i, input_length = 0;
-    HIDP_REPORT_IDS *report;
-
-    for (i = 0; i < fdo->device_desc.CollectionDescLength; i++)
-    {
-        HIDP_COLLECTION_DESC *desc = fdo->device_desc.CollectionDesc + i;
-        input_length = max( input_length, desc->InputLength );
-    }
-
-    if (!(fdo->io_packet = malloc( sizeof(*fdo->io_packet) + input_length ))) return STATUS_NO_MEMORY;
-
-    if (!(report = find_report_with_type_and_id( &fdo->device_desc, 0, HidP_Input, 0, TRUE ))) WARN( "no input report found.\n" );
-    fdo->io_packet->reportId = report ? report->ReportID : 0;
-    fdo->io_packet->reportBuffer = (BYTE *)(fdo->io_packet + 1);
-    fdo->io_packet->reportBufferLen = input_length;
-
-    if (!(fdo->thread = CreateThread( NULL, 0, hid_device_thread, device, 0, NULL ))) return STATUS_UNSUCCESSFUL;
+    IoInvalidateDeviceRelations( fdo_ext->u.fdo.hid_ext.PhysicalDeviceObject, BusRelations );
     return STATUS_SUCCESS;
 }
 
@@ -361,7 +332,7 @@
 {
     minidriver *minidriver = find_minidriver(device->DriverObject);
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation(irp);
-    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     NTSTATUS status;
 
     TRACE("irp %p, minor function %#x.\n", irp, stack->MinorFunction);
@@ -376,53 +347,49 @@
             if (stack->Parameters.QueryDeviceRelations.Type != BusRelations)
                 return minidriver->PNPDispatch(device, irp);
 
-            if (!(devices = ExAllocatePool( PagedPool, offsetof( DEVICE_RELATIONS, Objects[fdo->child_count] ) )))
+            if (!(devices = ExAllocatePool(PagedPool, offsetof(DEVICE_RELATIONS, Objects[ext->u.fdo.child_count]))))
             {
                 irp->IoStatus.Status = STATUS_NO_MEMORY;
                 IoCompleteRequest(irp, IO_NO_INCREMENT);
                 return STATUS_NO_MEMORY;
             }
 
-            for (i = 0, devices->Count = 0; i < fdo->child_count; ++i)
+            for (i = 0, devices->Count = 0; i < ext->u.fdo.child_count; ++i)
             {
-                devices->Objects[i] = fdo->child_pdos[i];
-                call_fastcall_func1( ObfReferenceObject, fdo->child_pdos[i] );
+                devices->Objects[i] = ext->u.fdo.child_pdos[i];
+                call_fastcall_func1(ObfReferenceObject, ext->u.fdo.child_pdos[i]);
                 devices->Count++;
             }
 
             irp->IoStatus.Information = (ULONG_PTR)devices;
             irp->IoStatus.Status = STATUS_SUCCESS;
             IoSkipCurrentIrpStackLocation(irp);
-            return IoCallDriver( fdo->base.hid.NextDeviceObject, irp );
+            return IoCallDriver(ext->u.fdo.hid_ext.NextDeviceObject, irp);
         }
 
         case IRP_MN_START_DEVICE:
             status = minidriver->PNPDispatch( device, irp );
             if (!status) status = initialize_device( minidriver, device );
             if (!status) status = create_child_pdos( minidriver, device );
-            if (!status) status = create_device_thread( device );
+            if (!status) ext->u.fdo.thread = CreateThread(NULL, 0, hid_device_thread, device, 0, NULL);
             return status;
 
         case IRP_MN_REMOVE_DEVICE:
-            if (fdo->thread)
+            if (ext->u.fdo.thread)
             {
-                KeSetEvent( &fdo->halt_event, IO_NO_INCREMENT, FALSE );
-                WaitForSingleObject( fdo->thread, INFINITE );
+                KeSetEvent( &ext->u.fdo.halt_event, IO_NO_INCREMENT, FALSE );
+                WaitForSingleObject(ext->u.fdo.thread, INFINITE);
             }
 
-            if ((status = minidriver->PNPDispatch( device, irp ))) return status;
-            if (fdo->io_irp) KeWaitForSingleObject( &fdo->io_event, Executive, KernelMode, FALSE, NULL );
-            free( fdo->io_packet );
-
-            HidP_FreeCollectionDescription( &fdo->device_desc );
-            free( fdo->child_pdos );
-            IoDetachDevice( fdo->base.hid.NextDeviceObject );
+            status = minidriver->PNPDispatch( device, irp );
+            HidP_FreeCollectionDescription( &ext->u.fdo.device_desc );
+            free( ext->u.fdo.child_pdos );
+            IoDetachDevice( ext->u.fdo.hid_ext.NextDeviceObject );
             IoDeleteDevice( device );
             return status;
 
         case IRP_MN_SURPRISE_REMOVAL:
-            if ((status = minidriver->PNPDispatch( device, irp ))) return status;
-            KeSetEvent( &fdo->halt_event, IO_NO_INCREMENT, FALSE );
+            KeSetEvent( &ext->u.fdo.halt_event, IO_NO_INCREMENT, FALSE );
             return STATUS_SUCCESS;
 
         default:
@@ -437,9 +404,9 @@
     static const WCHAR usage_format[] = L"HID_DEVICE_UP:%04X_U:%04X";
     static const WCHAR hid_format[] = L"HID_DEVICE";
 
-    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
-    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
-    HID_COLLECTION_INFORMATION *info = &pdo->information;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    HIDP_COLLECTION_DESC *desc = ext->u.pdo.collection_desc;
+    HID_COLLECTION_INFORMATION *info = &ext->u.pdo.information;
     WCHAR *dst;
     DWORD size;
 
@@ -470,7 +437,7 @@
 
 static WCHAR *query_device_id(DEVICE_OBJECT *device)
 {
-    struct device *ext = device->DeviceExtension;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     DWORD size = (wcslen(ext->device_id) + 1) * sizeof(WCHAR);
     WCHAR *dst;
 
@@ -482,7 +449,7 @@
 
 static WCHAR *query_instance_id(DEVICE_OBJECT *device)
 {
-    struct device *ext = device->DeviceExtension;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     DWORD size = (wcslen(ext->instance_id) + 1) * sizeof(WCHAR);
     WCHAR *dst;
 
@@ -494,7 +461,7 @@
 
 static WCHAR *query_container_id(DEVICE_OBJECT *device)
 {
-    struct device *ext = device->DeviceExtension;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
     DWORD size = (wcslen(ext->container_id) + 1) * sizeof(WCHAR);
     WCHAR *dst;
 
@@ -504,11 +471,11 @@
     return dst;
 }
 
-static NTSTATUS pdo_pnp( DEVICE_OBJECT *device, IRP *irp )
+static NTSTATUS pdo_pnp(DEVICE_OBJECT *device, IRP *irp)
 {
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation(irp);
-    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
-    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    HIDP_COLLECTION_DESC *desc = ext->u.pdo.collection_desc;
     NTSTATUS status = irp->IoStatus.Status;
     struct hid_queue *queue, *next;
     KIRQL irql;
@@ -543,7 +510,7 @@
                 else status = STATUS_SUCCESS;
                 break;
             case BusQueryContainerID:
-                if (pdo->base.container_id[0])
+                if (ext->container_id[0])
                 {
                     irp->IoStatus.Information = (ULONG_PTR)query_container_id(device);
                     if (!irp->IoStatus.Information) status = STATUS_NO_MEMORY;
@@ -567,9 +534,9 @@
         }
 
         case IRP_MN_START_DEVICE:
-            send_wm_input_device_change( pdo, GIDC_ARRIVAL );
+            send_wm_input_device_change(ext, GIDC_ARRIVAL);
 
-            if ((status = IoRegisterDeviceInterface( device, pdo->base.class_guid, NULL, &pdo->link_name )))
+            if ((status = IoRegisterDeviceInterface(device, ext->class_guid, NULL, &ext->u.pdo.link_name)))
             {
                 ERR( "Failed to register interface, status %#lx.\n", status );
                 break;
@@ -578,36 +545,40 @@
             /* FIXME: This should probably be done in mouhid.sys. */
             if (desc->UsagePage == HID_USAGE_PAGE_GENERIC && desc->Usage == HID_USAGE_GENERIC_MOUSE)
             {
-                if (!IoRegisterDeviceInterface( device, &GUID_DEVINTERFACE_MOUSE, NULL, &pdo->mouse_link_name ))
-                    pdo->is_mouse = TRUE;
+                if (!IoRegisterDeviceInterface(device, &GUID_DEVINTERFACE_MOUSE, NULL, &ext->u.pdo.mouse_link_name))
+                    ext->u.pdo.is_mouse = TRUE;
             }
             if (desc->UsagePage == HID_USAGE_PAGE_GENERIC && desc->Usage == HID_USAGE_GENERIC_KEYBOARD)
             {
-                if (!IoRegisterDeviceInterface( device, &GUID_DEVINTERFACE_KEYBOARD, NULL, &pdo->keyboard_link_name ))
-                    pdo->is_keyboard = TRUE;
+                if (!IoRegisterDeviceInterface(device, &GUID_DEVINTERFACE_KEYBOARD, NULL, &ext->u.pdo.keyboard_link_name))
+                    ext->u.pdo.is_keyboard = TRUE;
             }
 
-            IoSetDeviceInterfaceState( &pdo->link_name, TRUE );
-            if (pdo->is_mouse) IoSetDeviceInterfaceState( &pdo->mouse_link_name, TRUE );
-            if (pdo->is_keyboard) IoSetDeviceInterfaceState( &pdo->keyboard_link_name, TRUE );
+            IoSetDeviceInterfaceState(&ext->u.pdo.link_name, TRUE);
+            if (ext->u.pdo.is_mouse)
+                IoSetDeviceInterfaceState(&ext->u.pdo.mouse_link_name, TRUE);
+            if (ext->u.pdo.is_keyboard)
+                IoSetDeviceInterfaceState(&ext->u.pdo.keyboard_link_name, TRUE);
 
-            pdo->removed = FALSE;
+            ext->u.pdo.removed = FALSE;
             status = STATUS_SUCCESS;
             break;
 
         case IRP_MN_REMOVE_DEVICE:
-            send_wm_input_device_change( pdo, GIDC_REMOVAL );
+            send_wm_input_device_change(ext, GIDC_REMOVAL);
 
-            IoSetDeviceInterfaceState( &pdo->link_name, FALSE );
-            if (pdo->is_mouse) IoSetDeviceInterfaceState( &pdo->mouse_link_name, FALSE );
-            if (pdo->is_keyboard) IoSetDeviceInterfaceState( &pdo->keyboard_link_name, FALSE );
+            IoSetDeviceInterfaceState(&ext->u.pdo.link_name, FALSE);
+            if (ext->u.pdo.is_mouse)
+                IoSetDeviceInterfaceState(&ext->u.pdo.mouse_link_name, FALSE);
+            if (ext->u.pdo.is_keyboard)
+                IoSetDeviceInterfaceState(&ext->u.pdo.keyboard_link_name, FALSE);
 
-            KeAcquireSpinLock( &pdo->lock, &irql );
-            LIST_FOR_EACH_ENTRY_SAFE( queue, next, &pdo->queues, struct hid_queue, entry )
+            KeAcquireSpinLock( &ext->u.pdo.lock, &irql );
+            LIST_FOR_EACH_ENTRY_SAFE( queue, next, &ext->u.pdo.queues, struct hid_queue, entry )
                 hid_queue_destroy( queue );
-            KeReleaseSpinLock( &pdo->lock, irql );
+            KeReleaseSpinLock( &ext->u.pdo.lock, irql );
 
-            RtlFreeUnicodeString( &pdo->link_name );
+            RtlFreeUnicodeString(&ext->u.pdo.link_name);
 
             irp->IoStatus.Status = STATUS_SUCCESS;
             IoCompleteRequest(irp, IO_NO_INCREMENT);
@@ -615,11 +586,11 @@
             return STATUS_SUCCESS;
 
         case IRP_MN_SURPRISE_REMOVAL:
-            KeAcquireSpinLock( &pdo->lock, &irql );
-            pdo->removed = TRUE;
-            LIST_FOR_EACH_ENTRY_SAFE( queue, next, &pdo->queues, struct hid_queue, entry )
+            KeAcquireSpinLock(&ext->u.pdo.lock, &irql);
+            ext->u.pdo.removed = TRUE;
+            LIST_FOR_EACH_ENTRY_SAFE( queue, next, &ext->u.pdo.queues, struct hid_queue, entry )
                 hid_queue_remove_pending_irps( queue );
-            KeReleaseSpinLock( &pdo->lock, irql );
+            KeReleaseSpinLock( &ext->u.pdo.lock, irql );
 
             status = STATUS_SUCCESS;
             break;
@@ -635,7 +606,7 @@
 
 static NTSTATUS WINAPI driver_pnp(DEVICE_OBJECT *device, IRP *irp)
 {
-    struct device *ext = device->DeviceExtension;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
 
     if (ext->is_fdo)
         return fdo_pnp(device, irp);
@@ -645,7 +616,7 @@
 
 static NTSTATUS WINAPI driver_create(DEVICE_OBJECT *device, IRP *irp)
 {
-    struct device *ext = device->DeviceExtension;
+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
 
     if (ext->is_fdo)
     {
@@ -688,8 +659,6 @@
         if (md->DriverUnload)
             md->DriverUnload(md->minidriver.DriverObject);
         list_remove(&md->entry);
-
-        CloseHandle(md->steam_overlay_event);
         free(md);
     }
 }
@@ -705,8 +674,6 @@
     if (!(driver = calloc(1, sizeof(*driver))))
         return STATUS_NO_MEMORY;
 
-    driver->steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
-
     driver->DriverUnload = registration->DriverObject->DriverUnload;
     registration->DriverObject->DriverUnload = driver_unload;
 
