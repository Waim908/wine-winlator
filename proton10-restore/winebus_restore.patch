diff -urN wine_proton10/dlls/winebus.sys/bus_sdl.c wine-10.0/dlls/winebus.sys/bus_sdl.c
--- wine_proton10/dlls/winebus.sys/bus_sdl.c	2025-11-05 17:27:20.490950696 +0800
+++ wine-10.0/dlls/winebus.sys/bus_sdl.c	2025-01-22 00:42:16.000000000 +0800
@@ -115,8 +115,6 @@
 MAKE_FUNCPTR(SDL_RegisterEvents);
 MAKE_FUNCPTR(SDL_PushEvent);
 MAKE_FUNCPTR(SDL_GetTicks);
-MAKE_FUNCPTR(SDL_LogSetPriority);
-MAKE_FUNCPTR(SDL_SetHintWithPriority);
 static int (*pSDL_JoystickRumble)(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
 static int (*pSDL_JoystickRumbleTriggers)(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
 static Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick * joystick);
@@ -249,13 +247,6 @@
     return TRUE;
 }
 
-static const USAGE_AND_PAGE g920_absolute_usages[] =
-{
-    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_X},  /* wheel */
-    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Y},  /* accelerator */
-    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Z},  /* brake */
-    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RZ}, /* clutch */
-};
 static const USAGE_AND_PAGE absolute_axis_usages[] =
 {
     {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_X},
@@ -280,18 +271,6 @@
     {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_WHEEL},
 };
 
-static int get_absolute_usages(struct sdl_device *impl, const USAGE_AND_PAGE **absolute_usages)
-{
-    if (pSDL_JoystickGetVendor(impl->sdl_joystick) == 0x046D && pSDL_JoystickGetProduct(impl->sdl_joystick) == 0xC262)
-    {
-        *absolute_usages = g920_absolute_usages;
-        return ARRAY_SIZE(g920_absolute_usages);
-    }
-
-    *absolute_usages = absolute_axis_usages;
-    return ARRAY_SIZE(absolute_axis_usages);
-}
-
 static NTSTATUS build_joystick_report_descriptor(struct unix_device *iface)
 {
     const USAGE_AND_PAGE device_usage = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_JOYSTICK};
@@ -299,15 +278,12 @@
     int i, button_count, axis_count, ball_count, hat_count;
     USAGE_AND_PAGE physical_usage;
 
-    const USAGE_AND_PAGE *absolute_usages = NULL;
-    size_t absolute_usages_count = get_absolute_usages(impl, &absolute_usages);
-
     axis_count = pSDL_JoystickNumAxes(impl->sdl_joystick);
     if (options.split_controllers) axis_count = min(6, axis_count - impl->axis_offset);
-    if (axis_count > absolute_usages_count)
+    if (axis_count > ARRAY_SIZE(absolute_axis_usages))
     {
-        FIXME("More than %zu absolute axes found, ignoring.\n", absolute_usages_count);
-        axis_count = absolute_usages_count;
+        FIXME("More than %zu absolute axes found, ignoring.\n", ARRAY_SIZE(absolute_axis_usages));
+        axis_count = ARRAY_SIZE(absolute_axis_usages);
     }
 
     ball_count = pSDL_JoystickNumBalls(impl->sdl_joystick);
@@ -363,8 +339,8 @@
 
     for (i = 0; i < axis_count; i++)
     {
-        if (!hid_device_add_axes(iface, 1, absolute_usages[i].UsagePage,
-                                 &absolute_usages[i].Usage, FALSE, -32768, 32767))
+        if (!hid_device_add_axes(iface, 1, absolute_axis_usages[i].UsagePage,
+                                 &absolute_axis_usages[i].Usage, FALSE, -32768, 32767))
             return STATUS_NO_MEMORY;
     }
 
@@ -949,22 +925,6 @@
     return FALSE;
 }
 
-/* logic from SDL2's SDL_ShouldIgnoreGameController */
-BOOL is_sdl_ignored_device(WORD vid, WORD pid)
-{
-    const char *whitelist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT");
-    const char *blacklist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES");
-    char needle[16];
-
-    if (vid == 0x056a) return TRUE; /* all Wacom devices */
-    if (vid == 0x28de && pid == 0x11ff) return TRUE; /* Steam Input virtual controller, handled with evdev */
-
-    sprintf(needle, "0x%04x/0x%04x", vid, pid);
-    if (whitelist) return strcasestr(whitelist, needle) == NULL;
-    if (blacklist) return strcasestr(blacklist, needle) != NULL;
-    return FALSE;
-}
-
 static void sdl_add_device(unsigned int index)
 {
     struct device_desc desc =
@@ -977,7 +937,6 @@
 
     SDL_Joystick* joystick;
     SDL_JoystickID id;
-    SDL_JoystickType joystick_type;
     SDL_GameController *controller = NULL;
     const char *product, *sdl_serial;
     char guid_str[33], buffer[ARRAY_SIZE(desc.product)];
@@ -989,10 +948,7 @@
         return;
     }
 
-    joystick_type = pSDL_JoystickGetType(joystick);
-    if (options.map_controllers && pSDL_IsGameController(index)
-            && joystick_type != SDL_JOYSTICK_TYPE_WHEEL
-            && joystick_type != SDL_JOYSTICK_TYPE_FLIGHT_STICK)
+    if (options.map_controllers && pSDL_IsGameController(index))
         controller = pSDL_GameControllerOpen(index);
 
     if (controller) product = pSDL_GameControllerName(controller);
@@ -1013,14 +969,6 @@
         desc.version = 0;
     }
 
-    if (is_sdl_ignored_device(desc.vid, desc.pid))
-    {
-        TRACE("ignoring %s\n", debugstr_device_desc(&desc));
-        if (controller) pSDL_GameControllerClose(controller);
-        pSDL_JoystickClose(joystick);
-        return;
-    }
-
     if (pSDL_JoystickGetSerial && (sdl_serial = pSDL_JoystickGetSerial(joystick)))
     {
         ntdll_umbstowcs(sdl_serial, strlen(sdl_serial) + 1, desc.serialnumber, ARRAY_SIZE(desc.serialnumber));
@@ -1047,8 +995,7 @@
         desc.is_gamepad = (axis_count == 6  && button_count >= 14);
     }
 
-    axis_offset = 0;
-    do
+    for (axis_offset = 0; axis_offset < axis_count; axis_offset += (options.split_controllers ? 6 : axis_count))
     {
         NTSTATUS status;
 
@@ -1075,9 +1022,7 @@
         }
 
         bus_event_queue_device_created(&event_queue, &impl->unix_device, &desc);
-        axis_offset += (options.split_controllers ? 6 : axis_count);
     }
-    while (axis_offset < axis_count);
 }
 
 static void process_device_event(SDL_Event *event)
@@ -1196,8 +1141,6 @@
     LOAD_FUNCPTR(SDL_RegisterEvents);
     LOAD_FUNCPTR(SDL_PushEvent);
     LOAD_FUNCPTR(SDL_GetTicks);
-    LOAD_FUNCPTR(SDL_LogSetPriority);
-    LOAD_FUNCPTR(SDL_SetHintWithPriority);
 #undef LOAD_FUNCPTR
     pSDL_JoystickRumble = dlsym(sdl_handle, "SDL_JoystickRumble");
     pSDL_JoystickRumbleTriggers = dlsym(sdl_handle, "SDL_JoystickRumbleTriggers");
@@ -1207,10 +1150,6 @@
     pSDL_JoystickGetType = dlsym(sdl_handle, "SDL_JoystickGetType");
     pSDL_JoystickGetSerial = dlsym(sdl_handle, "SDL_JoystickGetSerial");
 
-    /* CW-Bug-Id: #23185: Disable SDL 2.30 new behavior, we need the steam virtual
-     * controller name to figure which slot number it represents. */
-    pSDL_SetHintWithPriority("SteamVirtualGamepadInfo", "", SDL_HINT_OVERRIDE);
-
     if (pSDL_Init(SDL_INIT_GAMECONTROLLER | SDL_INIT_HAPTIC) < 0)
     {
         ERR("could not init SDL: %s\n", pSDL_GetError());
@@ -1223,11 +1162,6 @@
         goto failed;
     }
 
-    if (TRACE_ON(hid))
-    {
-        pSDL_LogSetPriority(SDL_LOG_CATEGORY_INPUT, SDL_LOG_PRIORITY_VERBOSE);
-    }
-
     pSDL_JoystickEventState(SDL_ENABLE);
     pSDL_GameControllerEventState(SDL_ENABLE);
 
diff -urN wine_proton10/dlls/winebus.sys/bus_udev.c wine-10.0/dlls/winebus.sys/bus_udev.c
--- wine_proton10/dlls/winebus.sys/bus_udev.c	2025-11-05 17:27:20.491950695 +0800
+++ wine-10.0/dlls/winebus.sys/bus_udev.c	2025-01-22 00:42:16.000000000 +0800
@@ -25,7 +25,6 @@
 #include "config.h"
 #include <errno.h>
 #include <fcntl.h>
-#include <limits.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -189,11 +188,7 @@
     BYTE hat_map[8];
     BYTE button_map[KEY_MAX];
 
-    int haptics_state;
-    pthread_cond_t haptics_cond;
-    pthread_t haptics_thread;
-    struct ff_effect haptics;
-
+    int haptic_effect_id;
     int effect_ids[256];
     LONG effect_flags;
 };
@@ -460,302 +455,6 @@
 
 #define test_bit(arr,bit) (((BYTE*)(arr))[(bit)>>3]&(1<<((bit)&7)))
 
-/* Minimal compatibility with code taken from steam-runtime-tools */
-typedef int gboolean;
-#define g_debug(fmt, ...) TRACE(fmt "\n", ## __VA_ARGS__)
-#define G_N_ELEMENTS(arr) (sizeof(arr)/sizeof(arr[0]))
-
-typedef enum
-{
-  SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK = (1 << 0),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER = (1 << 1),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD = (1 << 2),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS = (1 << 3),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE = (1 << 4),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD = (1 << 5),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN = (1 << 6),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET = (1 << 7),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET_PAD = (1 << 8),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK = (1 << 9),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_SWITCH = (1 << 10),
-  SRT_INPUT_DEVICE_TYPE_FLAGS_NONE = 0
-} SrtInputDeviceTypeFlags;
-
-#define BITS_PER_LONG           (sizeof (unsigned long) * CHAR_BIT)
-#define LONGS_FOR_BITS(x)       ((((x)-1)/BITS_PER_LONG)+1)
-typedef struct
-{
-  unsigned long ev[LONGS_FOR_BITS (EV_MAX)];
-  unsigned long keys[LONGS_FOR_BITS (KEY_MAX)];
-  unsigned long abs[LONGS_FOR_BITS (ABS_MAX)];
-  unsigned long rel[LONGS_FOR_BITS (REL_MAX)];
-  unsigned long ff[LONGS_FOR_BITS (FF_MAX)];
-  unsigned long props[LONGS_FOR_BITS (INPUT_PROP_MAX)];
-} SrtEvdevCapabilities;
-
-static gboolean
-_srt_get_caps_from_evdev (int fd,
-                          unsigned int type,
-                          unsigned long *bitmask,
-                          size_t bitmask_len_longs)
-{
-  size_t bitmask_len_bytes = bitmask_len_longs * sizeof (*bitmask);
-
-  memset (bitmask, 0, bitmask_len_bytes);
-
-  if (ioctl (fd, EVIOCGBIT (type, bitmask_len_bytes), bitmask) < 0)
-    return FALSE;
-
-  return TRUE;
-}
-
-static gboolean
-_srt_evdev_capabilities_set_from_evdev (SrtEvdevCapabilities *caps,
-                                        int fd)
-{
-  if (_srt_get_caps_from_evdev (fd, 0, caps->ev, G_N_ELEMENTS (caps->ev)))
-    {
-      _srt_get_caps_from_evdev (fd, EV_KEY, caps->keys, G_N_ELEMENTS (caps->keys));
-      _srt_get_caps_from_evdev (fd, EV_ABS, caps->abs, G_N_ELEMENTS (caps->abs));
-      _srt_get_caps_from_evdev (fd, EV_REL, caps->rel, G_N_ELEMENTS (caps->rel));
-      _srt_get_caps_from_evdev (fd, EV_FF, caps->ff, G_N_ELEMENTS (caps->ff));
-      ioctl (fd, EVIOCGPROP (sizeof (caps->props)), caps->props);
-      return TRUE;
-    }
-
-  memset (caps, 0, sizeof (*caps));
-  return FALSE;
-}
-
-#define JOYSTICK_ABS_AXES \
-  ((1 << ABS_X) | (1 << ABS_Y) \
-   | (1 << ABS_RX) | (1 << ABS_RY) \
-   | (1 << ABS_THROTTLE) | (1 << ABS_RUDDER) \
-   | (1 << ABS_WHEEL) | (1 << ABS_GAS) | (1 << ABS_BRAKE) \
-   | (1 << ABS_HAT0X) | (1 << ABS_HAT0Y) \
-   | (1 << ABS_HAT1X) | (1 << ABS_HAT1Y) \
-   | (1 << ABS_HAT2X) | (1 << ABS_HAT2Y) \
-   | (1 << ABS_HAT3X) | (1 << ABS_HAT3Y))
-
-static const unsigned int first_mouse_button = BTN_MOUSE;
-static const unsigned int last_mouse_button = BTN_JOYSTICK - 1;
-
-static const unsigned int first_joystick_button = BTN_JOYSTICK;
-static const unsigned int last_joystick_button = BTN_GAMEPAD - 1;
-
-static const unsigned int first_gamepad_button = BTN_GAMEPAD;
-static const unsigned int last_gamepad_button = BTN_DIGI - 1;
-
-static const unsigned int first_dpad_button = BTN_DPAD_UP;
-static const unsigned int last_dpad_button = BTN_DPAD_RIGHT;
-
-static const unsigned int first_extra_joystick_button = BTN_TRIGGER_HAPPY;
-static const unsigned int last_extra_joystick_button = BTN_TRIGGER_HAPPY40;
-
-SrtInputDeviceTypeFlags
-_srt_evdev_capabilities_guess_type (const SrtEvdevCapabilities *caps)
-{
-  SrtInputDeviceTypeFlags flags = SRT_INPUT_DEVICE_TYPE_FLAGS_NONE;
-  unsigned int i;
-  gboolean has_joystick_axes = FALSE;
-  gboolean has_joystick_buttons = FALSE;
-
-  /* Some properties let us be fairly sure about a device */
-  if (test_bit (caps->props, INPUT_PROP_ACCELEROMETER))
-    {
-      g_debug ("INPUT_PROP_ACCELEROMETER => is accelerometer");
-      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
-    }
-
-  if (test_bit (caps->props, INPUT_PROP_POINTING_STICK))
-    {
-      g_debug ("INPUT_PROP_POINTING_STICK => is pointing stick");
-      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK;
-    }
-
-  if (test_bit (caps->props, INPUT_PROP_BUTTONPAD)
-      || test_bit (caps->props, INPUT_PROP_TOPBUTTONPAD))
-    {
-      g_debug ("INPUT_PROP_[TOP]BUTTONPAD => is touchpad");
-      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD;
-    }
-
-  /* Devices with a stylus or pen are assumed to be graphics tablets */
-  if (test_bit (caps->keys, BTN_STYLUS)
-      || test_bit (caps->keys, BTN_TOOL_PEN))
-    {
-      g_debug ("Stylus or pen => is tablet");
-      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET;
-    }
-
-  /* Devices that accept a finger touch are assumed to be touchpads or
-   * touchscreens.
-   *
-   * In Steam we mostly only care about these as a way to
-   * reject non-joysticks, so we're not very precise here yet.
-   *
-   * SDL assumes that TOUCH means a touchscreen and FINGER
-   * means a touchpad. */
-  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE
-      && (test_bit (caps->keys, BTN_TOOL_FINGER)
-          || test_bit (caps->keys, BTN_TOUCH)
-          || test_bit (caps->props, INPUT_PROP_SEMI_MT)))
-    {
-      g_debug ("Finger or touch or semi-MT => is touchpad or touchscreen");
-
-      if (test_bit (caps->props, INPUT_PROP_POINTER))
-        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD;
-      else
-        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN;
-    }
-
-  /* Devices with mouse buttons are ... probably mice? */
-  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE)
-    {
-      for (i = first_mouse_button; i <= last_mouse_button; i++)
-        {
-          if (test_bit (caps->keys, i))
-            {
-              g_debug ("Mouse button => mouse");
-              flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE;
-            }
-        }
-    }
-
-  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE)
-    {
-      for (i = ABS_X; i < ABS_Z; i++)
-        {
-          if (!test_bit (caps->abs, i))
-            break;
-        }
-
-      /* If it has 3 axes and no buttons it's probably an accelerometer. */
-      if (i == ABS_Z && !test_bit (caps->ev, EV_KEY))
-        {
-          g_debug ("3 left axes and no buttons => accelerometer");
-          flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
-        }
-
-      /* Same for RX..RZ (e.g. Wiimote) */
-      for (i = ABS_RX; i < ABS_RZ; i++)
-        {
-          if (!test_bit (caps->abs, i))
-            break;
-        }
-
-      if (i == ABS_RZ && !test_bit (caps->ev, EV_KEY))
-        {
-          g_debug ("3 right axes and no buttons => accelerometer");
-          flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
-        }
-    }
-
-  /* Bits 1 to 31 are ESC, numbers and Q to D, which SDL and udev both
-   * consider to be enough to count as a fully-functioned keyboard. */
-  if ((caps->keys[0] & 0xfffffffe) == 0xfffffffe)
-    {
-      g_debug ("First few keys => keyboard");
-      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD;
-    }
-
-  /* If we have *any* keys, consider it to be something a bit
-   * keyboard-like. Bits 0 to 63 are all keyboard keys.
-   * Make sure we stop before reaching KEY_UP which is sometimes
-   * used on game controller mappings, e.g. for the Wiimote. */
-  for (i = 0; i < (64 / BITS_PER_LONG); i++)
-    {
-      if (caps->keys[i] != 0)
-        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS;
-    }
-
-  if (caps->abs[0] & JOYSTICK_ABS_AXES)
-    has_joystick_axes = TRUE;
-
-  /* Flight stick buttons */
-  for (i = first_joystick_button; i <= last_joystick_button; i++)
-    {
-      if (test_bit (caps->keys, i))
-        has_joystick_buttons = TRUE;
-    }
-
-  /* Gamepad buttons (Xbox, PS3, etc.) */
-  for (i = first_gamepad_button; i <= last_gamepad_button; i++)
-    {
-      if (test_bit (caps->keys, i))
-        has_joystick_buttons = TRUE;
-    }
-
-  /* Gamepad digital dpad */
-  for (i = first_dpad_button; i <= last_dpad_button; i++)
-    {
-      if (test_bit (caps->keys, i))
-        has_joystick_buttons = TRUE;
-    }
-
-  /* Steering wheel gear-change buttons */
-  for (i = BTN_GEAR_DOWN; i <= BTN_GEAR_UP; i++)
-    {
-      if (test_bit (caps->keys, i))
-        has_joystick_buttons = TRUE;
-    }
-
-  /* Reserved space for extra game-controller buttons, e.g. on Corsair
-   * gaming keyboards */
-  for (i = first_extra_joystick_button; i <= last_extra_joystick_button; i++)
-    {
-      if (test_bit (caps->keys, i))
-        has_joystick_buttons = TRUE;
-    }
-
-  if (test_bit (caps->keys, last_mouse_button))
-    {
-      /* Mice with a very large number of buttons can apparently
-       * overflow into the joystick-button space, but they're still not
-       * joysticks. */
-      has_joystick_buttons = FALSE;
-    }
-
-  /* TODO: Do we want to consider BTN_0 up to BTN_9 to be joystick buttons?
-   * libmanette and SDL look for BTN_1, udev does not.
-   *
-   * They're used by some game controllers, like BTN_1 and BTN_2 for the
-   * Wiimote, BTN_1..BTN_9 for the SpaceTec SpaceBall and BTN_0..BTN_3
-   * for Playstation dance pads, but they're also used by
-   * non-game-controllers like Logitech mice. For now we entirely ignore
-   * these buttons: they are not evidence that it's a joystick, but
-   * neither are they evidence that it *isn't* a joystick. */
-
-  /* We consider it to be a joystick if there is some evidence that it is,
-   * and no evidence that it's something else.
-   *
-   * Unlike SDL, we accept devices with only axes and no buttons as a
-   * possible joystick, unless they have X/Y/Z axes in which case we
-   * assume they're accelerometers. */
-  if ((has_joystick_buttons || has_joystick_axes)
-      && (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE))
-    {
-      g_debug ("Looks like a joystick");
-      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK;
-    }
-
-  /* If we have *any* keys below BTN_MISC, consider it to be something
-   * a bit keyboard-like, but don't rule out *also* being considered
-   * to be a joystick (again for e.g. the Wiimote). */
-  for (i = 0; i < (BTN_MISC / BITS_PER_LONG); i++)
-    {
-      if (caps->keys[i] != 0)
-        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS;
-    }
-
-  /* Also non-exclusive: don't rule out a device being a joystick and
-   * having a switch */
-  if (test_bit (caps->ev, EV_SW))
-    flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_SWITCH;
-
-  return flags;
-}
-
 static const USAGE_AND_PAGE *what_am_I(struct udev_device *dev, int fd)
 {
     static const USAGE_AND_PAGE Unknown     = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = 0};
@@ -766,7 +465,6 @@
     static const USAGE_AND_PAGE Tablet      = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_PEN};
     static const USAGE_AND_PAGE Touchscreen = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_TOUCH_SCREEN};
     static const USAGE_AND_PAGE Touchpad    = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_TOUCH_PAD};
-    SrtEvdevCapabilities caps;
 
     struct udev_device *parent = dev;
 
@@ -791,56 +489,11 @@
         parent = udev_device_get_parent_with_subsystem_devtype(parent, "input", NULL);
     }
 
-    /* In a container, udev properties might not be available. Fall back to deriving the device
-     * type from the fd's evdev capabilities. */
-    if (_srt_evdev_capabilities_set_from_evdev (&caps, fd))
-    {
-        SrtInputDeviceTypeFlags guessed_type;
-
-        guessed_type = _srt_evdev_capabilities_guess_type (&caps);
-
-        if (guessed_type & (SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE
-                            | SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK))
-            return &Mouse;
-        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD)
-            return &Keyboard;
-        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK)
-            return &Gamepad;
-        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS)
-            return &Keypad;
-        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD)
-            return &Touchpad;
-        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN)
-            return &Touchscreen;
-        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET)
-            return &Tablet;
-
-        /* Mapped to Unknown: ACCELEROMETER, TABLET_PAD, SWITCH. */
-    }
-
     return &Unknown;
 }
 
 static INT count_buttons(int device_fd, BYTE *map)
 {
-    static const UINT gamepad_buttons[] =
-    {
-        BTN_A,
-        BTN_B,
-        BTN_X,
-        BTN_Y,
-        BTN_TL,
-        BTN_TR,
-        BTN_SELECT,
-        BTN_START,
-        BTN_THUMBL,
-        BTN_THUMBR,
-        BTN_MODE,
-        BTN_C,
-        BTN_Z,
-        BTN_TL2,
-        BTN_TR2,
-    };
     int i;
     int button_count = 0;
     BYTE keybits[(KEY_MAX+7)/8];
@@ -851,16 +504,7 @@
         return FALSE;
     }
 
-    for (i = 0; i < ARRAY_SIZE(gamepad_buttons); i++)
-    {
-        if (test_bit(keybits, gamepad_buttons[i]))
-        {
-            if (map) map[gamepad_buttons[i]] = button_count;
-            button_count++;
-        }
-    }
-
-    for (i = BTN_DIGI; i < KEY_MAX; i++)
+    for (i = BTN_MISC; i < KEY_MAX; i++)
     {
         if (test_bit(keybits, i))
         {
@@ -894,6 +538,7 @@
     BYTE absbits[(ABS_MAX+7)/8];
     BYTE relbits[(REL_MAX+7)/8];
     BYTE ffbits[(FF_MAX+7)/8];
+    struct ff_effect effect;
     USAGE_AND_PAGE usage;
     USHORT count = 0;
     USAGE usages[16];
@@ -969,11 +614,24 @@
     if (!hid_device_end_input_report(iface))
         return STATUS_NO_MEMORY;
 
-    impl->haptics.id = -1;
+    impl->haptic_effect_id = -1;
     for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i) impl->effect_ids[i] = -1;
 
-    if (test_bit(ffbits, FF_RUMBLE) && !hid_device_add_haptics(iface))
-        return STATUS_NO_MEMORY;
+    if (test_bit(ffbits, FF_RUMBLE))
+    {
+        effect.id = -1;
+        effect.type = FF_RUMBLE;
+        effect.replay.length = 0;
+        effect.u.rumble.strong_magnitude = 0;
+        effect.u.rumble.weak_magnitude = 0;
+
+        if (ioctl(impl->base.device_fd, EVIOCSFF, &effect) == -1)
+            WARN("couldn't allocate rumble effect for haptics: %d %s\n", errno, strerror(errno));
+        else if (!hid_device_add_haptics(iface))
+            return FALSE;
+        else
+            impl->haptic_effect_id = effect.id;
+    }
 
     for (i = 0; i < FF_MAX; ++i) if (test_bit(ffbits, i)) break;
     if (i != FF_MAX)
@@ -1068,54 +726,11 @@
     udev_device_unref(impl->base.udev_device);
 }
 
-static void *lnxev_device_haptics_thread(void *args)
-{
-    struct lnxev_device *impl = lnxev_impl_from_unix_device(args);
-
-    pthread_mutex_lock(&udev_cs);
-
-    for (;;)
-    {
-        struct ff_effect effect;
-
-        while (impl->haptics_state == 1) pthread_cond_wait(&impl->haptics_cond, &udev_cs);
-        if (!impl->haptics_state) break;
-
-        effect = impl->haptics;
-        impl->haptics_state = 1;
-        pthread_mutex_unlock(&udev_cs);
-
-        if (effect.type && (effect.id == -1 || ioctl(impl->base.device_fd, EVIOCSFF, &effect) == -1))
-        {
-            effect.id = -1;
-            ioctl(impl->base.device_fd, EVIOCSFF, &effect);
-        }
-
-        if (effect.id != -1)
-        {
-            struct input_event event = {.type = EV_FF, .code = effect.id, .value = !!effect.type};
-            write(impl->base.device_fd, &event, sizeof(event));
-        }
-
-        pthread_mutex_lock(&udev_cs);
-        impl->haptics.id = effect.id;
-    }
-
-    pthread_mutex_unlock(&udev_cs);
-    return NULL;
-}
-
 static NTSTATUS lnxev_device_start(struct unix_device *iface)
 {
-    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
-
     pthread_mutex_lock(&udev_cs);
     start_polling_device(iface);
-    impl->haptics_state = 1;
     pthread_mutex_unlock(&udev_cs);
-
-    pthread_cond_init(&impl->haptics_cond, NULL);
-    pthread_create(&impl->haptics_thread, NULL, lnxev_device_haptics_thread, iface);
     return STATUS_SUCCESS;
 }
 
@@ -1126,12 +741,7 @@
     pthread_mutex_lock(&udev_cs);
     stop_polling_device(iface);
     list_remove(&impl->base.unix_device.entry);
-    impl->haptics_state = 0;
     pthread_mutex_unlock(&udev_cs);
-    pthread_cond_signal(&impl->haptics_cond);
-
-    pthread_join(impl->haptics_thread, NULL);
-    pthread_cond_destroy(&impl->haptics_cond);
 }
 
 static void lnxev_device_read_report(struct unix_device *iface)
@@ -1155,18 +765,39 @@
                                            USHORT left_intensity, USHORT right_intensity)
 {
     struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    struct ff_effect effect =
+    {
+        .id = impl->haptic_effect_id,
+        .type = FF_RUMBLE,
+    };
+    struct input_event event;
 
     TRACE("iface %p, duration_ms %u, rumble_intensity %u, buzz_intensity %u, left_intensity %u, right_intensity %u.\n",
           iface, duration_ms, rumble_intensity, buzz_intensity, left_intensity, right_intensity);
 
-    pthread_mutex_lock(&udev_cs);
-    impl->haptics.type = FF_RUMBLE;
-    impl->haptics.replay.length = duration_ms;
-    impl->haptics.u.rumble.strong_magnitude = rumble_intensity;
-    impl->haptics.u.rumble.weak_magnitude = buzz_intensity;
-    impl->haptics_state = 2;
-    pthread_mutex_unlock(&udev_cs);
-    pthread_cond_signal(&impl->haptics_cond);
+    effect.replay.length = duration_ms;
+    effect.u.rumble.strong_magnitude = rumble_intensity;
+    effect.u.rumble.weak_magnitude = buzz_intensity;
+
+    if (ioctl(impl->base.device_fd, EVIOCSFF, &effect) == -1)
+    {
+        effect.id = -1;
+        if (ioctl(impl->base.device_fd, EVIOCSFF, &effect) == 1)
+        {
+            WARN("couldn't re-allocate rumble effect for haptics: %d %s\n", errno, strerror(errno));
+            return STATUS_UNSUCCESSFUL;
+        }
+        impl->haptic_effect_id = effect.id;
+    }
+
+    event.type = EV_FF;
+    event.code = effect.id;
+    event.value = 1;
+    if (write(impl->base.device_fd, &event, sizeof(event)) == -1)
+    {
+        WARN("couldn't start haptics rumble effect: %d %s\n", errno, strerror(errno));
+        return STATUS_UNSUCCESSFUL;
+    }
 
     return STATUS_SUCCESS;
 }
@@ -1174,17 +805,22 @@
 static NTSTATUS lnxev_device_haptics_stop(struct unix_device *iface)
 {
     struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    struct ff_effect effect =
+    {
+        .id = impl->haptic_effect_id,
+        .type = FF_RUMBLE,
+    };
+    struct input_event event;
 
     TRACE("iface %p.\n", iface);
 
-    pthread_mutex_lock(&udev_cs);
-    impl->haptics.type = 0;
-    impl->haptics.replay.length = 0;
-    impl->haptics.u.rumble.strong_magnitude = 0;
-    impl->haptics.u.rumble.weak_magnitude = 0;
-    impl->haptics_state = 2;
-    pthread_mutex_unlock(&udev_cs);
-    pthread_cond_signal(&impl->haptics_cond);
+    if (effect.id == -1) return STATUS_SUCCESS;
+
+    event.type = EV_FF;
+    event.code = effect.id;
+    event.value = 0;
+    if (write(impl->base.device_fd, &event, sizeof(event)) == -1)
+        WARN("couldn't stop haptics rumble effect: %d %s\n", errno, strerror(errno));
 
     return STATUS_SUCCESS;
 }
@@ -1628,10 +1264,7 @@
         if (!desc.manufacturer[0]) memcpy(desc.manufacturer, evdev, sizeof(evdev));
 
         if (!desc.product[0] && ioctl(fd, EVIOCGNAME(sizeof(buffer) - 1), buffer) > 0)
-        {
-            if (sscanf(buffer, "Microsoft X-Box 360 pad %u", &desc.input) != 1) desc.input = -1;
             ntdll_umbstowcs(buffer, strlen(buffer) + 1, desc.product, ARRAY_SIZE(desc.product));
-        }
 
         if (!desc.serialnumber[0] && ioctl(fd, EVIOCGUNIQ(sizeof(buffer)), buffer) >= 0)
             ntdll_umbstowcs(buffer, strlen(buffer) + 1, desc.serialnumber, ARRAY_SIZE(desc.serialnumber));
@@ -1644,28 +1277,8 @@
         memcpy(desc.serialnumber, zeros, sizeof(zeros));
     }
 
-    if (desc.vid == 0x28de && desc.pid == 0x11ff && !strcmp(subsystem, "input"))
-    {
-        TRACE("evdev %s: detected steam input virtual controller\n", debugstr_a(devnode));
+    if (is_xbox_gamepad(desc.vid, desc.pid))
         desc.is_gamepad = TRUE;
-        desc.version = 0; /* keep version fixed as 0 so we can hardcode it in ntdll rawinput pipe redirection */
-    }
-    else if (is_sdl_ignored_device(desc.vid, desc.pid))
-    {
-        TRACE("evdev %s: ignoring %s, in SDL ignore list\n", debugstr_a(devnode), debugstr_device_desc(&desc));
-        close(fd);
-        return;
-    }
-    else if (!strcmp(subsystem, "input"))
-    {
-        TRACE("evdev %s: deferring %s to a different backend\n", debugstr_a(devnode), debugstr_device_desc(&desc));
-        close(fd);
-        return;
-    }
-    else if (is_xbox_gamepad(desc.vid, desc.pid))
-    {
-        desc.is_gamepad = TRUE;
-    }
 #ifdef HAS_PROPER_INPUT_HEADER
     else if (!strcmp(subsystem, "input"))
     {
@@ -2075,12 +1688,6 @@
         goto error;
     }
 
-    if (access("/run/pressure-vessel", R_OK) || access("/.flatpak-info", R_OK))
-    {
-        TRACE("Container detected, bypassing udevd by default\n");
-        options.disable_udevd = TRUE;
-    }
-
 #ifdef HAVE_SYS_INOTIFY_H
     if (options.disable_udevd) monitor_fd = create_inotify();
     if (monitor_fd < 0) options.disable_udevd = FALSE;
diff -urN wine_proton10/dlls/winebus.sys/main.c wine-10.0/dlls/winebus.sys/main.c
--- wine_proton10/dlls/winebus.sys/main.c	2025-11-05 17:27:20.491950695 +0800
+++ wine-10.0/dlls/winebus.sys/main.c	2025-01-22 00:42:16.000000000 +0800
@@ -287,18 +287,6 @@
     }
 }
 
-static void make_unique_serial(struct device_extension *device)
-{
-    struct device_extension *ext;
-
-    LIST_FOR_EACH_ENTRY(ext, &device_list, struct device_extension, entry)
-        if (!wcscmp(device->desc.serialnumber, ext->desc.serialnumber)) break;
-    if (&ext->entry == &device_list && *device->desc.serialnumber) return;
-
-    swprintf(device->desc.serialnumber, ARRAY_SIZE(device->desc.serialnumber), L"%04x%08x%04x%04x",
-             device->index, device->desc.input, device->desc.pid, device->desc.vid);
-}
-
 static DEVICE_OBJECT *bus_create_hid_device(struct device_desc *desc, UINT64 unix_device)
 {
     struct device_extension *ext;
@@ -343,10 +331,6 @@
     InitializeCriticalSectionEx(&ext->cs, 0, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO);
     ext->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": cs");
 
-    /* Overcooked! All You Can Eat only adds controllers with unique serial numbers
-     * Prefer keeping serial numbers unique over keeping them consistent across runs */
-    make_unique_serial(ext);
-
     /* add to list of pnp devices */
     if (before)
         list_add_before(before, &ext->entry);
@@ -433,31 +417,13 @@
     return default_value;
 }
 
-static const WCHAR *wcscasestr(const WCHAR *search, const WCHAR *needle)
-{
-    UNICODE_STRING search_str, needle_str;
-
-    RtlInitUnicodeString(&search_str, search);
-    RtlInitUnicodeString(&needle_str, needle);
-
-    while (needle_str.Length <= search_str.Length)
-    {
-        if (!RtlCompareUnicodeString(&search_str, &needle_str, TRUE)) return search_str.Buffer;
-        search_str.Length -= sizeof(WCHAR);
-        search_str.Buffer += 1;
-    }
-
-    return NULL;
-}
-
 static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages, UINT buttons)
 {
     char buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[1024])];
     KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
-    WCHAR vidpid[MAX_PATH], *tmp, value[1024];
+    WCHAR vidpid[MAX_PATH], *tmp;
     BOOL prefer_hidraw = FALSE;
     UNICODE_STRING str;
-    SIZE_T len;
     DWORD size;
 
     if (check_bus_option(L"DisableHidraw", FALSE)) return FALSE;
@@ -467,33 +433,7 @@
         WARN("Ignoring unsupported %04X:%04X hidraw touchscreen\n", vid, pid);
         return FALSE;
     }
-
-    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_DISABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
-    {
-        value[len] = 0;
-        if (!wcscmp(value, L"1")) return FALSE;
-        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
-        if (wcscasestr(value, vidpid)) return FALSE;
-    }
-    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_ENABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
-    {
-        value[len] = 0;
-        if (!wcscmp(value, L"1")) return TRUE;
-        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
-        if (wcscasestr(value, vidpid)) return TRUE;
-    }
-
-    if (usages->UsagePage == HID_USAGE_PAGE_DIGITIZER)
-    {
-        WARN("Ignoring unsupported %04X:%04X hidraw touchscreen\n", vid, pid);
-        return FALSE;
-    }
     if (usages->UsagePage != HID_USAGE_PAGE_GENERIC) return TRUE;
-    if (usages->Usage == HID_USAGE_GENERIC_MOUSE || usages->Usage == HID_USAGE_GENERIC_KEYBOARD)
-    {
-        WARN("Ignoring unsupported %04X:%04X hidraw mouse/keyboard\n", vid, pid);
-        return FALSE;
-    }
     if (usages->Usage != HID_USAGE_GENERIC_GAMEPAD && usages->Usage != HID_USAGE_GENERIC_JOYSTICK) return TRUE;
 
     if (!check_bus_option(L"Enable SDL", 1) && check_bus_option(L"DisableInput", 0))
@@ -518,15 +458,6 @@
     case 0x0eb7:
         if (pid == 0x183b) prefer_hidraw = TRUE; /* Fanatec ClubSport Pedals v3 */
         if (pid == 0x1839) prefer_hidraw = TRUE; /* Fanatec ClubSport Pedals v1/v2 */
-        if (pid == 0x0e03) prefer_hidraw = TRUE; /* Fanatec CSL Elite */
-        if (pid == 0x0005) prefer_hidraw = TRUE; /* Fanatec CSL Elite PS4 */
-        if (pid == 0x0020) prefer_hidraw = TRUE; /* Fanatec CSL DD / DD Pro / ClubSport DD */
-        if (pid == 0x0001) prefer_hidraw = TRUE; /* Fanatec ClubSport V2 */
-        if (pid == 0x0004) prefer_hidraw = TRUE; /* Fanatec ClubSport V2.5 */
-        if (pid == 0x0006) prefer_hidraw = TRUE; /* Fanatec Podium DD1 */
-        if (pid == 0x0007) prefer_hidraw = TRUE; /* Fanatec Podium DD2 */
-        if (pid == 0x0011) prefer_hidraw = TRUE; /* Fanatec CSR Elite / Forza Motorsport */
-        if (pid == 0xe0fe) prefer_hidraw = TRUE; /* CS-WB-DD (FW update mode) */
         break;
     case 0x231d:
         /* comes with 128 buttons in the default configuration */
@@ -1090,7 +1021,7 @@
 
     bus_options.disable_hidraw = check_bus_option(L"DisableHidraw", 0);
     if (bus_options.disable_hidraw) TRACE("UDEV hidraw devices disabled in registry\n");
-    bus_options.disable_input = check_bus_option(L"DisableInput", 0);
+    bus_options.disable_input = check_bus_option(L"DisableInput", 0) || enable_sdl;
     if (bus_options.disable_input) TRACE("UDEV input devices disabled in registry\n");
     bus_options.disable_udevd = check_bus_option(L"DisableUdevd", 0);
     if (bus_options.disable_udevd) TRACE("UDEV udevd use disabled in registry\n");
diff -urN wine_proton10/dlls/winebus.sys/unix_private.h wine-10.0/dlls/winebus.sys/unix_private.h
--- wine_proton10/dlls/winebus.sys/unix_private.h	2025-11-05 17:27:20.492950693 +0800
+++ wine-10.0/dlls/winebus.sys/unix_private.h	2025-01-22 00:42:16.000000000 +0800
@@ -266,6 +266,4 @@
 
 extern void hid_device_set_effect_state(struct unix_device *iface, BYTE index, BYTE flags);
 
-extern BOOL is_sdl_ignored_device(WORD vid, WORD pid);
-
 #endif /* __WINEBUS_UNIX_PRIVATE_H */
