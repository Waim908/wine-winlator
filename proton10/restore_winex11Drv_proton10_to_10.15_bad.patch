diff -urN proton_wine10.0/dlls/winex11.drv/bitblt.c wine-10.15/dlls/winex11.drv/bitblt.c
--- proton_wine10.0/dlls/winex11.drv/bitblt.c	2025-11-16 17:00:20.240403469 +0800
+++ wine-10.15/dlls/winex11.drv/bitblt.c	2025-09-13 03:36:38.000000000 +0800
@@ -1589,10 +1589,6 @@
     GC                    gc;
     struct x11drv_image  *image;
     BOOL                  byteswap;
-    int                   x_offset;
-    int                   y_offset;
-    RECT                 *clip_rects;
-    unsigned int          clip_rect_count;
 };
 
 static struct x11drv_window_surface *get_x11_surface( struct window_surface *surface )
@@ -1752,20 +1748,20 @@
     return NULL;
 }
 
-static XRectangle *xrectangles_from_rects( const RECT *rects, UINT count, int x_offset, int y_offset )
+static XRectangle *xrectangles_from_rects( const RECT *rects, UINT count )
 {
     XRectangle *xrects;
     if (!(xrects = malloc( count * sizeof(*xrects) ))) return NULL;
     while (count--)
     {
-        if (rects[count].left + x_offset > SHRT_MAX) continue;
-        if (rects[count].top + y_offset > SHRT_MAX) continue;
-        if (rects[count].right + x_offset < SHRT_MIN) continue;
-        if (rects[count].bottom + y_offset < SHRT_MIN) continue;
-        xrects[count].x      = max( min( rects[count].left + x_offset, SHRT_MAX), SHRT_MIN);
-        xrects[count].y      = max( min( rects[count].top + y_offset, SHRT_MAX), SHRT_MIN);
-        xrects[count].width  = max( min( rects[count].right + x_offset, SHRT_MAX ) - xrects[count].x, 0);
-        xrects[count].height = max( min( rects[count].bottom + y_offset, SHRT_MAX ) - xrects[count].y, 0);
+        if (rects[count].left > SHRT_MAX) continue;
+        if (rects[count].top > SHRT_MAX) continue;
+        if (rects[count].right < SHRT_MIN) continue;
+        if (rects[count].bottom < SHRT_MIN) continue;
+        xrects[count].x      = max( min( rects[count].left, SHRT_MAX), SHRT_MIN);
+        xrects[count].y      = max( min( rects[count].top, SHRT_MAX), SHRT_MIN);
+        xrects[count].width  = max( min( rects[count].right, SHRT_MAX ) - xrects[count].x, 0);
+        xrects[count].height = max( min( rects[count].bottom, SHRT_MAX ) - xrects[count].y, 0);
     }
     return xrects;
 }
@@ -1780,17 +1776,10 @@
 
     TRACE( "surface %p, rects %p, count %u\n", surface, rects, count );
 
-    free( surface->clip_rects );
-    surface->clip_rects = NULL;
-    surface->clip_rect_count = 0;
-
     if (!count)
         XSetClipMask( gdi_display, surface->gc, None );
-    else if ((xrects = xrectangles_from_rects( rects, count, surface->x_offset, surface->y_offset )))
+    else if ((xrects = xrectangles_from_rects( rects, count )))
     {
-        surface->clip_rect_count = count;
-        surface->clip_rects = malloc( count * sizeof(*surface->clip_rects) );
-        memcpy( surface->clip_rects, rects, count * sizeof(*surface->clip_rects) );
         XSetClipRectangles( gdi_display, surface->gc, 0, 0, xrects, count, YXBanded );
         free( xrects );
     }
@@ -1799,7 +1788,7 @@
 /***********************************************************************
  *           x11drv_surface_flush
  */
-static BOOL x11drv_surface_flush( struct window_surface *window_surface, const RECT *surface_rect, const RECT *dirty,
+static BOOL x11drv_surface_flush( struct window_surface *window_surface, const RECT *rect, const RECT *dirty,
                                   const BITMAPINFO *color_info, const void *color_bits, BOOL shape_changed,
                                   const BITMAPINFO *shape_info, const void *shape_bits )
 {
@@ -1808,9 +1797,6 @@
     XImage *ximage = surface->image->ximage;
     const unsigned char *src = color_bits;
     unsigned char *dst = (unsigned char *)ximage->data;
-    RECT rect = *surface_rect;
-
-    OffsetRect( &rect, surface->x_offset, surface->y_offset );
 
     if (alpha_bits == -1)
     {
@@ -1845,10 +1831,6 @@
 
     if (shape_changed)
     {
-        /* HACK: Do not shape layered windows on gamescope */
-        if (shape_bits && alpha_mask != 0 && X11DRV_HasWindowManager( "steamcompmgr" ))
-            shape_bits = 0;
-
 #ifdef HAVE_LIBXSHAPE
         if (!shape_bits)
             XShapeCombineMask( gdi_display, surface->window, ShapeBounding, 0, 0, None, ShapeSet );
@@ -1860,15 +1842,15 @@
 
             vis.depth = 1;
             shape = create_pixmap_from_image( 0, &vis, shape_info, &bits, DIB_RGB_COLORS );
-            XShapeCombineMask( gdi_display, surface->window, ShapeBounding, surface->x_offset, surface->y_offset, shape, ShapeSet );
+            XShapeCombineMask( gdi_display, surface->window, ShapeBounding, 0, 0, shape, ShapeSet );
             XFreePixmap( gdi_display, shape );
         }
 #endif /* HAVE_LIBXSHAPE */
     }
 
-    if (!put_shm_image( ximage, &surface->image->shminfo, surface->window, surface->gc, &rect, dirty ))
+    if (!put_shm_image( ximage, &surface->image->shminfo, surface->window, surface->gc, rect, dirty ))
         XPutImage( gdi_display, surface->window, surface->gc, ximage, dirty->left,
-                   dirty->top, rect.left + dirty->left, rect.top + dirty->top,
+                   dirty->top, rect->left + dirty->left, rect->top + dirty->top,
                    dirty->right - dirty->left, dirty->bottom - dirty->top );
 
     XFlush( gdi_display );
@@ -1884,7 +1866,6 @@
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
     TRACE( "freeing %p\n", surface );
-    free( surface->clip_rects );
     if (surface->gc) XFreeGC( gdi_display, surface->gc );
     if (surface->image) x11drv_image_destroy( surface->image );
 }
@@ -2013,30 +1994,8 @@
 
     *surface = create_surface( data->hwnd, data->whole_window, &data->vis, surface_rect,
                                layered ? data->use_alpha : FALSE );
-    set_surface_window_rects( *surface, &data->rects );
 
 done:
     release_win_data( data );
     return TRUE;
 }
-
-void set_surface_window_rects( struct window_surface *window_surface, const struct window_rects *rects )
-{
-    if (window_surface && window_surface->funcs == &x11drv_surface_funcs)
-    {
-        struct x11drv_window_surface *surface = get_x11_surface( window_surface );
-        XRectangle *xrects;
-
-        window_surface_lock( window_surface );
-        surface->x_offset = max( rects->window.left - rects->visible.left, 0 );
-        surface->y_offset = max( rects->window.top - rects->visible.top, 0 );
-        window_surface_unlock( window_surface );
-
-        if (surface->clip_rects && (xrects = xrectangles_from_rects( surface->clip_rects, surface->clip_rect_count,
-                                                                     surface->x_offset, surface->y_offset )))
-        {
-            XSetClipRectangles( gdi_display, surface->gc, 0, 0, xrects, surface->clip_rect_count, YXBanded );
-            free( xrects );
-        }
-    }
-}
diff -urN proton_wine10.0/dlls/winex11.drv/clipboard.c wine-10.15/dlls/winex11.drv/clipboard.c
--- proton_wine10.0/dlls/winex11.drv/clipboard.c	2025-11-16 17:00:20.241403442 +0800
+++ wine-10.15/dlls/winex11.drv/clipboard.c	2025-09-13 03:36:38.000000000 +0800
@@ -83,7 +83,6 @@
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "x11drv.h"
-#include "xfixes.h"
 
 #ifdef HAVE_X11_EXTENSIONS_XFIXES_H
 #include <X11/extensions/Xfixes.h>
@@ -200,6 +199,7 @@
 static ULONG last_clipboard_update;
 static struct clipboard_format **current_x11_formats;
 static unsigned int nb_current_x11_formats;
+static BOOL use_xfixes;
 
 Display *clipboard_display = NULL;
 
@@ -580,101 +580,6 @@
 }
 
 
-/* based on wine_get_dos_file_name */
-static WCHAR *get_dos_file_name( const char *path )
-{
-    ULONG len = strlen( path ) + 9; /* \??\unix prefix */
-    WCHAR *ret;
-
-    if (!(ret = malloc( len * sizeof(WCHAR) ))) return NULL;
-    if (wine_unix_to_nt_file_name( path, ret, &len ))
-    {
-        free( ret );
-        return NULL;
-    }
-
-    if (ret[5] == ':')
-    {
-        /* get rid of the \??\ prefix */
-        memmove( ret, ret + 4, (len - 4) * sizeof(WCHAR) );
-    }
-    else ret[1] = '\\';
-    return ret;
-}
-
-
-/***********************************************************************
- *           get_nt_pathname
- *
- * Simplified version of RtlDosPathNameToNtPathName_U.
- */
-static BOOL get_nt_pathname( const WCHAR *name, UNICODE_STRING *nt_name )
-{
-    static const WCHAR ntprefixW[] = {'\\','?','?','\\'};
-    static const WCHAR uncprefixW[] = {'U','N','C','\\'};
-    size_t len = lstrlenW( name );
-    WCHAR *ptr;
-
-    nt_name->MaximumLength = (len + 8) * sizeof(WCHAR);
-    if (!(ptr = malloc( nt_name->MaximumLength ))) return FALSE;
-    nt_name->Buffer = ptr;
-
-    memcpy( ptr, ntprefixW, sizeof(ntprefixW) );
-    ptr += ARRAYSIZE(ntprefixW);
-    if (name[0] == '\\' && name[1] == '\\')
-    {
-        if ((name[2] == '.' || name[2] == '?') && name[3] == '\\')
-        {
-            name += 4;
-            len -= 4;
-        }
-        else
-        {
-            memcpy( ptr, uncprefixW, sizeof(uncprefixW) );
-            ptr += ARRAYSIZE(uncprefixW);
-            name += 2;
-            len -= 2;
-        }
-    }
-    memcpy( ptr, name, (len + 1) * sizeof(WCHAR) );
-    ptr += len;
-    nt_name->Length = (ptr - nt_name->Buffer) * sizeof(WCHAR);
-    return TRUE;
-}
-
-
-/* based on wine_get_unix_file_name */
-static char *get_unix_file_name( const WCHAR *dosW )
-{
-    UNICODE_STRING nt_name;
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-    ULONG size = 256;
-    char *buffer;
-
-    if (!get_nt_pathname( dosW, &nt_name )) return NULL;
-    InitializeObjectAttributes( &attr, &nt_name, 0, 0, NULL );
-    for (;;)
-    {
-        if (!(buffer = malloc( size )))
-        {
-            free( nt_name.Buffer );
-            return NULL;
-        }
-        status = wine_nt_to_unix_file_name( &attr, buffer, &size, FILE_OPEN_IF );
-        if (status != STATUS_BUFFER_TOO_SMALL) break;
-        free( buffer );
-    }
-    free( nt_name.Buffer );
-    if (status)
-    {
-        free( buffer );
-        return NULL;
-    }
-    return buffer;
-}
-
-
 static CPTABLEINFO *get_xstring_cp(void)
 {
     static CPTABLEINFO cp;
@@ -751,7 +656,7 @@
             if (uri[7] == '/')
             {
                 /* file:///path/to/file (nautilus, thunar) */
-                ret = get_dos_file_name( &uri[7] );
+                ntdll_get_dos_file_name( &uri[7], &ret, FILE_OPEN );
             }
             else if (uri[7])
             {
@@ -761,18 +666,11 @@
                 if (path)
                 {
                     *path = '\0';
-                    if (strcmp(&uri[7], "localhost") == 0)
+                    if (!strcmp(&uri[7], "localhost") ||
+                        (!gethostname(hostname, sizeof(hostname)) && !strcmp(hostname, &uri[7])))
                     {
                         *path = '/';
-                        ret = get_dos_file_name( path );
-                    }
-                    else if (gethostname(hostname, sizeof(hostname)) == 0)
-                    {
-                        if (strcmp(hostname, &uri[7]) == 0)
-                        {
-                            *path = '/';
-                            ret = get_dos_file_name( path );
-                        }
+                        ntdll_get_dos_file_name( path, &ret, FILE_OPEN );
                     }
                 }
             }
@@ -780,7 +678,7 @@
         else if (uri[6])
         {
             /* file:/path/to/file (konqueror) */
-            ret = get_dos_file_name( &uri[5] );
+            ntdll_get_dos_file_name( &uri[5], &ret, FILE_OPEN );
         }
     }
     free( uri );
@@ -1057,7 +955,7 @@
 
     for (ptr = data; ptr < (const char *)data + size; ptr += strlen( ptr ) + 1)
     {
-        path = get_dos_file_name( ptr );
+        ntdll_get_dos_file_name( ptr, &path, FILE_OPEN );
 
         TRACE( "converted URI %s to DOS path %s\n", debugstr_a(ptr), debugstr_w(path) );
 
@@ -1592,9 +1490,9 @@
         char *unixFilename = NULL;
         UINT uriSize;
         UINT u;
+        NTSTATUS status = ntdll_get_unix_file_name( ptr, &unixFilename, FILE_OPEN );
 
-        unixFilename = get_unix_file_name( ptr );
-        if (unixFilename == NULL) goto failed;
+        if (status) goto failed;
         ptr += lstrlenW( ptr ) + 1;
 
         uriSize = 8 + /* file:/// */
@@ -2170,6 +2068,28 @@
 static void xfixes_init(void)
 {
 #ifdef SONAME_LIBXFIXES
+    typeof(XFixesSelectSelectionInput) *pXFixesSelectSelectionInput;
+    typeof(XFixesQueryExtension) *pXFixesQueryExtension;
+    typeof(XFixesQueryVersion) *pXFixesQueryVersion;
+
+    int event_base, error_base;
+    int major = 3, minor = 0;
+    void *handle;
+
+    handle = dlopen(SONAME_LIBXFIXES, RTLD_NOW);
+    if (!handle) return;
+
+    pXFixesQueryExtension = dlsym(handle, "XFixesQueryExtension");
+    if (!pXFixesQueryExtension) return;
+    pXFixesQueryVersion = dlsym(handle, "XFixesQueryVersion");
+    if (!pXFixesQueryVersion) return;
+    pXFixesSelectSelectionInput = dlsym(handle, "XFixesSelectSelectionInput");
+    if (!pXFixesSelectSelectionInput) return;
+
+    if (!pXFixesQueryExtension(clipboard_display, &event_base, &error_base))
+        return;
+    pXFixesQueryVersion(clipboard_display, &major, &minor);
+    use_xfixes = (major >= 1);
     if (!use_xfixes) return;
 
     pXFixesSelectSelectionInput(clipboard_display, import_window, x11drv_atom(CLIPBOARD),
@@ -2183,7 +2103,7 @@
                 XFixesSelectionWindowDestroyNotifyMask |
                 XFixesSelectionClientCloseNotifyMask);
     }
-    X11DRV_register_event_handler(xfixes_event_base + XFixesSelectionNotify,
+    X11DRV_register_event_handler(event_base + XFixesSelectionNotify,
             selection_notify_event, "XFixesSelectionNotify");
     TRACE("xfixes succesully initialized\n");
 #else
diff -urN proton_wine10.0/dlls/winex11.drv/desktop.c wine-10.15/dlls/winex11.drv/desktop.c
--- proton_wine10.0/dlls/winex11.drv/desktop.c	2025-11-16 17:00:20.241403442 +0800
+++ wine-10.15/dlls/winex11.drv/desktop.c	2025-09-13 03:36:38.000000000 +0800
@@ -35,8 +35,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
 
-static RECT *host_monitor_rects;
-static int host_monitor_rect_count;
+static RECT host_primary_rect;
 
 #define _NET_WM_STATE_REMOVE 0
 #define _NET_WM_STATE_ADD 1
@@ -52,11 +51,9 @@
  *
  * Setup the desktop when not using the root window.
  */
-void X11DRV_init_desktop( Window win )
+void X11DRV_init_desktop( Window win, unsigned int width, unsigned int height )
 {
-    if (host_monitor_rects) free( host_monitor_rects );
-    if (!get_host_monitor_rects( &host_monitor_rects, &host_monitor_rect_count ))
-        ERR("Failed to get host monitor rectangle.\n");
+    host_primary_rect = get_host_primary_monitor_rect();
     root_window = win;
     managed_mode = FALSE;  /* no managed windows in desktop mode */
 }
@@ -77,7 +74,7 @@
     /* Create window */
     win_attr.event_mask = ExposureMask | KeyPressMask | KeyReleaseMask | EnterWindowMask |
                           PointerMotionMask | ButtonPressMask | ButtonReleaseMask | FocusChangeMask |
-                          PropertyChangeMask;
+                          StructureNotifyMask | PropertyChangeMask;
     win_attr.cursor = XCreateFontCursor( display, XC_top_left_arrow );
 
     if (default_visual.visual != DefaultVisual( display, DefaultScreen(display) ))
@@ -94,23 +91,13 @@
     x11drv_xinput2_enable( display, win );
     XFlush( display );
 
-    X11DRV_init_desktop( win );
+    X11DRV_init_desktop( win, width, height );
     return TRUE;
 }
 
 BOOL is_desktop_fullscreen(void)
 {
-    Display *display = thread_display();
-    unsigned int width, height, border, depth;
-    int x, y, i;
-    Window root;
-    RECT rect;
-
-    XGetGeometry( display, root_window, &root, &x, &y, &width, &height, &border, &depth );
-    SetRect( &rect, x, y, x + width, y + height );
-
-    for (i = 0; i < host_monitor_rect_count; i++)
-        if (EqualRect( &host_monitor_rects[i], &rect) ) return TRUE;
-
-    return FALSE;
+    RECT primary_rect = NtUserGetPrimaryMonitorRect();
+    return (primary_rect.right - primary_rect.left == host_primary_rect.right - host_primary_rect.left &&
+            primary_rect.bottom - primary_rect.top == host_primary_rect.bottom - host_primary_rect.top);
 }
diff -urN proton_wine10.0/dlls/winex11.drv/display.c wine-10.15/dlls/winex11.drv/display.c
--- proton_wine10.0/dlls/winex11.drv/display.c	2025-11-16 17:00:20.241403442 +0800
+++ wine-10.15/dlls/winex11.drv/display.c	2025-09-13 03:36:38.000000000 +0800
@@ -33,7 +33,6 @@
 
 static struct x11drv_display_device_handler host_handler;
 static struct x11drv_settings_handler settings_handler;
-RECT gamescope_screen_rect;
 
 #define NEXT_DEVMODEW(mode) ((DEVMODEW *)((char *)((mode) + 1) + (mode)->dmDriverExtra))
 
@@ -232,9 +231,9 @@
         TRACE("handler:%s changing %s to position:(%d,%d) resolution:%ux%u frequency:%uHz "
               "depth:%ubits orientation:%#x.\n", settings_handler.name,
               wine_dbgstr_w(mode->dmDeviceName),
-              (int)full_mode->dmPosition.x, (int)full_mode->dmPosition.y, (int)full_mode->dmPelsWidth,
-              (int)full_mode->dmPelsHeight, (int)full_mode->dmDisplayFrequency,
-              (int)full_mode->dmBitsPerPel, (int)full_mode->dmDisplayOrientation);
+              full_mode->dmPosition.x, full_mode->dmPosition.y, full_mode->dmPelsWidth,
+              full_mode->dmPelsHeight, full_mode->dmDisplayFrequency,
+              full_mode->dmBitsPerPel, full_mode->dmDisplayOrientation);
 
         ret = settings_handler.set_current_mode(*id, full_mode);
         free_full_mode(full_mode);
@@ -324,67 +323,6 @@
     return rect;
 }
 
-/* Get an array of host monitor rectangles in X11 root coordinates. Free the array when it's done */
-BOOL get_host_monitor_rects( RECT **ret_rects, int *ret_count )
-{
-    int gpu_count, adapter_count, monitor_count, rect_count = 0;
-    int gpu_idx, adapter_idx, monitor_idx, rect_idx;
-    struct x11drv_gpu *gpus = NULL;
-    struct x11drv_adapter *adapters = NULL;
-    struct gdi_monitor *monitors = NULL;
-    RECT *rects = NULL, *new_rects;
-    POINT left_top = {INT_MAX, INT_MAX};
-
-    if (!host_handler.get_gpus( &gpus, &gpu_count, FALSE )) goto failed;
-
-    for (gpu_idx = 0; gpu_idx < gpu_count; gpu_idx++)
-    {
-        if (!host_handler.get_adapters( gpus[gpu_idx].id, &adapters, &adapter_count )) goto failed;
-
-        for (adapter_idx = 0; adapter_idx < adapter_count; adapter_idx++)
-        {
-            if (!host_handler.get_monitors( adapters[adapter_idx].id, &monitors, &monitor_count )) goto failed;
-
-            new_rects = realloc( rects, (rect_count + monitor_count) * sizeof(*rects) );
-            if (!new_rects) goto failed;
-            rects = new_rects;
-
-            for (monitor_idx = 0; monitor_idx < monitor_count; monitor_idx++)
-            {
-                rects[rect_count++] = monitors[monitor_idx].rc_monitor;
-                left_top.x = min( left_top.x, monitors[monitor_idx].rc_monitor.left );
-                left_top.y = min( left_top.y, monitors[monitor_idx].rc_monitor.top );
-            }
-
-            host_handler.free_monitors( monitors, monitor_count );
-            monitors = NULL;
-        }
-
-        host_handler.free_adapters( adapters );
-        adapters = NULL;
-    }
-
-    host_handler.free_gpus( gpus, gpu_count );
-    gpus = NULL;
-
-    /* Convert from win32 virtual screen coordinates to X11 root coordinates */
-    for (rect_idx = 0; rect_idx < rect_count; rect_idx++)
-        OffsetRect( &rects[rect_idx], -left_top.x, -left_top.y );
-
-    *ret_rects = rects;
-    *ret_count = rect_count;
-    return TRUE;
-
-failed:
-    if (monitors) host_handler.free_monitors( monitors, monitor_count );
-    if (adapters) host_handler.free_adapters( adapters );
-    if (gpus) host_handler.free_gpus( gpus, gpu_count );
-    free( rects );
-    *ret_rects = NULL;
-    *ret_count = 0;
-    return FALSE;
-}
-
 RECT get_work_area(const RECT *monitor_rect)
 {
     Atom type;
@@ -515,13 +453,6 @@
             if (!settings_handler.get_id( devname, is_primary, &settings_id )) break;
 
             settings_handler.get_current_mode( settings_id, &current_mode );
-            if (!gpu && X11DRV_HasWindowManager( "steamcompmgr" ))
-            {
-                gamescope_screen_rect.left = gamescope_screen_rect.top = 0;
-                gamescope_screen_rect.right = current_mode.dmPelsWidth;
-                gamescope_screen_rect.bottom = current_mode.dmPelsHeight;
-            }
-
             if (settings_handler.get_modes( settings_id, EDS_ROTATEDMODE, &modes, &mode_count, FALSE ))
             {
                 device_manager->add_modes( &current_mode, mode_count, modes, param );
diff -urN proton_wine10.0/dlls/winex11.drv/event.c wine-10.15/dlls/winex11.drv/event.c
--- proton_wine10.0/dlls/winex11.drv/event.c	2025-11-16 17:00:20.242403415 +0800
+++ wine-10.15/dlls/winex11.drv/event.c	2025-09-13 03:36:38.000000000 +0800
@@ -322,30 +322,6 @@
     }
 }
 
-static void wait_grab_pointer( Display *display )
-{
-    RECT rect;
-
-    /* unnecessary on gamescope, windows cannot be moved with the mouse */
-    if (X11DRV_HasWindowManager( "steamcompmgr" )) return;
-
-    /* release cursor grab held by any Wine process */
-    NtUserGetClipCursor( &rect );
-    NtUserClipCursor( NULL );
-
-    while (XGrabPointer( display, root_window, False, 0, GrabModeAsync, GrabModeAsync,
-                         None, None, CurrentTime ) != GrabSuccess)
-    {
-        LARGE_INTEGER timeout = {.QuadPart = -10 * (ULONGLONG)10000};
-        NtDelayExecution( FALSE, &timeout );
-    }
-
-    XUngrabPointer( display, CurrentTime );
-    XFlush( display );
-
-    /* restore the previously used clipping rect */
-    NtUserClipCursor( &rect );
-}
 
 enum event_merge_action
 {
@@ -402,10 +378,6 @@
  */
 static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
 {
-#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-    struct x11drv_thread_data *thread_data = x11drv_thread_data();
-#endif
-
     switch (prev->type)
     {
     case ConfigureNotify:
@@ -437,21 +409,19 @@
         case GenericEvent:
             if (next->xcookie.extension != xinput2_opcode) break;
             if (next->xcookie.evtype != XI_RawMotion) break;
-            if (thread_data->xinput2_rawinput) break;
-            if (thread_data->warp_serial) break;
+            if (x11drv_thread_data()->warp_serial) break;
             return MERGE_KEEP;
         }
         break;
     case GenericEvent:
         if (prev->xcookie.extension != xinput2_opcode) break;
         if (prev->xcookie.evtype != XI_RawMotion) break;
-        if (thread_data->xinput2_rawinput) break;
         switch (next->type)
         {
         case GenericEvent:
             if (next->xcookie.extension != xinput2_opcode) break;
             if (next->xcookie.evtype != XI_RawMotion) break;
-            if (thread_data->warp_serial) break;
+            if (x11drv_thread_data()->warp_serial) break;
             return merge_raw_motion_events( prev->xcookie.data, next->xcookie.data );
 #endif
         }
@@ -502,19 +472,13 @@
 {
     XEvent event, prev_event;
     int count = 0;
-    BOOL queued = FALSE, overlay_enabled = FALSE;
+    BOOL queued = FALSE;
     enum event_merge_action action = MERGE_DISCARD;
-    ULONG_PTR overlay_filter = QS_KEY | QS_MOUSEBUTTON | QS_MOUSEMOVE;
-    LARGE_INTEGER timeout = {0};
-
-    if (NtWaitForSingleObject(steam_overlay_event, FALSE, &timeout) == WAIT_OBJECT_0)
-        overlay_enabled = TRUE;
 
     prev_event.type = 0;
     while (XCheckIfEvent( display, &event, filter, (char *)arg ))
     {
         count++;
-        if (overlay_enabled && filter_event( display, &event, (char *)overlay_filter )) continue;
         if (XFilterEvent( &event, None ))
         {
             /*
@@ -691,11 +655,9 @@
     Window win;
     GUITHREADINFO threadinfo;
 
-    wait_grab_pointer( display );
-
     TRACE( "setting foreground window to %p\n", focus );
 
-    if (!is_netwm_supported( x11drv_atom(_NET_ACTIVE_WINDOW) ))
+    if (!is_net_supported( x11drv_atom(_NET_ACTIVE_WINDOW) ))
     {
         NtUserSetForegroundWindow( focus );
 
@@ -783,7 +745,7 @@
                         NtUserSetActiveWindow( hwnd );
                         break;
                     default:
-                        WARN( "unknown WM_MOUSEACTIVATE code %d\n", (int) ma );
+                        WARN( "unknown WM_MOUSEACTIVATE code %ld\n", ma );
                         break;
                 }
             }
@@ -793,8 +755,7 @@
     }
     else if (protocol == x11drv_atom(WM_TAKE_FOCUS))
     {
-        struct x11drv_thread_data *data = x11drv_thread_data();
-        HWND last_focus = data->last_focus, foreground = NtUserGetForegroundWindow();
+        HWND last_focus = x11drv_thread_data()->last_focus, foreground = NtUserGetForegroundWindow();
 
         if (window_has_pending_wm_state( hwnd, -1 ) || (hwnd != foreground && !window_should_take_focus( foreground, event_time )))
         {
@@ -806,15 +767,9 @@
         TRACE( "window %p/%lx WM_TAKE_FOCUS serial %lu, event_time %ld, foreground %p\n", hwnd, event->window,
                event->serial, event_time, foreground );
         TRACE( "  enabled %u, visible %u, style %#x, focus %p, active %p, last %p\n",
-                NtUserIsWindowEnabled( hwnd ), NtUserIsWindowVisible( hwnd ), (int)NtUserGetWindowLongW( hwnd, GWL_STYLE ),
+                NtUserIsWindowEnabled( hwnd ), NtUserIsWindowVisible( hwnd ), NtUserGetWindowLongW( hwnd, GWL_STYLE ),
                 get_focus(), get_active_window(), last_focus );
 
-        /* Steam sometimes calls XSetInputFocus with CurrentTime when it gets focused out, and the game gets
-         * focused in, this effectively sometimes steals focus away from us. Although there's no guarantee to
-         * win the race as it entirely depends on the request timings, using CurrentTime makes it more likely.
-         */
-        if (data->active_window && !strcmp( data->active_window, "Steam" )) event_time = CurrentTime;
-
         if (can_activate_window(hwnd))
         {
             set_focus( event->display, hwnd, event_time );
@@ -905,17 +860,6 @@
     if (is_virtual_desktop() && hwnd == NtUserGetDesktopWindow()) reapply_cursor_clipping();
     if (hwnd == NtUserGetDesktopWindow()) return FALSE;
 
-    /* Focus was just restored but it can be right after super was
-     * pressed and gnome-shell needs a bit of time to respond and
-     * toggle the activity view. If we grab the cursor right away
-     * it will cancel it and super key will do nothing.
-     */
-    if (event->mode == NotifyUngrab && X11DRV_HasWindowManager( "Mutter" ))
-    {
-        LARGE_INTEGER timeout = {.QuadPart = 100 * -10000};
-        NtDelayExecution( FALSE, &timeout );
-    }
-
     x11drv_thread_data()->keymapnotify_hwnd = hwnd;
 
     /* when keyboard grab is released, re-apply the cursor clipping rect */
@@ -927,7 +871,7 @@
 
     xim_set_focus( hwnd, TRUE );
 
-    if (use_take_focus && !X11DRV_HasWindowManager( "steamcompmgr" )) return TRUE;
+    if (use_take_focus) return TRUE;
 
     if (!can_activate_window(hwnd))
     {
@@ -937,12 +881,7 @@
         if (!hwnd) hwnd = x11drv_thread_data()->last_focus;
         if (hwnd && can_activate_window(hwnd)) set_focus( event->display, hwnd, CurrentTime );
     }
-    else
-    {
-        wait_grab_pointer( event->display );
-        NtUserSetForegroundWindow( hwnd );
-    }
-
+    else NtUserSetForegroundWindow( hwnd );
     return TRUE;
 }
 
@@ -964,7 +903,7 @@
     /* don't reset the foreground window, if the window which is
        getting the focus is a Wine window */
 
-    if (!is_netwm_supported( x11drv_atom(_NET_ACTIVE_WINDOW) ) && !is_current_process_focused())
+    if (!is_net_supported( x11drv_atom(_NET_ACTIVE_WINDOW) ) && !is_current_process_focused())
     {
         /* Abey : 6-Oct-99. Check again if the focus out window is the
            Foreground window, because in most cases the messages sent
@@ -1007,6 +946,12 @@
               hwnd, event->window, event->serial, focus_details[event->detail], focus_modes[event->mode], foreground );
         return FALSE;
     }
+    if (!is_virtual_desktop() && window_is_reparenting( hwnd )) /* ignore FocusOut only if the window is being reparented */
+    {
+        WARN( "Ignoring window %p/%lx FocusOut serial %lu, detail %s, mode %s, foreground %p during reparenting\n",
+              hwnd, event->window, event->serial, focus_details[event->detail], focus_modes[event->mode], foreground );
+        return FALSE;
+    }
 
     TRACE( "window %p/%lx FocusOut serial %lu, detail %s, mode %s, foreground %p\n", hwnd, event->window,
            event->serial, focus_details[event->detail], focus_modes[event->mode], foreground );
@@ -1021,28 +966,6 @@
     return TRUE;
 }
 
-void clear_emulated_fullscreen_padding( struct x11drv_win_data *data )
-{
-    RECT rect, visible;
-
-    visible = data->rects.visible;
-    OffsetRect( &visible, -data->rects.visible.left, -data->rects.visible.top );
-
-    rect = data->rects.window;
-    OffsetRect( &rect, -data->rects.visible.left, -data->rects.visible.top );
-    intersect_rect( &rect, &rect, &visible );
-
-    if (rect.left > 0 || rect.top > 0 || rect.right < visible.right || rect.bottom < visible.bottom)
-    {
-        UINT width = visible.right - rect.right, height = visible.bottom - rect.bottom;
-
-        TRACE("clearing for visible %s, rect %s.\n", wine_dbgstr_rect(&visible), wine_dbgstr_rect(&rect));
-        if (visible.right && rect.top) XClearArea( data->display, data->whole_window, 0, 0, visible.right, rect.top, 0 );
-        if (rect.left && visible.bottom) XClearArea( data->display, data->whole_window, 0, 0, rect.left, visible.bottom, 0 );
-        if (width && visible.bottom) XClearArea( data->display, data->whole_window, rect.right, 0, width, visible.bottom, 0 );
-        if (height && visible.right) XClearArea( data->display, data->whole_window, 0, rect.bottom, visible.right, height, 0 );
-    }
-}
 
 /***********************************************************************
  *           X11DRV_Expose
@@ -1053,7 +976,7 @@
     RECT rect, abs_rect;
     POINT pos;
     struct x11drv_win_data *data;
-    UINT flags = RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN;
+    UINT flags = RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN;
 
     TRACE( "win %p (%lx) %d,%d %dx%d\n",
            hwnd, event->window, event->x, event->y, event->width, event->height );
@@ -1067,8 +990,6 @@
 
     if (!(data = get_win_data( hwnd ))) return FALSE;
 
-    clear_emulated_fullscreen_padding( data );
-
     rect.left   = pos.x;
     rect.top    = pos.y;
     rect.right  = pos.x + event->width;
@@ -1110,6 +1031,11 @@
     if (event->xany.window == x11drv_thread_data()->clip_window) return TRUE;
 
     if (!(data = get_win_data( hwnd ))) return FALSE;
+    if (data->reparenting)
+    {
+        TRACE( "window %p/%lx has been reparented\n", data->hwnd, data->whole_window );
+        data->reparenting = 0;
+    }
 
     if (!data->managed && !data->embedded && data->desired_state.wm_state != WithdrawnState)
     {
@@ -1127,6 +1053,15 @@
  */
 static BOOL X11DRV_UnmapNotify( HWND hwnd, XEvent *event )
 {
+    struct x11drv_win_data *data;
+
+    if (!(data = get_win_data( hwnd ))) return FALSE;
+    if (data->managed && !data->wm_state_serial && data->current_state.wm_state == NormalState)
+    {
+        WARN( "window %p/%lx unexpectedly unmapped, assuming reparenting\n", data->hwnd, data->whole_window );
+        data->reparenting = 1;
+    }
+    release_win_data( data );
     return TRUE;
 }
 
@@ -1307,25 +1242,6 @@
     }
 }
 
-Window get_net_active_window( Display *display, char **name )
-{
-    unsigned long count, remaining;
-    Window window = None, *value;
-    int format;
-    Atom type;
-
-    if (!XGetWindowProperty( display, DefaultRootWindow( display ), x11drv_atom(_NET_ACTIVE_WINDOW), 0,
-                             65536 / sizeof(Window), False, XA_WINDOW, &type, &format, &count,
-                             &remaining, (unsigned char **)&value ))
-    {
-        if (type == XA_WINDOW && format == 32) window = *value;
-        XFree( value );
-    }
-
-    if (window) get_window_name( display, window, name );
-    return window;
-}
-
 /***********************************************************************
  *           handle_wm_state_notify
  *
@@ -1340,7 +1256,7 @@
     if (!(data = get_win_data( hwnd ))) return;
     if (event->state == PropertyNewValue) value = get_window_wm_state( event->display, event->window );
     window_wm_state_notify( data, event->serial, value, event->time );
-    activate = value == NormalState && !data->wm_state_serial && !(data->current_state.swp_flags & SWP_NOACTIVATE);
+    activate = value == NormalState && !data->wm_state_serial && data->current_state.activate;
     release_win_data( data );
 
     if (hwnd == NtUserGetForegroundWindow() && activate) set_net_active_window( hwnd, 0 );
@@ -1397,38 +1313,12 @@
     if (event->state == PropertyNewValue) net_supported_init( data );
 }
 
-static void handle_net_supporting_wm_check_notify( XPropertyEvent *event )
-{
-    struct x11drv_thread_data *data = x11drv_thread_data();
-
-    if (data->window_manager)
-    {
-        XFree( data->window_manager );
-        data->window_manager = NULL;
-    }
-
-    if (event->state == PropertyNewValue) net_supporting_wm_check_init( data );
-}
-
-static void handle_net_active_window( HWND hwnd, XPropertyEvent *event )
+static void handle_net_active_window( XPropertyEvent *event )
 {
-    struct x11drv_thread_data *data = x11drv_thread_data();
-    Window window = None;
-    HWND foreground;
+    Window window = 0;
 
-    if (data->active_window)
-    {
-        XFree( data->active_window );
-        data->active_window = NULL;
-    }
-
-    if (event->state == PropertyNewValue) window = get_net_active_window( event->display, &data->active_window );
+    if (event->state == PropertyNewValue) window = get_net_active_window( event->display );
     net_active_window_notify( event->serial, window, event->time );
-
-    if (data->active_window) TRACE( "_NET_ACTIVE_WINDOW changed to %s\n", debugstr_a(data->active_window) );
-
-    if (!(foreground = NtUserGetForegroundWindow())) foreground = NtUserGetDesktopWindow();
-    NtUserPostMessage( foreground, WM_WINE_WINDOW_STATE_CHANGED, 0, 0 );
 }
 
 /***********************************************************************
@@ -1444,8 +1334,7 @@
     if (event->atom == x11drv_atom(_NET_WM_STATE)) handle_net_wm_state_notify( hwnd, event );
     if (event->atom == x11drv_atom(_MOTIF_WM_HINTS)) handle_mwm_hints_notify( hwnd, event );
     if (event->atom == x11drv_atom(_NET_SUPPORTED)) handle_net_supported_notify( event );
-    if (event->atom == x11drv_atom(_NET_SUPPORTING_WM_CHECK)) handle_net_supporting_wm_check_notify( event );
-    if (event->atom == x11drv_atom(_NET_ACTIVE_WINDOW)) handle_net_active_window( hwnd, event );
+    if (event->atom == x11drv_atom(_NET_ACTIVE_WINDOW)) handle_net_active_window( event );
 
     return TRUE;
 }
@@ -1460,7 +1349,7 @@
 {
     struct x11drv_win_data *data;
 
-    set_net_active_window( hwnd, previous );
+    if (!is_virtual_desktop()) set_net_active_window( hwnd, previous );
 
     if (!(data = get_win_data( hwnd ))) return;
     if (!data->managed || data->embedder) set_input_focus( data );
@@ -1735,7 +1624,7 @@
     effect = drag_drop_drag( hwnd, point, effect );
 
     TRACE( "actionRequested(%ld) chosen(0x%x) at x(%d),y(%d)\n",
-           event->data.l[4], effect, (int)point.x, (int)point.y );
+           event->data.l[4], effect, point.x, point.y );
 
     /*
      * Let source know if we're accepting the drop by
diff -urN proton_wine10.0/dlls/winex11.drv/graphics.c wine-10.15/dlls/winex11.drv/graphics.c
--- proton_wine10.0/dlls/winex11.drv/graphics.c	2025-11-16 17:00:20.243403388 +0800
+++ wine-10.15/dlls/winex11.drv/graphics.c	2025-09-13 03:36:38.000000000 +0800
@@ -40,6 +40,8 @@
 #include <string.h>
 #include <limits.h>
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "windef.h"
 #include "winbase.h"
 #include "winreg.h"
@@ -296,13 +298,12 @@
 /***********************************************************************
  *           X11DRV_SetDeviceClipping
  */
-void X11DRV_SetDeviceClipping( PHYSDEV dev, HRGN rgn, HRGN monitor_rgn )
+void X11DRV_SetDeviceClipping( PHYSDEV dev, HRGN rgn )
 {
     X11DRV_PDEVICE *physDev = get_x11drv_dev( dev );
 
-    if (physDev->region) NtGdiDeleteObjectApp( physDev->region );
-    physDev->region = clone_gdi_region( monitor_rgn );
-    update_x11_clipping( physDev, physDev->region );
+    physDev->region = rgn;
+    update_x11_clipping( physDev, rgn );
 }
 
 
@@ -1642,99 +1643,75 @@
     return ret;
 }
 
-static const WCHAR mntr_key[] =
-    {'\\','R','e','g','i','s','t','r','y','\\','M','a','c','h','i','n','e','\\',
-     'S','o','f','t','w','a','r','e','\\','M','i','c','r','o','s','o','f','t','\\',
-     'W','i','n','d','o','w','s',' ','N','T','\\','C','u','r','r','e','n','t',
-     'V','e','r','s','i','o','n','\\','I','C','M','\\','m','n','t','r'};
-
-static const WCHAR color_path[] =
-    {'\\','?','?','\\','c',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2',
-     '\\','s','p','o','o','l','\\','d','r','i','v','e','r','s','\\','c','o','l','o','r','\\'};
-
-/***********************************************************************
- *              GetICMProfile (X11DRV.@)
- */
-BOOL X11DRV_GetICMProfile( PHYSDEV dev, BOOL allow_default, LPDWORD size, LPWSTR filename )
+void init_icm_profile(void)
 {
-    static const WCHAR srgb[] =
-        {'s','R','G','B',' ','C','o','l','o','r',' ','S','p','a','c','e',' ',
-         'P','r','o','f','i','l','e','.','i','c','m',0};
-    HKEY hkey;
-    DWORD required;
-    char buf[4096];
-    KEY_VALUE_FULL_INFORMATION *info = (void *)buf;
+    static const WCHAR icm[] = {'.','i','c','m',0};
+    static const WCHAR mntr[] = {'m','n','t','r',0};
+    static const WCHAR color_path[] = {'\\','?','?','\\','c',':','\\','w','i','n','d','o','w','s',
+                                       '\\','s','y','s','t','e','m','3','2','\\','s','p','o','o','l',
+                                       '\\','d','r','i','v','e','r','s','\\','c','o','l','o','r','\\',0};
+    static const WCHAR icm_key[] = {'\\','R','e','g','i','s','t','r','y','\\','M','a','c','h','i','n','e',
+                                    '\\','S','o','f','t','w','a','r','e',
+                                    '\\','M','i','c','r','o','s','o','f','t',
+                                    '\\','W','i','n','d','o','w','s',' ','N','T',
+                                    '\\','C','u','r','r','e','n','t', 'V','e','r','s','i','o','n',
+                                    '\\','I','C','M',0};
     char *buffer;
     unsigned long buflen, i;
-    ULONG full_size;
-    WCHAR fullname[MAX_PATH + ARRAY_SIZE( color_path )], *p;
+    UINT64 hash = 0;
+    WCHAR filename[sizeof(hash) * 2 + ARRAY_SIZE(icm)];
+    WCHAR fullname[ARRAY_SIZE(color_path) + ARRAY_SIZE(filename)];
     UNICODE_STRING name;
     OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK io;
+    HANDLE file, key, subkey;
+    NTSTATUS status;
+    ULONG dispos;
 
-    if (!size) return FALSE;
-
-    memcpy( fullname, color_path, sizeof(color_path) );
-    p = fullname + ARRAYSIZE(color_path);
-
-    hkey = reg_open_key( NULL, mntr_key, sizeof(mntr_key) );
+    if (!(buffer = get_icm_profile( &buflen ))) return;
 
-    if (hkey && !NtEnumerateValueKey( hkey, 0, KeyValueFullInformation,
-                                      info, sizeof(buf), &full_size ))
+    for (i = 0; i < buflen; i++) hash = (hash << 16) - hash + buffer[i];
+    for (i = 0; i < sizeof(hash) * 2; i++)
     {
-        /* FIXME handle multiple values */
-        memcpy( p, info->Name, info->NameLength );
-        p[info->NameLength / sizeof(WCHAR)] = 0;
+        int digit = hash & 0xf;
+        filename[i] = digit < 10 ? '0' + digit : 'a' - 10 + digit;
+        hash >>= 4;
     }
-    else if ((buffer = get_icm_profile( &buflen )))
+    wcscpy( filename + i, icm );
+    wcscpy( fullname, color_path );
+    wcscat( fullname, filename );
+
+    RtlInitUnicodeString( &name, fullname );
+    InitializeObjectAttributes( &attr, &name, OBJ_CASE_INSENSITIVE, NULL, NULL );
+    status = NtCreateFile( &file, GENERIC_WRITE, &attr, &io, NULL, 0, 0, FILE_CREATE,
+                           FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0 );
+    if (!status)
     {
-        static const WCHAR icm[] = {'.','i','c','m',0};
-        IO_STATUS_BLOCK io = {{0}};
-        UINT64 hash = 0;
-        HANDLE file;
-        int status;
+        status = NtWriteFile( file, NULL, NULL, NULL, &io, buffer, buflen, NULL, NULL );
+        if (status) ERR( "Unable to write color profile: %x\n", status );
+        NtClose( file );
+    }
+    free( buffer );
 
-        for (i = 0; i < buflen; i++) hash = (hash << 16) - hash + buffer[i];
-        for (i = 0; i < sizeof(hash) * 2; i++)
-        {
-            int digit = hash & 0xf;
-            p[i] = digit < 10 ? '0' + digit : 'a' - 10 + digit;
-            hash >>= 4;
-        }
+    if (status && status != STATUS_OBJECT_NAME_COLLISION) return;
 
-        memcpy( p + i, icm, sizeof(icm) );
+    RtlInitUnicodeString( &name, icm_key );
+    if (NtCreateKey( &key, MAXIMUM_ALLOWED, &attr, 0, NULL, 0, NULL )) return;
 
-        RtlInitUnicodeString( &name, fullname );
-        InitializeObjectAttributes( &attr, &name, OBJ_CASE_INSENSITIVE, NULL, NULL );
-        status = NtCreateFile( &file, GENERIC_WRITE, &attr, &io, NULL, 0, 0, FILE_CREATE,
-                               FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0 );
-        if (!status)
-        {
-            status = NtWriteFile( file, NULL, NULL, NULL, &io, buffer, buflen, NULL, NULL );
-            if (status) ERR( "Unable to write color profile: %x\n", status );
-            NtClose( file );
-        }
-        free( buffer );
-    }
-    else if (!allow_default) return FALSE;
-    else lstrcpyW( p, srgb );
+    RtlInitUnicodeString( &name, mntr );
+    attr.RootDirectory = key;
+    status = NtCreateKey( &subkey, MAXIMUM_ALLOWED, &attr, 0, NULL, REG_OPTION_VOLATILE, &dispos );
+    NtClose( key );
+    if (status) return;
 
-    NtClose( hkey );
-    required = wcslen( fullname ) + 1 - 4 /* skip NT prefix */;
-    if (*size < required)
-    {
-        *size = required;
-        RtlSetLastWin32Error( ERROR_INSUFFICIENT_BUFFER );
-        return FALSE;
-    }
-    if (filename)
+    /* FIXME: support multiple profiles */
+
+    if (dispos == REG_CREATED_NEW_KEY)
     {
-        FILE_BASIC_INFORMATION info;
-        wcscpy( filename, fullname + 4 );
-        RtlInitUnicodeString( &name, fullname );
-        InitializeObjectAttributes( &attr, &name, OBJ_CASE_INSENSITIVE, NULL, NULL );
-        if (NtQueryAttributesFile( &attr, &info ))
-            WARN( "color profile not found in %s\n", debugstr_w(fullname) );
+        BYTE data[12] = { 0 };
+        RtlInitUnicodeString( &name, filename );
+        NtSetValueKey( subkey, &name, 0, REG_BINARY, data, sizeof(data) );
+        TRACE( "created mntr entry for %s\n", debugstr_w(filename) );
     }
-    *size = required;
-    return TRUE;
+    NtClose( subkey );
 }
diff -urN proton_wine10.0/dlls/winex11.drv/init.c wine-10.15/dlls/winex11.drv/init.c
--- proton_wine10.0/dlls/winex11.drv/init.c	2025-11-16 17:00:20.243403388 +0800
+++ wine-10.15/dlls/winex11.drv/init.c	2025-09-13 03:36:38.000000000 +0800
@@ -31,6 +31,7 @@
 #include "winbase.h"
 #include "winreg.h"
 #include "x11drv.h"
+#include "xcomposite.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
@@ -138,7 +139,6 @@
     X11DRV_PDEVICE *physDev = get_x11drv_dev( dev );
 
     XFreeGC( gdi_display, physDev->gc );
-    if (physDev->region) NtGdiDeleteObjectApp( physDev->region );
     free( physDev );
     return TRUE;
 }
@@ -218,50 +218,11 @@
     return ret > 0;
 }
 
-BOOL needs_offscreen_rendering( HWND hwnd, BOOL known_child, BOOL check_gamma )
+BOOL needs_offscreen_rendering( HWND hwnd )
 {
-    static int no_child_clipping_cached = -1;
-    struct window_surface *surface;
-    DWORD layered_flags;
-
-    UINT style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
-    struct x11drv_win_data *data;
-    BOOL needs_offscreen;
-
-    if (no_child_clipping_cached == -1)
-    {
-        const char *sgi = getenv( "SteamGameId" );
-
-        no_child_clipping_cached = sgi && (!strcmp( sgi, "2229850" ) || !strcmp( sgi, "2229880" ));
-        if (no_child_clipping_cached) FIXME( "HACK: disabling child GL window clipping.\n" );
-    }
-
-    if (!(data = get_win_data( hwnd ))) needs_offscreen = TRUE; /* window is in a different process */
-    else
-    {
-        needs_offscreen = (style & WS_VISIBLE) && !(style & WS_MINIMIZE) && !is_window_rect_mapped( &data->rects.visible );
-        release_win_data( data );
-    }
-
-    if (!needs_offscreen && style & WS_EX_LAYERED && NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, &layered_flags )
-        && layered_flags & LWA_COLORKEY)
-        needs_offscreen = TRUE;
-
-    if (!needs_offscreen && (surface = window_surface_get( hwnd )))
-    {
-        TRACE("hwnd %p, surface %p, surface->alpha_mask %#x.\n", hwnd, surface, surface->alpha_mask);
-        /* 3d drawing to ULW window never gets onscreen directly, only though UpdateLayeredWindow(). */
-        needs_offscreen = !!surface->alpha_mask;
-        window_surface_release( surface );
-    }
-    if (needs_offscreen) return needs_offscreen;
-
-    if (NtUserGetDpiForWindow( hwnd ) != NtUserGetWinMonitorDpi( hwnd, MDT_RAW_DPI )
-        && !enable_fullscreen_hack( hwnd, check_gamma ))
-        return TRUE; /* needs DPI scaling */
+    if (NtUserGetDpiForWindow( hwnd ) != NtUserGetWinMonitorDpi( hwnd, MDT_RAW_DPI )) return TRUE; /* needs DPI scaling */
     if (NtUserGetAncestor( hwnd, GA_PARENT ) != NtUserGetDesktopWindow()) return TRUE; /* child window, needs compositing */
-    if (no_child_clipping_cached) return FALSE;
-    if (NtUserGetWindowRelative( hwnd, GW_CHILD ) || known_child) return needs_client_window_clipping( hwnd ); /* window has children, needs compositing */
+    if (NtUserGetWindowRelative( hwnd, GW_CHILD )) return needs_client_window_clipping( hwnd ); /* window has children, needs compositing */
     return FALSE;
 }
 
@@ -295,6 +256,187 @@
     return 0;
 }
 
+static const struct client_surface_funcs x11drv_client_surface_funcs;
+
+struct x11drv_client_surface
+{
+    struct client_surface client;
+    Window window;
+    RECT rect;
+
+    HDC hdc_src;
+    HDC hdc_dst;
+};
+
+static struct x11drv_client_surface *impl_from_client_surface( struct client_surface *client )
+{
+    return CONTAINING_RECORD( client, struct x11drv_client_surface, client );
+}
+
+static void x11drv_client_surface_destroy( struct client_surface *client )
+{
+    struct x11drv_client_surface *surface = impl_from_client_surface( client );
+    HWND hwnd = client->hwnd;
+
+    TRACE( "%s\n", debugstr_client_surface( client ) );
+
+    if (surface->window) destroy_client_window( hwnd, surface->window );
+    if (surface->hdc_dst) NtGdiDeleteObjectApp( surface->hdc_dst );
+    if (surface->hdc_src) NtGdiDeleteObjectApp( surface->hdc_src );
+}
+
+static void x11drv_client_surface_detach( struct client_surface *client )
+{
+    struct x11drv_client_surface *surface = impl_from_client_surface( client );
+    Window client_window = surface->window;
+    struct x11drv_win_data *data;
+    HWND hwnd = client->hwnd;
+
+    TRACE( "%s\n", debugstr_client_surface( client ) );
+
+    if ((data = get_win_data( hwnd )))
+    {
+        detach_client_window( data, client_window );
+        release_win_data( data );
+    }
+}
+
+static void client_surface_update_size( HWND hwnd, struct x11drv_client_surface *surface )
+{
+    XWindowChanges changes;
+    RECT rect;
+
+    NtUserGetClientRect( hwnd, &rect, NtUserGetDpiForWindow( hwnd ) );
+    if (EqualRect( &surface->rect, &rect )) return;
+
+    changes.width  = min( max( 1, rect.right ), 65535 );
+    changes.height = min( max( 1, rect.bottom ), 65535 );
+    XConfigureWindow( gdi_display, surface->window, CWWidth | CWHeight, &changes );
+    surface->rect = rect;
+}
+
+static void client_surface_update_offscreen( HWND hwnd, struct x11drv_client_surface *surface )
+{
+    BOOL offscreen = needs_offscreen_rendering( hwnd );
+    struct x11drv_win_data *data;
+
+    if (InterlockedExchange( &surface->client.offscreen, offscreen ) == offscreen)
+    {
+        if (!offscreen && (data = get_win_data( hwnd )))
+        {
+            attach_client_window( data, surface->window );
+            release_win_data( data );
+        }
+        return;
+    }
+
+    if (!offscreen)
+    {
+#ifdef SONAME_LIBXCOMPOSITE
+        if (usexcomposite) pXCompositeUnredirectWindow( gdi_display, surface->window, CompositeRedirectManual );
+#endif
+        if (surface->hdc_dst)
+        {
+            NtGdiDeleteObjectApp( surface->hdc_dst );
+            surface->hdc_dst = NULL;
+        }
+        if (surface->hdc_src)
+        {
+            NtGdiDeleteObjectApp( surface->hdc_src );
+            surface->hdc_src = NULL;
+        }
+    }
+    else
+    {
+        static const WCHAR displayW[] = {'D','I','S','P','L','A','Y'};
+        UNICODE_STRING device_str = RTL_CONSTANT_STRING(displayW);
+        surface->hdc_dst = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
+        surface->hdc_src = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
+        set_dc_drawable( surface->hdc_src, surface->window, &surface->rect, IncludeInferiors );
+#ifdef SONAME_LIBXCOMPOSITE
+        if (usexcomposite) pXCompositeRedirectWindow( gdi_display, surface->window, CompositeRedirectManual );
+#endif
+    }
+
+    if ((data = get_win_data( hwnd )))
+    {
+        if (offscreen) detach_client_window( data, surface->window );
+        else attach_client_window( data, surface->window );
+        release_win_data( data );
+    }
+}
+
+static void x11drv_client_surface_update( struct client_surface *client )
+{
+    struct x11drv_client_surface *surface = impl_from_client_surface( client );
+    HWND hwnd = client->hwnd;
+
+    TRACE( "%s\n", debugstr_client_surface( client ) );
+
+    client_surface_update_size( hwnd, surface );
+    client_surface_update_offscreen( hwnd, surface );
+}
+
+static void X11DRV_client_surface_present( struct client_surface *client, HDC hdc )
+{
+    struct x11drv_client_surface *surface = impl_from_client_surface( client );
+    HWND hwnd = client->hwnd, toplevel = NtUserGetAncestor( hwnd, GA_ROOT );
+    struct x11drv_win_data *data;
+    RECT rect_dst, rect;
+    Drawable window;
+    HRGN region;
+
+    client_surface_update_size( hwnd, surface );
+    client_surface_update_offscreen( hwnd, surface );
+
+    if (!hdc) return;
+    window = X11DRV_get_whole_window( toplevel );
+    region = get_dc_monitor_region( hwnd, hdc );
+
+    NtUserGetClientRect( hwnd, &rect_dst, NtUserGetWinMonitorDpi( hwnd, MDT_RAW_DPI ) );
+    NtUserMapWindowPoints( hwnd, toplevel, (POINT *)&rect_dst, 2, NtUserGetWinMonitorDpi( hwnd, MDT_RAW_DPI ) );
+
+    if ((data = get_win_data( toplevel )))
+    {
+        OffsetRect( &rect_dst, data->rects.client.left - data->rects.visible.left,
+                    data->rects.client.top - data->rects.visible.top );
+        release_win_data( data );
+    }
+
+    if (get_dc_drawable( surface->hdc_dst, &rect ) != window || !EqualRect( &rect, &rect_dst ))
+        set_dc_drawable( surface->hdc_dst, window, &rect_dst, IncludeInferiors );
+    if (region) NtGdiExtSelectClipRgn( surface->hdc_dst, region, RGN_COPY );
+
+    NtGdiStretchBlt( surface->hdc_dst, 0, 0, rect_dst.right - rect_dst.left, rect_dst.bottom - rect_dst.top,
+                     surface->hdc_src, 0, 0, surface->rect.right, surface->rect.bottom, SRCCOPY, 0 );
+
+    if (region) NtGdiDeleteObjectApp( region );
+}
+
+static const struct client_surface_funcs x11drv_client_surface_funcs =
+{
+    .destroy = x11drv_client_surface_destroy,
+    .detach = x11drv_client_surface_detach,
+    .update = x11drv_client_surface_update,
+    .present = X11DRV_client_surface_present,
+};
+
+Window x11drv_client_surface_create( HWND hwnd, const XVisualInfo *visual, Colormap colormap, struct client_surface **client )
+{
+    struct x11drv_client_surface *surface;
+
+    if (!(surface = client_surface_create( sizeof(*surface), &x11drv_client_surface_funcs, hwnd ))) return None;
+    if (!(surface->window = create_client_window( hwnd, visual, colormap )))
+    {
+        client_surface_release( &surface->client );
+        return None;
+    }
+    NtUserGetClientRect( hwnd, &surface->rect, NtUserGetDpiForWindow( hwnd ) );
+
+    *client = &surface->client;
+    return surface->window;
+}
+
 /**********************************************************************
  *           ExtEscape  (X11DRV.@)
  */
@@ -411,14 +553,6 @@
     return 0;
 }
 
-/**********************************************************************
- *           X11DRV_wine_get_wgl_driver
- */
-static struct opengl_funcs *X11DRV_wine_get_wgl_driver( UINT version )
-{
-    return get_glx_driver( version );
-}
-
 
 static const struct user_driver_funcs x11drv_funcs =
 {
@@ -432,8 +566,7 @@
     .dc_funcs.pExtFloodFill = X11DRV_ExtFloodFill,
     .dc_funcs.pFillPath = X11DRV_FillPath,
     .dc_funcs.pGetDeviceCaps = X11DRV_GetDeviceCaps,
-    .dc_funcs.pGetDeviceGammaRamp = fs_hack_get_gamma_ramp,
-    .dc_funcs.pGetICMProfile = X11DRV_GetICMProfile,
+    .dc_funcs.pGetDeviceGammaRamp = X11DRV_GetDeviceGammaRamp,
     .dc_funcs.pGetImage = X11DRV_GetImage,
     .dc_funcs.pGetNearestColor = X11DRV_GetNearestColor,
     .dc_funcs.pGetSystemPaletteEntries = X11DRV_GetSystemPaletteEntries,
@@ -456,7 +589,7 @@
     .dc_funcs.pSetDCBrushColor = X11DRV_SetDCBrushColor,
     .dc_funcs.pSetDCPenColor = X11DRV_SetDCPenColor,
     .dc_funcs.pSetDeviceClipping = X11DRV_SetDeviceClipping,
-    .dc_funcs.pSetDeviceGammaRamp = fs_hack_set_gamma_ramp,
+    .dc_funcs.pSetDeviceGammaRamp = X11DRV_SetDeviceGammaRamp,
     .dc_funcs.pSetPixel = X11DRV_SetPixel,
     .dc_funcs.pStretchBlt = X11DRV_StretchBlt,
     .dc_funcs.pStrokeAndFillPath = X11DRV_StrokeAndFillPath,
@@ -474,6 +607,7 @@
     .pSetIMECompositionRect = X11DRV_SetIMECompositionRect,
     .pDestroyCursorIcon = X11DRV_DestroyCursorIcon,
     .pSetCursor = X11DRV_SetCursor,
+    .pGetCursorPos = X11DRV_GetCursorPos,
     .pSetCursorPos = X11DRV_SetCursorPos,
     .pClipCursor = X11DRV_ClipCursor,
     .pSystrayDockInit = X11DRV_SystrayDockInit,
@@ -487,7 +621,6 @@
     .pDesktopWindowProc = X11DRV_DesktopWindowProc,
     .pDestroyWindow = X11DRV_DestroyWindow,
     .pFlashWindowEx = X11DRV_FlashWindowEx,
-    .pHasWindowManager = X11DRV_HasWindowManager,
     .pGetDC = X11DRV_GetDC,
     .pProcessEvents = X11DRV_ProcessEvents,
     .pReleaseDC = X11DRV_ReleaseDC,
@@ -515,7 +648,7 @@
     .pWindowPosChanged = X11DRV_WindowPosChanged,
     .pSystemParametersInfo = X11DRV_SystemParametersInfo,
     .pVulkanInit = X11DRV_VulkanInit,
-    .pwine_get_wgl_driver = X11DRV_wine_get_wgl_driver,
+    .pOpenGLInit = X11DRV_OpenGLInit,
     .pThreadDetach = X11DRV_ThreadDetach,
 };
 
diff -urN proton_wine10.0/dlls/winex11.drv/keyboard.c wine-10.15/dlls/winex11.drv/keyboard.c
--- proton_wine10.0/dlls/winex11.drv/keyboard.c	2025-11-16 17:00:20.244403361 +0800
+++ wine-10.15/dlls/winex11.drv/keyboard.c	2025-09-13 03:36:38.000000000 +0800
@@ -1353,7 +1353,7 @@
 
     if (event->type == KeyPress && (data = get_win_data( hwnd )))
     {
-        update_user_time( data, event->time, FALSE );
+        window_set_user_time( data, event->time, FALSE );
         release_win_data( data );
     }
 
@@ -1435,35 +1435,6 @@
     return TRUE;
 }
 
-/* From the point of view of this function there are two types of
- * keys: those for which the mapping to vkey and scancode depends on
- * the keyboard layout (i.e., letters, numbers, punctuation) and those
- * for which it doesn't (control keys); since this function is used to
- * recognize the keyboard layout and map keysyms to vkeys and
- * scancodes, we are only concerned about the first type, and map
- * everything in the second type to zero.
- */
-static char keysym_to_char( KeySym keysym )
-{
-    /* Dead keys */
-    if (0xfe50 <= keysym && keysym < 0xfed0)
-        return KEYBOARD_MapDeadKeysym( keysym );
-
-    /* Control keys (there is nothing allocated below 0xfc00, but I
-       take some margin in case something is added in the future) */
-    if (0xf000 <= keysym && keysym < 0x10000)
-        return 0;
-
-    /* XFree86 vendor keys */
-    if (0x10000000 <= keysym)
-        return 0;
-
-    /* "Normal" keys: return last octet, because our tables don't have
-       more than that; it would be better to extend the tables and
-       compare the whole keysym, but it's a lot of work... */
-    return keysym & 0xff;
-}
-
 /**********************************************************************
  *		X11DRV_KEYBOARD_DetectLayout
  *
@@ -1494,20 +1465,22 @@
       /* get data for keycode from X server */
       for (i = 0; i < syms; i++) {
         if (!(keysym = XkbKeycodeToKeysym( display, keyc, 0, i ))) continue;
-        ckey[keyc][i] = keysym_to_char(keysym);
-        if (TRACE_ON(keyboard))
+	/* Allow both one-byte and two-byte national keysyms */
+	if ((keysym < 0x8000) && (keysym != ' '))
         {
-            char buf[32];
-            WCHAR bufW[32];
-            int len, lenW;
-            KeySym orig_keysym = keysym;
-            len = XkbTranslateKeySym(display, &keysym, 0, buf, sizeof(buf), NULL);
-            lenW = ntdll_umbstowcs(buf, len, bufW, ARRAY_SIZE(bufW));
-            if (lenW < ARRAY_SIZE(bufW))
-                bufW[lenW] = 0;
-            TRACE("keycode %u, index %d, orig_keysym 0x%04lx, keysym 0x%04lx, buf %s, bufW %s\n",
-                    keyc, i, orig_keysym, keysym, debugstr_a(buf), debugstr_w(bufW));
+            if (!XkbTranslateKeySym(display, &keysym, 0, &ckey[keyc][i], 1, NULL))
+            {
+                TRACE("XKB could not translate keysym %04lx\n", keysym);
+                /* FIXME: query what keysym is used as Mode_switch, fill XKeyEvent
+                 * with appropriate ShiftMask and Mode_switch, use XLookupString
+                 * to get character in the local encoding.
+                 */
+                ckey[keyc][i] = keysym & 0xFF;
+            }
         }
+	else {
+	  ckey[keyc][i] = KEYBOARD_MapDeadKeysym(keysym);
+	}
       }
   }
 
@@ -1681,8 +1654,20 @@
 	      /* we seem to need to search the layout-dependent scancodes */
 	      int maxlen=0,maxval=-1,ok;
 	      for (i=0; i<syms; i++) {
-    keysym = XkbKeycodeToKeysym( display, keyc, 0, i );
-                ckey[i] = keysym_to_char(keysym);
+		keysym = XkbKeycodeToKeysym( display, keyc, 0, i );
+		if ((keysym<0x8000) && (keysym!=' '))
+                {
+                    if (!XkbTranslateKeySym(display, &keysym, 0, &ckey[i], 1, NULL))
+                    {
+                        /* FIXME: query what keysym is used as Mode_switch, fill XKeyEvent
+                         * with appropriate ShiftMask and Mode_switch, use XLookupString
+                         * to get character in the local encoding.
+                         */
+                        ckey[i] = (keysym <= 0x7F) ? keysym : 0;
+                    }
+		} else {
+		  ckey[i] = KEYBOARD_MapDeadKeysym(keysym);
+		}
 	      }
 	      /* find key with longest match streak */
 	      for (keyn=0; keyn<MAIN_LEN; keyn++) {
@@ -1850,7 +1835,11 @@
     return TRUE;
 }
 
-static BOOL X11DRV_KeyboardMappingNotify( HWND dummy, XEvent *event )
+
+/***********************************************************************
+ *           X11DRV_MappingNotify
+ */
+BOOL X11DRV_MappingNotify( HWND dummy, XEvent *event )
 {
     HWND hwnd;
 
@@ -1864,24 +1853,6 @@
     return TRUE;
 }
 
-/***********************************************************************
- *           X11DRV_MappingNotify
- */
-BOOL X11DRV_MappingNotify( HWND dummy, XEvent *event )
-{
-    switch (event->xmapping.request)
-    {
-    case MappingModifier:
-    case MappingKeyboard:
-        return X11DRV_KeyboardMappingNotify( dummy, event );
-    case MappingPointer:
-        X11DRV_InitMouse( event->xmapping.display );
-        break;
-    }
-
-    return TRUE;
-}
-
 
 /***********************************************************************
  *		VkKeyScanEx (X11DRV.@)
diff -urN proton_wine10.0/dlls/winex11.drv/Makefile.in wine-10.15/dlls/winex11.drv/Makefile.in
--- proton_wine10.0/dlls/winex11.drv/Makefile.in	2025-11-16 17:00:20.239403497 +0800
+++ wine-10.15/dlls/winex11.drv/Makefile.in	2025-09-13 03:36:38.000000000 +0800
@@ -22,6 +22,7 @@
 	version.rc \
 	vulkan.c \
 	window.c \
+	winex11.drv.spec \
 	wintab.c \
 	x11drv_main.c \
 	xim.c \
diff -urN proton_wine10.0/dlls/winex11.drv/mouse.c wine-10.15/dlls/winex11.drv/mouse.c
--- proton_wine10.0/dlls/winex11.drv/mouse.c	2025-11-16 17:00:20.245403334 +0800
+++ wine-10.15/dlls/winex11.drv/mouse.c	2025-09-13 03:36:38.000000000 +0800
@@ -30,9 +30,6 @@
 #include <X11/Xlib.h>
 #include <X11/cursorfont.h>
 #include <stdarg.h>
-#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-#include <X11/extensions/XInput.h>
-#endif
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
 #include <X11/extensions/XInput2.h>
 #endif
@@ -54,7 +51,6 @@
 #define OEMRESOURCE
 
 #include "x11drv.h"
-#include "xfixes.h"
 #include "winreg.h"
 #include "wine/server.h"
 #include "wine/debug.h"
@@ -79,8 +75,8 @@
     MOUSEEVENTF_RIGHTDOWN,
     MOUSEEVENTF_WHEEL,
     MOUSEEVENTF_WHEEL,
-    MOUSEEVENTF_XDOWN,  /* FIXME: horizontal wheel */
-    MOUSEEVENTF_XDOWN,
+    MOUSEEVENTF_HWHEEL,
+    MOUSEEVENTF_HWHEEL,
     MOUSEEVENTF_XDOWN,
     MOUSEEVENTF_XDOWN
 };
@@ -92,8 +88,8 @@
     MOUSEEVENTF_RIGHTUP,
     0,
     0,
-    MOUSEEVENTF_XUP,
-    MOUSEEVENTF_XUP,
+    0,
+    0,
     MOUSEEVENTF_XUP,
     MOUSEEVENTF_XUP
 };
@@ -105,8 +101,8 @@
     0,
     WHEEL_DELTA,
     -WHEEL_DELTA,
-    XBUTTON1,
-    XBUTTON2,
+    -WHEEL_DELTA,
+    WHEEL_DELTA,
     XBUTTON1,
     XBUTTON2
 };
@@ -118,8 +114,8 @@
     0,
     0,
     0,
-    XBUTTON1,
-    XBUTTON2,
+    0,
+    0,
     XBUTTON1,
     XBUTTON2
 };
@@ -141,14 +137,6 @@
 #undef MAKE_FUNCPTR
 #endif
 
-#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-#define MAKE_FUNCPTR(f) static typeof(f) * p##f
-MAKE_FUNCPTR(XOpenDevice);
-MAKE_FUNCPTR(XCloseDevice);
-MAKE_FUNCPTR(XGetDeviceButtonMapping);
-#undef MAKE_FUNCPTR
-#endif
-
 /***********************************************************************
  *		X11DRV_Xcursor_Init
  *
@@ -236,75 +224,6 @@
     XFlush( gdi_display );
 }
 
-struct mouse_button_mapping
-{
-    int deviceid;
-    unsigned int button_count;
-    unsigned char buttons[256];
-};
-
-static struct mouse_button_mapping *pointer_mapping;
-static struct mouse_button_mapping *device_mapping;
-
-#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-
-static void update_pointer_mapping( Display *display )
-{
-    struct mouse_button_mapping *tmp;
-
-    if (!(tmp = malloc( sizeof(*tmp) )))
-    {
-        WARN("Unable to allocate device mapping.\n");
-        return;
-    }
-
-    tmp->button_count = ARRAY_SIZE( tmp->buttons );
-    tmp->button_count = XGetPointerMapping( display, tmp->buttons, tmp->button_count );
-
-    free( InterlockedExchangePointer( (void**)&pointer_mapping, tmp ) );
-}
-
-static void update_device_mapping( Display *display, int deviceid )
-{
-    struct mouse_button_mapping *tmp;
-    XDevice *device;
-
-    if (!deviceid || !(device = pXOpenDevice( display, deviceid )))
-    {
-        WARN( "Unable to open cursor device %d\n", deviceid );
-        return;
-    }
-
-    if (!(tmp = malloc( sizeof(*tmp) )))
-    {
-        WARN( "Unable to allocate device mapping.\n" );
-        pXCloseDevice( display, device );
-        return;
-    }
-
-    tmp->deviceid = deviceid;
-    tmp->button_count = ARRAY_SIZE( tmp->buttons );
-    tmp->button_count = pXGetDeviceButtonMapping( display, device, tmp->buttons, tmp->button_count );
-
-    free( InterlockedExchangePointer( (void**)&device_mapping, tmp ) );
-
-    pXCloseDevice( display, device );
-}
-
-void X11DRV_InitMouse( Display *display )
-{
-    update_pointer_mapping( display );
-}
-
-#else /* HAVE_X11_EXTENSIONS_XINPUT_H */
-
-void X11DRV_InitMouse( Display *display )
-{
-}
-
-#endif /* HAVE_X11_EXTENSIONS_XINPUT_H */
-
-
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
 /***********************************************************************
  *              update_relative_valuators
@@ -321,18 +240,12 @@
     {
         valuator = (XIValuatorClassInfo *)classes[num_classes];
         if (classes[num_classes]->type != XIValuatorClass) continue;
-        if (valuator->number == 0) thread_data->x_valuator = *valuator;
-        if (valuator->number == 1) thread_data->y_valuator = *valuator;
+        if (valuator->number == 0 && valuator->mode == XIModeRelative) thread_data->x_valuator = *valuator;
+        if (valuator->number == 1 && valuator->mode == XIModeRelative) thread_data->y_valuator = *valuator;
     }
 
     if (thread_data->x_valuator.number < 0 || thread_data->y_valuator.number < 0)
         WARN( "X/Y axis valuators not found, ignoring RawMotion events\n" );
-    else if (thread_data->x_valuator.mode != thread_data->y_valuator.mode)
-    {
-        WARN( "Relative/Absolute mismatch between X/Y axis, ignoring RawMotion events\n" );
-        thread_data->x_valuator.number = -1;
-        thread_data->y_valuator.number = -1;
-    }
 
     thread_data->x_valuator.value = 0;
     thread_data->y_valuator.value = 0;
@@ -344,7 +257,6 @@
  */
 void x11drv_xinput2_enable( Display *display, Window window )
 {
-    struct x11drv_thread_data *thread_data = x11drv_thread_data();
     XIEventMask mask;
     unsigned char mask_bits[XIMaskLen(XI_LASTEVENT)];
 
@@ -359,17 +271,13 @@
     {
         XISetMask( mask_bits, XI_DeviceChanged );
         XISetMask( mask_bits, XI_RawMotion );
-        if (!thread_data->xinput2_rawinput)
-            XISetMask( mask_bits, XI_ButtonPress );
-        else
-        {
-            XISetMask( mask_bits, XI_RawButtonPress );
-            XISetMask( mask_bits, XI_RawButtonRelease );
-
-            XISetMask( mask_bits, XI_RawTouchBegin );
-            XISetMask( mask_bits, XI_RawTouchUpdate );
-            XISetMask( mask_bits, XI_RawTouchEnd );
-        }
+        XISetMask( mask_bits, XI_ButtonPress );
+    }
+    else
+    {
+        XISetMask( mask_bits, XI_TouchBegin );
+        XISetMask( mask_bits, XI_TouchUpdate );
+        XISetMask( mask_bits, XI_TouchEnd );
     }
 
     pXISelectEvents( display, window, &mask, 1 );
@@ -381,12 +289,10 @@
  */
 void x11drv_xinput2_disable( Display *display, Window window )
 {
-    struct x11drv_thread_data *thread_data = x11drv_thread_data();
     unsigned char mask_bits[XIMaskLen(XI_LASTEVENT)];
     XIEventMask mask;
 
     if (!xinput2_available) return;
-    if (thread_data->xinput2_rawinput) return;
 
     mask.mask     = mask_bits;
     mask.mask_len = sizeof(mask_bits);
@@ -545,11 +451,7 @@
 
     TRACE( "no longer clipping\n" );
     XUnmapWindow( data->display, clip_window );
-    if (clipping_cursor)
-    {
-        XUngrabPointer( data->display, CurrentTime );
-        XFlush( data->display );
-    }
+    if (clipping_cursor) XUngrabPointer( data->display, CurrentTime );
     clipping_cursor = FALSE;
     data->clipping_cursor = FALSE;
     x11drv_xinput2_disable( data->display, DefaultRootWindow( data->display ) );
@@ -596,6 +498,7 @@
            x_root, y_root, input );
 
     if (window == root_window) pt = root_to_virtual_screen( pt.x, pt.y );
+    else if (event_root == root_window) pt = root_to_virtual_screen( x_root, y_root );
     else if (!hwnd)
     {
         thread_data = x11drv_thread_data();
@@ -640,7 +543,7 @@
     {
         struct x11drv_thread_data *thread_data = x11drv_thread_data();
         if (!thread_data->clipping_cursor || thread_data->clip_window != window) return;
-        NtUserSendHardwareInput( hwnd, SEND_HWMSG_NO_RAW, input, 0 );
+        NtUserSendHardwareInput( hwnd, 0, input, 0 );
         return;
     }
 
@@ -664,7 +567,7 @@
         SERVER_END_REQ;
     }
 
-    NtUserSendHardwareInput( hwnd, SEND_HWMSG_NO_RAW, input, 0 );
+    NtUserSendHardwareInput( hwnd, 0, input, 0 );
 }
 
 #ifdef SONAME_LIBXCURSOR
@@ -1484,20 +1387,53 @@
 
     if (keyboard_grabbed)
     {
-        WARN( "refusing to warp to %u, %u\n", (int)pos.x, (int)pos.y );
+        WARN( "refusing to warp to %u, %u\n", pos.x, pos.y );
+        return FALSE;
+    }
+
+    if (!clipping_cursor &&
+        XGrabPointer( data->display, root_window, False,
+                      PointerMotionMask | ButtonPressMask | ButtonReleaseMask,
+                      GrabModeAsync, GrabModeAsync, None, None, CurrentTime ) != GrabSuccess)
+    {
+        WARN( "refusing to warp pointer to %u, %u without exclusive grab\n", pos.x, pos.y );
         return FALSE;
     }
 
-    pXFixesHideCursor( data->display, root_window );
     XWarpPointer( data->display, root_window, root_window, 0, 0, 0, 0, pos.x, pos.y );
     data->warp_serial = NextRequest( data->display );
-    pXFixesShowCursor( data->display, root_window );
+
+    if (!clipping_cursor)
+        XUngrabPointer( data->display, CurrentTime );
+
+    XNoOp( data->display );
     XFlush( data->display ); /* avoids bad mouse lag in games that do their own mouse warping */
     TRACE( "warped to %d,%d serial %lu\n", x, y, data->warp_serial );
     return TRUE;
 }
 
 /***********************************************************************
+ *		GetCursorPos (X11DRV.@)
+ */
+BOOL X11DRV_GetCursorPos(LPPOINT pos)
+{
+    Display *display = thread_init_display();
+    Window root, child;
+    int rootX, rootY, winX, winY;
+    unsigned int xstate;
+    BOOL ret;
+
+    ret = XQueryPointer( display, root_window, &root, &child, &rootX, &rootY, &winX, &winY, &xstate );
+    if (ret)
+    {
+        POINT old = *pos;
+        *pos = root_to_virtual_screen( winX, winY );
+        TRACE( "pointer at %s server pos %s\n", wine_dbgstr_point(pos), wine_dbgstr_point(&old) );
+    }
+    return ret;
+}
+
+/***********************************************************************
  *		ClipCursor (X11DRV.@)
  */
 BOOL X11DRV_ClipCursor( const RECT *clip, BOOL reset )
@@ -1570,7 +1506,7 @@
             input.mi.dwFlags     = button_up_flags[button - 1] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
             input.mi.time        = NtGetTickCount();
             input.mi.dwExtraInfo = 0;
-            NtUserSendHardwareInput( hwnd, SEND_HWMSG_NO_RAW, &input, 0 );
+            NtUserSendHardwareInput( hwnd, 0, &input, 0 );
         }
 
         while (NtUserPeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
@@ -1614,7 +1550,7 @@
 
     if ((data = get_win_data( hwnd )))
     {
-        update_user_time( data, event->time, FALSE );
+        window_set_user_time( data, event->time, FALSE );
         release_win_data( data );
     }
 
@@ -1668,7 +1604,7 @@
     input.mi.time        = EVENT_x11_time_to_win32_time( event->time );
     input.mi.dwExtraInfo = 0;
 
-    if (is_old_motion_event( event->serial ))
+    if (!hwnd && is_old_motion_event( event->serial ))
     {
         TRACE( "pos %d,%d old serial %lu, ignoring\n", event->x, event->y, event->serial );
         return FALSE;
@@ -1722,21 +1658,16 @@
     struct x11drv_thread_data *data = x11drv_thread_data();
 
     if (event->deviceid != data->xinput2_pointer) return FALSE;
-    if (event->reason != XISlaveSwitch) return FALSE;
-
     update_relative_valuators( event->classes, event->num_classes );
-    update_device_mapping( event->display, event->sourceid );
-
     return TRUE;
 }
 
-static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input, BOOL send_raw )
+static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     XIValuatorClassInfo *x = &thread_data->x_valuator, *y = &thread_data->y_valuator;
-    const double *values = event->valuators.values, *raw_values = event->raw_values;
-    const UINT absolute_flags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_VIRTUALDESK;
-    double x_raw = 0, y_raw = 0, x_value = 0, y_value = 0, x_scale, y_scale;
+    double x_value = 0, y_value = 0, x_scale, y_scale;
+    const double *values = event->valuators.values;
     RECT virtual_rect;
     int i;
 
@@ -1745,15 +1676,7 @@
     if (!xinput2_available) return FALSE;
     if (event->deviceid != thread_data->xinput2_pointer) return FALSE;
 
-    if (x->mode == XIModeRelative && y->mode == XIModeRelative)
-        input->mi.dwFlags &= ~absolute_flags;
-    else if (x->mode == XIModeAbsolute && y->mode == XIModeAbsolute)
-        input->mi.dwFlags |= absolute_flags;
-    else
-        FIXME( "Unsupported relative/absolute X/Y axis mismatch\n." );
-
-    if (input->mi.dwFlags & MOUSEEVENTF_VIRTUALDESK) SetRect( &virtual_rect, 0, 0, 65535, 65535 );
-    else virtual_rect = NtUserGetVirtualScreenRect( MDT_RAW_DPI );
+    virtual_rect = NtUserGetVirtualScreenRect( MDT_RAW_DPI );
 
     if (x->max <= x->min) x_scale = 1;
     else x_scale = (virtual_rect.right - virtual_rect.left) / (x->max - x->min);
@@ -1765,64 +1688,30 @@
         if (!XIMaskIsSet( event->valuators.mask, i )) continue;
         if (i == x->number)
         {
-            x_raw = *raw_values;
             x_value = *values;
-            if (x->mode == XIModeRelative) x->value += x_value * x_scale;
-            else x->value = (x_value - x->min) * x_scale;
+            x->value += x_value * x_scale;
         }
         if (i == y->number)
         {
-            y_raw = *raw_values;
             y_value = *values;
-            if (y->mode == XIModeRelative) y->value += y_value * y_scale;
-            else y->value = (y_value - y->min) * y_scale;
+            y->value += y_value * y_scale;
         }
-        raw_values++;
         values++;
     }
 
-    if (input->mi.dwFlags & MOUSEEVENTF_ABSOLUTE)
-    {
-        input->mi.dx = round( x->value );
-        input->mi.dy = round( y->value );
-        if (gamescope_screen_rect.bottom)
-        {
-            RECT virtual = NtUserGetVirtualScreenRect( MDT_RAW_DPI );
+    input->mi.dx = round( x->value );
+    input->mi.dy = round( y->value );
 
-            input->mi.dx = input->mi.dx * (gamescope_screen_rect.right - gamescope_screen_rect.left)
-                           / (virtual.right - virtual.left);
-            input->mi.dx = min( input->mi.dx, 65535 );
-
-            input->mi.dy = input->mi.dy * (gamescope_screen_rect.bottom - gamescope_screen_rect.top)
-                           / (virtual.bottom - virtual.top);
-            input->mi.dy = min( input->mi.dy, 65535 );
-        }
-        TRACE( "event %f,%f value %f,%f absolute input %d,%d\n", x_value, y_value, x->value, y->value,
-               (int)input->mi.dx, (int)input->mi.dy );
-    }
-    else if (send_raw)
-    {
-        input->mi.dx = round( x_raw );
-        input->mi.dy = round( y_raw );
-        TRACE( "event %f,%f raw value %f,%f, raw input %d,%d\n", x_value, y_value, x_raw, y_raw,
-               (int)input->mi.dx, (int)input->mi.dy );
-    }
-    else
-    {
-        input->mi.dx = round( x->value );
-        input->mi.dy = round( y->value );
+    TRACE( "event %f,%f value %f,%f input %d,%d\n", x_value, y_value, x->value, y->value,
+           input->mi.dx, input->mi.dy );
 
-        if (!input->mi.dx && !input->mi.dy)
-        {
-            TRACE( "event %f,%f value %f,%f, accumulating motion\n", x_value, y_value, x->value, y->value );
-            input->mi.dwFlags &= ~MOUSEEVENTF_MOVE;
-            return TRUE;
-        }
+    x->value -= input->mi.dx;
+    y->value -= input->mi.dy;
 
-        TRACE( "event %f,%f value %f,%f, input %d,%d\n", x_value, y_value, x->value, y->value,
-               (int)input->mi.dx, (int)input->mi.dy );
-        x->value -= input->mi.dx;
-        y->value -= input->mi.dy;
+    if (!input->mi.dx && !input->mi.dy)
+    {
+        TRACE( "accumulating motion\n" );
+        return FALSE;
     }
 
     return TRUE;
@@ -1833,8 +1722,6 @@
  */
 static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
 {
-    struct x11drv_thread_data *thread_data = x11drv_thread_data();
-    UINT flags = thread_data->xinput2_rawinput ? SEND_HWMSG_NO_MSG : SEND_HWMSG_NO_RAW;
     XIRawEvent *event = xev->data;
     INPUT input;
 
@@ -1851,90 +1738,40 @@
     input.mi.dwExtraInfo = 0;
     input.mi.dx          = 0;
     input.mi.dy          = 0;
-    if (!map_raw_event_coords( event, &input, flags & SEND_HWMSG_NO_MSG )) return FALSE;
-    if (!(input.mi.dwFlags & MOUSEEVENTF_MOVE)) return FALSE;
+    if (!map_raw_event_coords( event, &input )) return FALSE;
 
-    NtUserSendHardwareInput( 0, flags, &input, 0 );
+    NtUserSendHardwareInput( 0, 0, &input, 0 );
     return TRUE;
 }
 
-/***********************************************************************
- *           X11DRV_RawButtonEvent
- */
-static BOOL X11DRV_RawButtonEvent( XGenericEventCookie *cookie )
+static BOOL X11DRV_TouchEvent( HWND hwnd, XGenericEventCookie *xev )
 {
-    struct x11drv_thread_data *thread_data = x11drv_thread_data();
-    const UINT *button_data, *button_flags;
-    XIRawEvent *event = cookie->data;
-    int button = event->detail - 1;
-    INPUT input;
-
-    if (!thread_data->xinput2_rawinput) return FALSE;
-
-    if (!device_mapping || device_mapping->deviceid != event->sourceid)
-        update_device_mapping( event->display, event->sourceid );
-
-    if (button >= 0 && device_mapping)  button = device_mapping->buttons[button] - 1;
-    if (button >= 0 && pointer_mapping) button = pointer_mapping->buttons[button] - 1;
-
-    if (button < 0 || button >= NB_BUTTONS) return FALSE;
-    if (event->deviceid != thread_data->xinput2_pointer) return FALSE;
-
-    TRACE( "raw button %u (raw: %u) %s\n", button, event->detail, event->evtype == XI_RawButtonRelease ? "up" : "down" );
-
-    if (event->evtype == XI_RawButtonRelease)
-    {
-        button_data = button_up_data;
-        button_flags = button_up_flags;
-    }
-    else
-    {
-        button_data = button_down_data;
-        button_flags = button_down_flags;
-    }
-
-    input.type = INPUT_MOUSE;
-    input.mi.mouseData   = button_data[button];
-    input.mi.dwFlags     = button_flags[button] | MOUSEEVENTF_MOVE;
-    input.mi.time        = EVENT_x11_time_to_win32_time( event->time );
-    input.mi.dwExtraInfo = 0;
-    input.mi.dx          = 0;
-    input.mi.dy          = 0;
-    map_raw_event_coords( event, &input, TRUE );
-
-    NtUserSendHardwareInput( 0, SEND_HWMSG_NO_MSG, &input, 0 );
-    return TRUE;
-}
-
-static BOOL X11DRV_RawTouchEvent( HWND hwnd, XGenericEventCookie *xev )
-{
-    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+    RECT virtual = NtUserGetVirtualScreenRect( MDT_RAW_DPI );
     INPUT input = {.type = INPUT_HARDWARE};
-    XIRawEvent *event = xev->data;
+    XIDeviceEvent *event = xev->data;
     int flags = 0;
     POINT pos;
 
-    if (!thread_data->xinput2_rawinput) return FALSE;
-
-    if (!map_raw_event_coords( event, &input, FALSE )) return FALSE;
-    if (!(input.mi.dwFlags & MOUSEEVENTF_ABSOLUTE)) return FALSE;
-    pos.x = input.mi.dx;
-    pos.y = input.mi.dy;
+    input.mi.dx = event->event_x;
+    input.mi.dy = event->event_y;
+    map_event_coords( hwnd, event->event, event->root, event->root_x, event->root_y, &input );
+    pos.x = input.mi.dx * 65535 / (virtual.right - virtual.left);
+    pos.y = input.mi.dy * 65535 / (virtual.bottom - virtual.top);
 
     switch (event->evtype)
     {
-    case XI_RawTouchBegin:
+    case XI_TouchBegin:
         input.hi.uMsg = WM_POINTERDOWN;
         flags |= POINTER_MESSAGE_FLAG_NEW;
-        TRACE("XI_TouchBegin detail %u pos %dx%d, flags %#x\n", event->detail, (int)pos.x, (int)pos.y, flags);
+        TRACE("XI_TouchBegin detail %u pos %dx%d, flags %#x\n", event->detail, pos.x, pos.y, flags);
         break;
-    case XI_RawTouchEnd:
+    case XI_TouchEnd:
         input.hi.uMsg = WM_POINTERUP;
-        TRACE("XI_TouchEnd detail %u pos %dx%d, flags %#x\n", event->detail, (int)pos.x, (int)pos.y, flags);
+        TRACE("XI_TouchEnd detail %u pos %dx%d, flags %#x\n", event->detail, pos.x, pos.y, flags);
         break;
-    case XI_RawTouchUpdate:
+    case XI_TouchUpdate:
         input.hi.uMsg = WM_POINTERUPDATE;
-        TRACE("XI_TouchUpdate detail %u pos %dx%d, flags %#x\n", event->detail, (int)pos.x, (int)pos.y, flags);
+        TRACE("XI_TouchUpdate detail %u pos %dx%d, flags %#x\n", event->detail, pos.x, pos.y, flags);
         break;
     }
 
@@ -1953,7 +1790,7 @@
  */
 void x11drv_xinput2_load(void)
 {
-#if defined(SONAME_LIBXI)
+#if defined(SONAME_LIBXI) && defined(HAVE_X11_EXTENSIONS_XINPUT2_H)
     int event, error;
     void *libxi_handle = dlopen( SONAME_LIBXI, RTLD_NOW );
 
@@ -1969,20 +1806,11 @@
         return; \
     }
 
-#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     LOAD_FUNCPTR(XIGetClientPointer);
     LOAD_FUNCPTR(XIFreeDeviceInfo);
     LOAD_FUNCPTR(XIQueryDevice);
     LOAD_FUNCPTR(XIQueryVersion);
     LOAD_FUNCPTR(XISelectEvents);
-#endif
-
-#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-    LOAD_FUNCPTR(XOpenDevice);
-    LOAD_FUNCPTR(XCloseDevice);
-    LOAD_FUNCPTR(XGetDeviceButtonMapping);
-#endif
-
 #undef LOAD_FUNCPTR
 
     xinput2_available = XQueryExtension( gdi_display, "XInputExtension", &xinput2_opcode, &event, &error );
@@ -2018,15 +1846,11 @@
     case XI_RawMotion:
         ret = X11DRV_RawMotion( event );
         break;
-    case XI_RawButtonPress:
-    case XI_RawButtonRelease:
-        ret = X11DRV_RawButtonEvent( event );
-        break;
 
-    case XI_RawTouchBegin:
-    case XI_RawTouchUpdate:
-    case XI_RawTouchEnd:
-        ret = X11DRV_RawTouchEvent( hwnd, event );
+    case XI_TouchBegin:
+    case XI_TouchUpdate:
+    case XI_TouchEnd:
+        ret = X11DRV_TouchEvent( hwnd, event );
         break;
 
     default:
diff -urN proton_wine10.0/dlls/winex11.drv/opengl.c wine-10.15/dlls/winex11.drv/opengl.c
--- proton_wine10.0/dlls/winex11.drv/opengl.c	2025-11-16 17:00:20.246403306 +0800
+++ wine-10.15/dlls/winex11.drv/opengl.c	2025-09-13 03:36:38.000000000 +0800
@@ -37,25 +37,20 @@
 #ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
-#include <fcntl.h>
-#include <unistd.h>
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "x11drv.h"
 #include "xcomposite.h"
 #include "winternl.h"
 #include "wine/debug.h"
 
-#ifndef ARRAY_SIZE
-#define ARRAY_SIZE( array ) (sizeof(array) / sizeof((array)[0]))
-#endif
-
 #ifdef SONAME_LIBGL
 
 WINE_DEFAULT_DEBUG_CHANNEL(wgl);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
-#include "wine/wgl.h"
-#include "wine/wgl_driver.h"
+#include "wine/opengl_driver.h"
 
 typedef struct __GLXcontextRec *GLXContext;
 typedef struct __GLXFBConfigRec *GLXFBConfig;
@@ -184,7 +179,7 @@
 #define GLX_FLOAT_COMPONENTS_NV           0x20B0
 
 
-static char *glExtensions;
+static const char *glExtensions;
 static const char *glxExtensions;
 static char wglExtensions[4096];
 static int glxVersion[2];
@@ -199,115 +194,17 @@
     DWORD       dwFlags; /* We store some PFD_* flags in here for emulated bitmap formats */
 };
 
-struct fs_hack_fbconfig_attribs
-{
-    int render_type;
-    int buffer_size;
-    int red_size;
-    int green_size;
-    int blue_size;
-    int alpha_size;
-    int depth_size;
-    int stencil_size;
-    int doublebuffer;
-    int samples;
-};
-
-struct fs_hack_fbo_attachments_config
-{
-    GLint color_internalformat;
-    GLenum color_format;
-    GLenum color_type;
-    GLint ds_internalformat;
-    GLenum ds_format;
-    GLenum ds_type;
-    int samples;
-};
-
-struct wgl_context
-{
-    HDC hdc;
-    BOOL has_been_current;
-    BOOL sharing;
-    BOOL gl3_context;
-    const struct glx_pixel_format *fmt;
-    int numAttribs; /* This is needed for delaying wglCreateContextAttribsARB */
-    int attribList[16]; /* This is needed for delaying wglCreateContextAttribsARB */
-    GLXContext ctx;
-    struct gl_drawable *drawables[2];
-    struct gl_drawable *new_drawables[2];
-    BOOL refresh_drawables;
-    BOOL fs_hack;
-    BOOL fs_hack_integer;
-    BOOL is_core;
-    GLuint fs_hack_fbo, fs_hack_resolve_fbo;
-    GLuint fs_hack_color_texture, fs_hack_ds_texture;
-    GLuint fs_hack_color_renderbuffer, fs_hack_ds_renderbuffer;
-    GLuint fs_hack_gamma_pgm, ramp_ubo;
-    POINT setup_for;
-    GLuint current_draw_fbo, current_read_fbo;
-    BOOL drawing_to_front;
-    BOOL fs_hack_needs_resolve;
-    struct list entry;
-};
-
-enum dc_gl_type
-{
-    DC_GL_NONE,       /* no GL support (pixel format not set yet) */
-    DC_GL_WINDOW,     /* normal top-level window */
-    DC_GL_CHILD_WIN,  /* child window using XComposite */
-    DC_GL_PIXMAP_WIN, /* child window using intermediate pixmap */
-    DC_GL_PBUFFER     /* pseudo memory DC using a PBuffer */
-};
-
 struct gl_drawable
 {
-    LONG                           ref;          /* reference count */
-    enum dc_gl_type                type;         /* type of GL surface */
-    HWND                           hwnd;
-    RECT                           rect;         /* current size of the GL drawable */
+    struct opengl_drawable         base;
     GLXDrawable                    drawable;     /* drawable for rendering with GL */
-    Window                         window;       /* window if drawable is a GLXWindow */
     Colormap                       colormap;     /* colormap for the client window */
-    Pixmap                         pixmap;       /* base pixmap if drawable is a GLXPixmap */
-    const struct glx_pixel_format *format;       /* pixel format for the drawable */
-    int                            swap_interval;
-    BOOL                           refresh_swap_interval;
-    BOOL                           mutable_pf;
-    HDC                            hdc_src;
-    HDC                            hdc_dst;
-
-    BOOL fs_hack;
-    BOOL fs_hack_did_swapbuf;
-    BOOL fs_hack_context_set_up;
-    BOOL fs_hack_needs_resolve;
-    BOOL has_scissor_indexed;
-    BOOL has_clip_control;
-    BOOL has_ati_frag_shader;
-    BOOL has_fragment_program;
-    BOOL has_vertex_program;
-    LONG last_gamma_serial;
 };
 
-struct wgl_pbuffer
+static struct gl_drawable *impl_from_opengl_drawable( struct opengl_drawable *base )
 {
-    struct gl_drawable *gl;
-    const struct glx_pixel_format* fmt;
-    int        width;
-    int        height;
-    int*       attribList;
-    int        use_render_texture; /* This is also the internal texture format */
-    int        texture_bind_target;
-    int        texture_bpp;
-    GLint      texture_format;
-    GLuint     texture_target;
-    GLenum     texture_type;
-    GLuint     texture;
-    int        texture_level;
-    GLXContext tmp_context;
-    GLXContext prev_context;
-    struct list entry;
-};
+    return CONTAINING_RECORD( base, struct gl_drawable, base );
+}
 
 enum glx_swap_control_method
 {
@@ -317,18 +214,9 @@
     GLX_SWAP_CONTROL_MESA
 };
 
-static const char *gl_renderer;
-
-/* X context to associate a struct gl_drawable to an hwnd */
-static XContext gl_hwnd_context;
-/* X context to associate a struct gl_drawable to a pbuffer hdc */
-static XContext gl_pbuffer_context;
-
-static struct list context_list = LIST_INIT( context_list );
-static struct list pbuffer_list = LIST_INIT( pbuffer_list );
 static struct glx_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
-static BOOL use_render_texture_emulation = TRUE;
+static const struct egl_platform *egl;
 
 /* Selects the preferred GLX swap control method for use by wglSwapIntervalEXT */
 static enum glx_swap_control_method swap_control_method = GLX_SWAP_CONTROL_NONE;
@@ -336,24 +224,14 @@
 static BOOL has_swap_control_tear = FALSE;
 static BOOL has_swap_method = FALSE;
 
-static pthread_mutex_t context_mutex = PTHREAD_MUTEX_INITIALIZER;
-
 static const BOOL is_win64 = sizeof(void *) > sizeof(int);
 
-static struct opengl_funcs opengl_funcs;
-
-#define USE_GL_FUNC(name) #name,
-static const char *opengl_func_names[] = { ALL_WGL_FUNCS };
-#undef USE_GL_FUNC
-
-static void X11DRV_WineGL_LoadExtensions(void);
-static void init_pixel_formats( Display *display );
 static BOOL glxRequireVersion(int requiredVersion);
 
 static void dump_PIXELFORMATDESCRIPTOR(const PIXELFORMATDESCRIPTOR *ppfd) {
   TRACE( "size %u version %u flags %u type %u color %u %u,%u,%u,%u "
          "accum %u depth %u stencil %u aux %u ",
-         ppfd->nSize, ppfd->nVersion, (int)ppfd->dwFlags, ppfd->iPixelType,
+         ppfd->nSize, ppfd->nVersion, ppfd->dwFlags, ppfd->iPixelType,
          ppfd->cColorBits, ppfd->cRedBits, ppfd->cGreenBits, ppfd->cBlueBits, ppfd->cAlphaBits,
          ppfd->cAccumBits, ppfd->cDepthBits, ppfd->cStencilBits, ppfd->cAuxBuffers );
 #define TEST_AND_DUMP(t,tv) if ((t) & (tv)) TRACE(#tv " ")
@@ -380,9 +258,6 @@
   TRACE("\n");
 }
 
-#define PUSH1(attribs,att)        do { attribs[nAttribs++] = (att); } while (0)
-#define PUSH2(attribs,att,value)  do { attribs[nAttribs++] = (att); attribs[nAttribs++] = (value); } while(0)
-
 /* GLX 1.0 */
 static XVisualInfo* (*pglXChooseVisual)( Display *dpy, int screen, int *attribList );
 static GLXContext (*pglXCreateContext)( Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct );
@@ -440,79 +315,14 @@
         INT64 target_msc, INT64 divisor, INT64 remainder );
 
 /* Standard OpenGL */
-static void (*pglFinish)(void);
-static void (*pglFlush)(void);
 static const GLubyte *(*pglGetString)(GLenum name);
 
-static void wglFinish(void);
-static void wglFlush(void);
-static const GLubyte *wglGetString(GLenum name);
-
-/* Fullscreen hack */
-static void (*pglActiveTexture)( GLenum texture );
-static void (*pglAttachShader)( GLuint program, GLuint shader );
-static void (*pglBindBuffer)( GLenum target, GLuint buffer );
-static void (*pglBindBufferBase)( GLenum target, GLuint index, GLuint buffer );
-static void (*pglBindBufferRange)( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size );
-static void (*pglBindFramebuffer)( GLenum target, GLuint framebuffer );
-static void (*pglBindFramebufferEXT)( GLenum target, GLuint framebuffer );
-static void (*pglBindRenderbuffer)( GLenum target, GLuint renderbuffer );
-static void (*pglBindSampler)( GLuint target, GLuint sampler );
-static void (*pglBlitFramebuffer)( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0,
-                                   GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter );
-static void (*pglBufferData)( GLenum target, GLsizeiptr size, const void *data, GLenum usage );
-static void (*pglClipControl)( GLenum origin, GLenum depth );
-static void (*pglColorMaski)( GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a );
-static void (*pglCompileShader)( GLuint shader );
-static GLuint (*pglCreateProgram)(void);
-static GLuint (*pglCreateShader)( GLenum type );
-static void (*pglDeleteBuffers)( GLsizei n, GLuint *buffers );
-static void (*pglDeleteFramebuffers)( GLsizei n, const GLuint *framebuffers );
-static void (*pglDeleteProgram)( GLuint program );
-static void (*pglDeleteRenderbuffers)( GLsizei n, const GLuint *renderbuffers );
-static void (*pglDeleteShader)( GLuint shader );
-static void (*pglDrawArrays)( GLenum mode, GLint first, GLsizei count );
-static void (*pglDrawBuffer)( GLenum buffer );
-static void (*pglFramebufferRenderbuffer)( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer );
-static void (*pglFramebufferTexture2D)( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );
-static void (*pglGenBuffers)( GLsizei n, GLuint *buffers );
-static void (*pglGenFramebuffers)( GLsizei n, GLuint *ids );
-static void (*pglGetBooleani_v)( GLenum target, GLuint index, GLboolean *data );
-static void (*pglGetInteger64i_v)( GLenum target, GLuint index, GLint64 *data );
-static void (*pglGetIntegeri_v)( GLenum, GLuint, GLint * );
-static void (*pglGetFloati_v)( GLenum, GLuint, GLfloat * );
-static void (*pglGenRenderbuffers)( GLsizei n, GLuint *renderbuffers );
-static void (*pglGetProgramiv)( GLuint program, GLenum pname, GLint *params );
-static void (*pglGetProgramInfoLog)( GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog );
-static void (*pglGetShaderiv)( GLuint shader, GLenum pname, GLint *params );
-static void (*pglGetShaderInfoLog)( GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog );
-static GLuint (*pglGetUniformBlockIndex)( GLuint program, const GLchar *uniformBlockName );
-static GLint (*pglGetUniformLocation)( GLuint program, const GLchar *name );
-static void (*pglLinkProgram)( GLuint program );
-static void (*pglReadBuffer)( GLenum src );
-static void (*pglRenderbufferStorage)( GLenum target, GLenum internalformat, GLsizei width, GLsizei height );
-static void (*pglRenderbufferStorageMultisample)( GLenum target, GLsizei samples, GLenum internalformat,
-                                                  GLsizei width, GLsizei height );
-static void (*pglScissorIndexed)( GLuint, GLint, GLint, GLsizei, GLsizei );
-static void (*pglScissorIndexedv)( GLuint, const GLint * );
-static void (*pglShaderSource)( GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length );
-static void (*pglUniformBlockBinding)( GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding );
-static void (*pglUniform1i)( GLint location, GLint v0 );
-static void (*pglUseProgram)( GLuint program );
-static void (*pglViewportIndexedf)( GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h );
-static void (*pglViewportIndexedfv)( GLuint index, const GLfloat *v );
-static void (*pglGetFramebufferAttachmentParameteriv)( GLenum target, GLenum attachment, GLenum pname, GLint *params );
-static void (*pglCopyTexImage2D)( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border );
-static void (*pglCopyTexSubImage2D)( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height );
-static void (*pglReadPixels)( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data);
-static void wglBindFramebuffer( GLenum target, GLuint framebuffer );
-static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer );
-static void wglDrawBuffer( GLenum buffer );
-static void wglReadBuffer( GLenum src );
-static void wglFramebufferTexture2D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );
-static void wglCopyTexImage2D( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border );
-static void wglCopyTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height );
-static void wglReadPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data);
+static void *opengl_handle;
+static const struct opengl_funcs *funcs;
+static struct opengl_driver_funcs x11drv_driver_funcs;
+static const struct opengl_drawable_funcs x11drv_surface_funcs;
+static const struct opengl_drawable_funcs x11drv_pbuffer_funcs;
+static const struct opengl_drawable_funcs x11drv_egl_surface_funcs;
 
 /* check if the extension is present in the list */
 static BOOL has_extension( const char *list, const char *ext )
@@ -538,12 +348,10 @@
 
 static BOOL X11DRV_WineGL_InitOpenglInfo(void)
 {
-    static const char legacy_extensions[] = " WGL_EXT_extensions_string WGL_EXT_swap_control";
-
     int screen = DefaultScreen(gdi_display);
     Window win = 0, root = 0;
     const char *gl_version;
-    const char* str;
+    const char *gl_renderer;
     BOOL glx_direct;
     XVisualInfo *vis;
     GLXContext ctx = NULL;
@@ -591,12 +399,9 @@
                         "installed correctly\n", is_win64 ? "64-bit" : "32-bit" );
         goto done;
     }
-    gl_renderer = strdup( (const char *)opengl_funcs.gl.p_glGetString(GL_RENDERER) );
-    gl_version  = (const char *)opengl_funcs.gl.p_glGetString(GL_VERSION);
-    str = (const char *) opengl_funcs.gl.p_glGetString(GL_EXTENSIONS);
-    glExtensions = malloc( strlen(str) + sizeof(legacy_extensions) );
-    strcpy(glExtensions, str);
-    strcat(glExtensions, legacy_extensions);
+    gl_renderer = (const char *)pglGetString(GL_RENDERER);
+    gl_version  = (const char *)pglGetString(GL_VERSION);
+    glExtensions = (const char *) pglGetString(GL_EXTENSIONS);
 
     /* Get the common GLX version supported by GLX client and server ( major/minor) */
     pglXQueryVersion(gdi_display, &glxVersion[0], &glxVersion[1]);
@@ -659,12 +464,75 @@
     return ret;
 }
 
-static void *opengl_handle;
+static void x11drv_init_egl_platform( struct egl_platform *platform )
+{
+    platform->type = EGL_PLATFORM_X11_KHR;
+    platform->native_display = gdi_display;
+    egl = platform;
+}
+
+static inline EGLConfig egl_config_for_format(int format)
+{
+    assert(format > 0 && format <= 2 * egl->config_count);
+    if (format <= egl->config_count) return egl->configs[format - 1];
+    return egl->configs[format - egl->config_count - 1];
+}
 
-static void init_opengl(void)
+static BOOL x11drv_egl_surface_create( HWND hwnd, int format, struct opengl_drawable **drawable )
+{
+    struct opengl_drawable *previous;
+    struct client_surface *client;
+    struct gl_drawable *gl;
+    Window window;
+    RECT rect;
+
+    if ((previous = *drawable) && previous->format == format) return TRUE;
+    NtUserGetClientRect( hwnd, &rect, NtUserGetDpiForWindow( hwnd ) );
+
+    if (!(window = x11drv_client_surface_create( hwnd, &default_visual, default_colormap, &client ))) return FALSE;
+    gl = opengl_drawable_create( sizeof(*gl), &x11drv_egl_surface_funcs, format, client );
+    client_surface_release( client );
+    if (!gl) return FALSE;
+
+    if (!(gl->base.surface = funcs->p_eglCreateWindowSurface( egl->display, egl_config_for_format( format ),
+                                                              (void *)window, NULL )))
+    {
+        opengl_drawable_release( &gl->base );
+        return FALSE;
+    }
+
+    TRACE( "Created drawable %s with client window %lx\n", debugstr_opengl_drawable( &gl->base ), window );
+    XFlush( gdi_display );
+
+    if (previous) opengl_drawable_release( previous );
+    *drawable = &gl->base;
+    return TRUE;
+}
+
+/**********************************************************************
+ *           X11DRV_OpenglInit
+ */
+UINT X11DRV_OpenGLInit( UINT version, const struct opengl_funcs *opengl_funcs, const struct opengl_driver_funcs **driver_funcs )
 {
     int error_base, event_base;
-    unsigned int i;
+
+    if (version != WINE_OPENGL_DRIVER_VERSION)
+    {
+        ERR( "version mismatch, opengl32 wants %u but driver has %u\n", version, WINE_OPENGL_DRIVER_VERSION );
+        return STATUS_INVALID_PARAMETER;
+    }
+    funcs = opengl_funcs;
+
+    if (use_egl)
+    {
+        if (!opengl_funcs->egl_handle) return STATUS_NOT_SUPPORTED;
+        WARN( "Using experimental EGL OpenGL backend\n" );
+        x11drv_driver_funcs = **driver_funcs;
+        x11drv_driver_funcs.p_init_egl_platform = x11drv_init_egl_platform;
+        x11drv_driver_funcs.p_surface_create = x11drv_egl_surface_create;
+        *driver_funcs = &x11drv_driver_funcs;
+        return STATUS_SUCCESS;
+    }
 
     /* No need to load any other libraries as according to the ABI, libGL should be self-sufficient
        and include all dependencies */
@@ -673,30 +541,18 @@
     {
         ERR( "Failed to load libGL: %s\n", dlerror() );
         ERR( "OpenGL support is disabled.\n");
-        return;
-    }
-
-    for (i = 0; i < ARRAY_SIZE( opengl_func_names ); i++)
-    {
-        if (!(((void **)&opengl_funcs.gl)[i] = dlsym( opengl_handle, opengl_func_names[i] )))
-        {
-            ERR( "%s not found in libGL, disabling OpenGL.\n", opengl_func_names[i] );
-            goto failed;
-        }
+        return STATUS_NOT_SUPPORTED;
     }
 
     /* redirect some standard OpenGL functions */
-#define REDIRECT(func) \
-    do { p##func = opengl_funcs.gl.p_##func; opengl_funcs.gl.p_##func = w##func; } while(0)
-    REDIRECT( glDrawBuffer );
-    REDIRECT( glFinish );
-    REDIRECT( glFlush );
-    REDIRECT( glGetString );
-    REDIRECT( glReadBuffer );
-    REDIRECT( glCopyTexSubImage2D );
-    REDIRECT( glCopyTexImage2D );
-    REDIRECT( glReadPixels );
-#undef REDIRECT
+#define LOAD_FUNCPTR(func) \
+        if (!(p##func = dlsym( opengl_handle, #func ))) \
+        { \
+            ERR( "%s not found in libGL, disabling OpenGL.\n", #func ); \
+            goto failed; \
+        }
+    LOAD_FUNCPTR( glGetString );
+#undef LOAD_FUNCPTR
 
     pglXGetProcAddressARB = dlsym(opengl_handle, "glXGetProcAddressARB");
     if (pglXGetProcAddressARB == NULL) {
@@ -704,59 +560,6 @@
         goto failed;
     }
 
-    /* Fullscreen hack */
-#define LOAD_FUNCPTR(func) p##func = (void *)pglXGetProcAddressARB((const unsigned char *)#func);
-    LOAD_FUNCPTR( glActiveTexture );
-    LOAD_FUNCPTR( glAttachShader );
-    LOAD_FUNCPTR( glBindBuffer );
-    LOAD_FUNCPTR( glBindBufferBase );
-    LOAD_FUNCPTR( glBindBufferRange );
-    LOAD_FUNCPTR( glBindFramebuffer );
-    LOAD_FUNCPTR( glBindFramebufferEXT );
-    LOAD_FUNCPTR( glBindRenderbuffer );
-    LOAD_FUNCPTR( glBindSampler );
-    LOAD_FUNCPTR( glBlitFramebuffer );
-    LOAD_FUNCPTR( glBufferData );
-    LOAD_FUNCPTR( glClipControl );
-    LOAD_FUNCPTR( glColorMaski );
-    LOAD_FUNCPTR( glCompileShader );
-    LOAD_FUNCPTR( glCreateProgram );
-    LOAD_FUNCPTR( glCreateShader );
-    LOAD_FUNCPTR( glDeleteBuffers );
-    LOAD_FUNCPTR( glDeleteFramebuffers );
-    LOAD_FUNCPTR( glDeleteProgram );
-    LOAD_FUNCPTR( glDeleteRenderbuffers );
-    LOAD_FUNCPTR( glDeleteShader );
-    LOAD_FUNCPTR( glDrawArrays );
-    LOAD_FUNCPTR( glFramebufferRenderbuffer );
-    LOAD_FUNCPTR( glFramebufferTexture2D );
-    LOAD_FUNCPTR( glGenBuffers );
-    LOAD_FUNCPTR( glGenFramebuffers );
-    LOAD_FUNCPTR( glGetBooleani_v );
-    LOAD_FUNCPTR( glGetInteger64i_v );
-    LOAD_FUNCPTR( glGetIntegeri_v );
-    LOAD_FUNCPTR( glGetFloati_v );
-    LOAD_FUNCPTR( glGenRenderbuffers );
-    LOAD_FUNCPTR( glGetProgramiv );
-    LOAD_FUNCPTR( glGetProgramInfoLog );
-    LOAD_FUNCPTR( glGetShaderiv );
-    LOAD_FUNCPTR( glGetShaderInfoLog );
-    LOAD_FUNCPTR( glGetUniformBlockIndex );
-    LOAD_FUNCPTR( glGetUniformLocation );
-    LOAD_FUNCPTR( glLinkProgram );
-    LOAD_FUNCPTR( glRenderbufferStorage );
-    LOAD_FUNCPTR( glRenderbufferStorageMultisample );
-    LOAD_FUNCPTR( glScissorIndexed );
-    LOAD_FUNCPTR( glScissorIndexedv );
-    LOAD_FUNCPTR( glShaderSource );
-    LOAD_FUNCPTR( glUniformBlockBinding );
-    LOAD_FUNCPTR( glUniform1i );
-    LOAD_FUNCPTR( glUseProgram );
-    LOAD_FUNCPTR( glViewportIndexedf );
-    LOAD_FUNCPTR( glViewportIndexedfv );
-    LOAD_FUNCPTR( glGetFramebufferAttachmentParameteriv );
-#undef LOAD_FUNCPTR
-
 #define LOAD_FUNCPTR(f) do if((p##f = (void*)pglXGetProcAddressARB((const unsigned char*)#f)) == NULL) \
     { \
         ERR( "%s not found in libGL, disabling OpenGL.\n", #f ); \
@@ -818,8 +621,6 @@
         ERR( "GLX extension is missing, disabling OpenGL.\n" );
         goto failed;
     }
-    gl_hwnd_context = XUniqueContext();
-    gl_pbuffer_context = XUniqueContext();
 
     /* In case of GLX you have direct and indirect rendering. Most of the time direct rendering is used
      * as in general only that is hardware accelerated. In some cases like in case of remote X indirect
@@ -897,31 +698,13 @@
         pglXSwapBuffersMscOML = pglXGetProcAddressARB( (const GLubyte *)"glXSwapBuffersMscOML" );
     }
 
-    X11DRV_WineGL_LoadExtensions();
-    init_pixel_formats( gdi_display );
-    return;
+    *driver_funcs = &x11drv_driver_funcs;
+    return STATUS_SUCCESS;
 
 failed:
     dlclose(opengl_handle);
     opengl_handle = NULL;
-}
-
-static BOOL has_opengl(void)
-{
-    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
-
-    return !pthread_once( &init_once, init_opengl );
-}
-
-static const char *debugstr_fbconfig( GLXFBConfig fbconfig )
-{
-    int id, visual, drawable;
-
-    if (pglXGetFBConfigAttrib( gdi_display, fbconfig, GLX_FBCONFIG_ID, &id ))
-        return "*** invalid fbconfig";
-    pglXGetFBConfigAttrib( gdi_display, fbconfig, GLX_VISUAL_ID, &visual );
-    pglXGetFBConfigAttrib( gdi_display, fbconfig, GLX_DRAWABLE_TYPE, &drawable );
-    return wine_dbg_sprintf( "fbconfig %#x visual id %#x drawable type %#x", id, visual, drawable );
+    return STATUS_NOT_SUPPORTED;
 }
 
 static int get_render_type_from_fbconfig(Display *display, GLXFBConfig fbconfig)
@@ -950,55 +733,46 @@
 }
 
 /* Check whether a fbconfig is suitable for Windows-style bitmap rendering */
-static BOOL check_fbconfig_bitmap_capability(Display *display, GLXFBConfig fbconfig)
+static BOOL check_fbconfig_bitmap_capability( GLXFBConfig fbconfig, const XVisualInfo *vis )
 {
     int dbuf, value;
-    pglXGetFBConfigAttrib(display, fbconfig, GLX_DOUBLEBUFFER, &dbuf);
+
+    pglXGetFBConfigAttrib( gdi_display, fbconfig, GLX_BUFFER_SIZE, &value );
+    if (vis && value != vis->depth) return FALSE;
+
+    pglXGetFBConfigAttrib( gdi_display, fbconfig, GLX_DOUBLEBUFFER, &dbuf );
     pglXGetFBConfigAttrib(gdi_display, fbconfig, GLX_DRAWABLE_TYPE, &value);
 
-    /* Windows only supports bitmap rendering on single buffered formats, further the fbconfig needs to have
-     * the GLX_PIXMAP_BIT set. */
-    return !dbuf && (value & GLX_PIXMAP_BIT);
+    /* Windows only supports bitmap rendering on single buffered formats. The fbconfig also needs to
+     * have the GLX_PBUFFER_BIT set, because Wine's implementation of bitmap rendering uses
+     * pbuffers. */
+    return !dbuf && (value & GLX_PBUFFER_BIT);
 }
 
-static void init_pixel_formats( Display *display )
+static UINT x11drv_init_pixel_formats( UINT *onscreen_count )
 {
     struct glx_pixel_format *list;
     int size = 0, onscreen_size = 0;
-    int fmt_id, nCfgs, i, run, bmp_formats;
+    int fmt_id, nCfgs, i, run;
     GLXFBConfig* cfgs;
     XVisualInfo *visinfo;
 
-    cfgs = pglXGetFBConfigs(display, DefaultScreen(display), &nCfgs);
+    cfgs = pglXGetFBConfigs(gdi_display, DefaultScreen(gdi_display), &nCfgs);
     if (NULL == cfgs || 0 == nCfgs) {
         if(cfgs != NULL) XFree(cfgs);
         ERR("glXChooseFBConfig returns NULL\n");
-        return;
-    }
-
-    /* Bitmap rendering on Windows implies the use of the Microsoft GDI software renderer.
-     * Further most GLX drivers only offer pixmap rendering using indirect rendering (except for modern drivers which support 'AIGLX' / composite).
-     * Indirect rendering can indicate software rendering (on Nvidia it is hw accelerated)
-     * Since bitmap rendering implies the use of software rendering we can safely use indirect rendering for bitmaps.
-     *
-     * Below we count the number of formats which are suitable for bitmap rendering. Windows restricts bitmap rendering to single buffered formats.
-     */
-    for(i=0, bmp_formats=0; i<nCfgs; i++)
-    {
-        if(check_fbconfig_bitmap_capability(display, cfgs[i]))
-            bmp_formats++;
+        return 0;
     }
-    TRACE("Found %d bitmap capable fbconfigs\n", bmp_formats);
 
-    list = calloc( 1, (nCfgs + bmp_formats) * sizeof(*list) );
+    list = calloc( 1, (nCfgs * 2) * sizeof(*list) );
 
     /* Fill the pixel format list. Put onscreen formats at the top and offscreen ones at the bottom.
      * Do this as GLX doesn't guarantee that the list is sorted */
     for(run=0; run < 2; run++)
     {
         for(i=0; i<nCfgs; i++) {
-            pglXGetFBConfigAttrib(display, cfgs[i], GLX_FBCONFIG_ID, &fmt_id);
-            visinfo = pglXGetVisualFromFBConfig(display, cfgs[i]);
+            pglXGetFBConfigAttrib(gdi_display, cfgs[i], GLX_FBCONFIG_ID, &fmt_id);
+            visinfo = pglXGetVisualFromFBConfig(gdi_display, cfgs[i]);
 
             /* The first run we only add onscreen formats (ones which have an associated X Visual).
              * The second run we only set offscreen formats. */
@@ -1021,19 +795,19 @@
                 list[size].fbconfig = cfgs[i];
                 list[size].visual = visinfo;
                 list[size].fmt_id = fmt_id;
-                list[size].render_type = get_render_type_from_fbconfig(display, cfgs[i]);
+                list[size].render_type = get_render_type_from_fbconfig(gdi_display, cfgs[i]);
                 list[size].dwFlags = 0;
                 size++;
                 onscreen_size++;
 
                 /* Clone a format if it is bitmap capable for indirect rendering to bitmaps */
-                if(check_fbconfig_bitmap_capability(display, cfgs[i]))
+                if (check_fbconfig_bitmap_capability( cfgs[i], visinfo ))
                 {
                     TRACE("Found bitmap capable format FBCONFIG_ID 0x%x corresponding to iPixelFormat %d at GLX index %d\n", fmt_id, size+1, i);
                     list[size].fbconfig = cfgs[i];
                     list[size].visual = visinfo;
                     list[size].fmt_id = fmt_id;
-                    list[size].render_type = get_render_type_from_fbconfig(display, cfgs[i]);
+                    list[size].render_type = get_render_type_from_fbconfig(gdi_display, cfgs[i]);
                     list[size].dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI | PFD_GENERIC_FORMAT;
                     size++;
                     onscreen_size++;
@@ -1057,8 +831,9 @@
                 TRACE("Found offscreen format FBCONFIG_ID 0x%x corresponding to iPixelFormat %d at GLX index %d\n", fmt_id, size+1, i);
                 list[size].fbconfig = cfgs[i];
                 list[size].fmt_id = fmt_id;
-                list[size].render_type = get_render_type_from_fbconfig(display, cfgs[i]);
-                list[size].dwFlags = 0;
+                list[size].render_type = get_render_type_from_fbconfig(gdi_display, cfgs[i]);
+                if (!check_fbconfig_bitmap_capability( cfgs[i], NULL )) list[size].dwFlags = 0;
+                else list[size].dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI | PFD_GENERIC_FORMAT;
                 size++;
             }
             else if (visinfo) XFree(visinfo);
@@ -1070,710 +845,38 @@
     pixel_formats = list;
     nb_pixel_formats = size;
     nb_onscreen_formats = onscreen_size;
-}
-
-static inline BOOL is_valid_pixel_format( int format )
-{
-    return format > 0 && format <= nb_pixel_formats;
-}
-
-static inline BOOL is_onscreen_pixel_format( int format )
-{
-    return format > 0 && format <= nb_onscreen_formats;
-}
-
-static inline int pixel_format_index( const struct glx_pixel_format *format )
-{
-    return format - pixel_formats + 1;
-}
-
-/* GLX can advertise dozens of different pixelformats including offscreen and onscreen ones.
- * In our WGL implementation we only support a subset of these formats namely the format of
- * Wine's main visual and offscreen formats (if they are available).
- * This function converts a WGL format to its corresponding GLX one.
- */
-static const struct glx_pixel_format *get_pixel_format(Display *display, int iPixelFormat, BOOL AllowOffscreen)
-{
-    /* Check if the pixelformat is valid. Note that it is legal to pass an invalid
-     * iPixelFormat in case of probing the number of pixelformats.
-     */
-    if (is_valid_pixel_format( iPixelFormat ) &&
-        (is_onscreen_pixel_format( iPixelFormat ) || AllowOffscreen)) {
-        TRACE("Returning fmt_id=%#x for iPixelFormat=%d\n",
-              pixel_formats[iPixelFormat-1].fmt_id, iPixelFormat);
-        return &pixel_formats[iPixelFormat-1];
-    }
-    return NULL;
-}
-
-static struct gl_drawable *grab_gl_drawable( struct gl_drawable *gl )
-{
-    InterlockedIncrement( &gl->ref );
-    return gl;
-}
-
-static void release_gl_drawable( struct gl_drawable *gl )
-{
-    if (!gl) return;
-    if (InterlockedDecrement( &gl->ref )) return;
-    switch (gl->type)
-    {
-    case DC_GL_WINDOW:
-    case DC_GL_CHILD_WIN:
-        TRACE( "destroying %lx drawable %lx\n", gl->window, gl->drawable );
-        pglXDestroyWindow( gdi_display, gl->drawable );
-        destroy_client_window( gl->hwnd, gl->window );
-        XFreeColormap( gdi_display, gl->colormap );
-        break;
-    case DC_GL_PIXMAP_WIN:
-        TRACE( "destroying pixmap %lx drawable %lx\n", gl->pixmap, gl->drawable );
-        pglXDestroyPixmap( gdi_display, gl->drawable );
-        XFreePixmap( gdi_display, gl->pixmap );
-        break;
-    case DC_GL_PBUFFER:
-        TRACE( "destroying pbuffer drawable %lx\n", gl->drawable );
-        pglXDestroyPbuffer( gdi_display, gl->drawable );
-        break;
-    default:
-        break;
-    }
-    if (gl->hdc_src) NtGdiDeleteObjectApp( gl->hdc_src );
-    if (gl->hdc_dst) NtGdiDeleteObjectApp( gl->hdc_dst );
-    free( gl );
-}
-
-static const char *fs_hack_gamma_vertex_shader_src =
-"#version 330\n"
-"\n"
-"const vec4 square[4] = vec4[4](\n"
-"    vec4(-1.0, -1.0, 0.0, 1.0),\n"
-"    vec4(-1.0, 1.0, 0.0, 1.0),\n"
-"    vec4(1.0, -1.0, 0.0, 1.0),\n"
-"    vec4(1.0, 1.0, 0.0, 1.0)\n"
-");\n"
-"const vec2 texsq[4] = vec2[4](\n"
-"    vec2(0.0, 0.0),\n"
-"    vec2(0.0, 1.0),\n"
-"    vec2(1.0, 0.0),\n"
-"    vec2(1.0, 1.0)\n"
-");\n"
-"\n"
-"out vec2 texCoord;\n"
-"\n"
-"void main(void)\n"
-"{\n"
-"    gl_Position = square[gl_VertexID];\n"
-"    texCoord = texsq[gl_VertexID];\n"
-"}\n"
-;
-
-static const char *fs_hack_gamma_frag_shader_src =
-"#version 330\n"
-"\n"
-"uniform sampler2D tex;\n"
-"in vec2 texCoord;\n"
-"layout (std140) uniform ramp {\n"
-"    vec3 values[256];\n"
-"};\n"
-"\n"
-"layout(location = 0) out vec4 outColor;\n"
-"\n"
-"vec3 color_from_index(vec3 index)\n"
-"{\n"
-"    ivec3 i = ivec3(index);\n"
-"    return vec3(values[i.r].r, values[i.g].g, values[i.b].b);\n"
-"}\n"
-"\n"
-"void main(void)\n"
-"{\n"
-"    vec3 lookup = texture(tex, texCoord).xyz * 255.0;\n"
-"    vec3 lookup1, lookup2;\n"
-"    lookup1 = floor(lookup);\n"
-"    lookup2 = ceil(lookup);\n"
-"    outColor.xyz = mix(color_from_index(lookup1), color_from_index(lookup2), lookup - lookup1);\n"
-"    outColor.a = 1.0;\n"
-"}\n"
-;
-
-static WORD gamma_ramp_i[GAMMA_RAMP_SIZE * 3];
-static float gamma_ramp[GAMMA_RAMP_SIZE * 4];
-static pthread_once_t gamma_init_once = PTHREAD_ONCE_INIT;
-static LONG gamma_serial;
-
-/* Return whether integer scaling is on */
-BOOL fs_hack_is_integer(void)
-{
-    static int is_int = -1;
-    if (is_int < 0)
-    {
-        const char *e = getenv( "WINE_FULLSCREEN_INTEGER_SCALING" );
-        is_int = e && strcmp( e, "0" );
-    }
-    TRACE( "is_interger_scaling: %s\n", is_int ? "TRUE" : "FALSE" );
-    return is_int;
-}
-
-static void init_default_gamma(void)
-{
-    unsigned int i;
-
-    for (i = 0; i < GAMMA_RAMP_SIZE; ++i)
-    {
-        gamma_ramp_i[i] = gamma_ramp_i[i + GAMMA_RAMP_SIZE] = gamma_ramp_i[i + 2 * GAMMA_RAMP_SIZE] =
-            i * 65535 / (GAMMA_RAMP_SIZE - 1);
-
-        gamma_ramp[i * 4] = gamma_ramp_i[i] / 65535.f;
-        gamma_ramp[i * 4 + 1] = gamma_ramp_i[i + GAMMA_RAMP_SIZE] / 65535.f;
-        gamma_ramp[i * 4 + 2] = gamma_ramp_i[i + 2 * GAMMA_RAMP_SIZE] / 65535.f;
-    }
-}
-
-BOOL fs_hack_get_gamma_ramp( PHYSDEV dev, void *data )
-{
-    pthread_once( &gamma_init_once, init_default_gamma );
-    memcpy( data, gamma_ramp_i, sizeof(gamma_ramp_i) );
-    return TRUE;
-}
-
-BOOL fs_hack_set_gamma_ramp( PHYSDEV dev, void *data )
-{
-    const WORD *ramp = data;
-    int i;
-
-    pthread_once( &gamma_init_once, init_default_gamma );
-    if (memcmp( gamma_ramp_i, ramp, sizeof(gamma_ramp_i) ) == 0)
-    {
-        /* identical */
-        return TRUE;
-    }
-    for (i = 0; i < GAMMA_RAMP_SIZE; ++i)
-    {
-        gamma_ramp[i * 4] = ramp[i] / 65535.f;
-        gamma_ramp[i * 4 + 1] = ramp[i + GAMMA_RAMP_SIZE] / 65535.f;
-        gamma_ramp[i * 4 + 2] = ramp[i + 2 * GAMMA_RAMP_SIZE] / 65535.f;
-    }
-    memcpy( gamma_ramp_i, ramp, sizeof(gamma_ramp_i) );
-    if (!InterlockedIncrement( &gamma_serial )) InterlockedIncrement( &gamma_serial );
-    TRACE( "new gamma serial: %u\n", (int)gamma_serial );
-    return TRUE;
-}
-
-const float *fs_hack_get_current_gamma_ramp( LONG *serial )
-{
-    if (!(*serial = ReadNoFence( &gamma_serial ))) return NULL;
-    return gamma_ramp;
-}
-
-static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_hack_fbconfig_attribs *attribs,
-                                            struct fs_hack_fbo_attachments_config *config )
-{
-    if (attribs->render_type != GLX_RGBA_BIT)
-        FIXME( "Unsupported GLX_RENDER_TYPE %#x.\n", attribs->render_type );
-    if (attribs->red_size != 8 || attribs->green_size != 8 || attribs->blue_size != 8)
-        FIXME( "Unsupported RGBA color sizes {%u, %u, %u, %u}.\n", attribs->red_size,
-               attribs->green_size, attribs->blue_size, attribs->alpha_size );
-    config->color_internalformat = attribs->alpha_size ? GL_RGBA8 : GL_RGB8;
-    config->color_format = GL_BGRA;
-    config->color_type = GL_UNSIGNED_INT_8_8_8_8_REV;
-    if (attribs->depth_size || attribs->stencil_size)
-    {
-        if (attribs->depth_size != 24) FIXME( "Unsupported depth buffer size %u.\n", attribs->depth_size );
-        if (attribs->stencil_size && attribs->stencil_size != 8)
-            FIXME( "Unsupported stencil buffer size %u.\n", attribs->stencil_size );
-        config->ds_internalformat = attribs->stencil_size ? GL_DEPTH24_STENCIL8 : GL_DEPTH_COMPONENT24;
-        config->ds_format = attribs->stencil_size ? GL_DEPTH_STENCIL : GL_DEPTH_COMPONENT;
-        config->ds_type = attribs->stencil_size ? GL_UNSIGNED_INT_24_8 : GL_UNSIGNED_INT;
-    }
-    else
-    {
-        config->ds_internalformat = config->ds_format = config->ds_type = 0;
-    }
-    config->samples = attribs->samples;
-}
-
-static const float *fs_hack_get_default_gamma_ramp(void)
-{
-    static float default_gamma_ramp[GAMMA_RAMP_SIZE * 4];
-    static BOOL initialized;
-    unsigned int i;
-
-    if (!initialized)
-    {
-        for (i = 0; i < GAMMA_RAMP_SIZE; i++)
-            default_gamma_ramp[i * 4] = default_gamma_ramp[i * 4 + 1] = default_gamma_ramp[i * 4 + 2] = i / (float)( GAMMA_RAMP_SIZE - 1 );
-        initialized = TRUE;
-    }
-    return default_gamma_ramp;
-}
-
-static void fs_hack_setup_gamma_shader( struct wgl_context *ctx, struct gl_drawable *gl )
-{
-    GLint success;
-    GLuint vshader, fshader, program, ramp_index, tex_loc, prev_program;
-    char errstr[512];
-    const float *default_gamma_ramp = fs_hack_get_default_gamma_ramp();
-
-    gl->last_gamma_serial = 0;
-
-    if (ctx->fs_hack_gamma_pgm) return;
-
-    opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&prev_program );
-    /* vertex shader */
-    vshader = pglCreateShader( GL_VERTEX_SHADER );
-    if (vshader == 0)
-    {
-        ERR( "Failed to create gamma vertex shader\n" );
-        return;
-    }
-    pglShaderSource( vshader, 1, &fs_hack_gamma_vertex_shader_src, NULL );
-    pglCompileShader( vshader );
-
-    pglGetShaderiv( vshader, GL_COMPILE_STATUS, &success );
-    if (!success)
-    {
-        pglGetShaderInfoLog( vshader, sizeof(errstr), NULL, errstr );
-        ERR( "Compiling gamma vertex shader failed: %s\n", errstr );
-        pglDeleteShader( vshader );
-        return;
-    }
-
-    /* fragment shader */
-    fshader = pglCreateShader( GL_FRAGMENT_SHADER );
-    if (fshader == 0)
-    {
-        ERR( "Failed to create gamma fragment shader\n" );
-        pglDeleteShader( vshader );
-        return;
-    }
-    pglShaderSource( fshader, 1, &fs_hack_gamma_frag_shader_src, NULL );
-    pglCompileShader( fshader );
-
-    pglGetShaderiv( fshader, GL_COMPILE_STATUS, &success );
-    if (!success)
-    {
-        pglGetShaderInfoLog( fshader, sizeof(errstr), NULL, errstr );
-        ERR( "Compiling gamma fragment shader failed: %s\n", errstr );
-        pglDeleteShader( fshader );
-        pglDeleteShader( vshader );
-        return;
-    }
-
-    /* gamma program */
-    program = pglCreateProgram();
-    if (program == 0)
-    {
-        ERR( "Failed to create gamma program\n" );
-        pglDeleteShader( fshader );
-        pglDeleteShader( vshader );
-        return;
-    }
-
-    pglAttachShader( program, vshader );
-    pglAttachShader( program, fshader );
-
-    pglLinkProgram( program );
-
-    pglGetProgramiv( program, GL_LINK_STATUS, &success );
-    if (!success)
-    {
-        pglGetProgramInfoLog( program, sizeof(errstr), NULL, errstr );
-        ERR( "Linking gamma shader failed: %s\n", errstr );
-        pglDeleteProgram( program );
-        pglDeleteShader( fshader );
-        pglDeleteShader( vshader );
-        return;
-    }
-
-    pglDeleteShader( fshader );
-    pglDeleteShader( vshader );
-
-    pglGenBuffers( 1, &ctx->ramp_ubo );
-    pglBindBuffer( GL_UNIFORM_BUFFER, ctx->ramp_ubo );
-    pglBufferData( GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, default_gamma_ramp, GL_DYNAMIC_DRAW );
-
-    ramp_index = pglGetUniformBlockIndex( program, "ramp" );
-    pglUniformBlockBinding( program, ramp_index, 0 );
-
-    pglUseProgram( program );
-
-    tex_loc = pglGetUniformLocation( program, "tex" );
-    pglUniform1i( tex_loc, 0 );
-
-    ctx->fs_hack_gamma_pgm = program;
-
-    pglUseProgram( prev_program );
-}
-
-enum fshack_texture_type
-{
-    FSHACK_TEXTURE_COLOUR,
-    FSHACK_TEXTURE_DEPTH,
-    FSHACK_TEXTURE_LAST,
-};
-
-static void gen_texture( struct wgl_context *ctx, GLuint *tex, enum fshack_texture_type type )
-{
-    static const GLuint texture_names[FSHACK_TEXTURE_LAST] =
-    {
-        65535,
-        65536,
-    };
-    static int texture_name_hack = -1;
-    static int once;
-
-    if (ctx->is_core)
-    {
-        opengl_funcs.gl.p_glGenTextures( 1, tex );
-        return;
-    }
-
-    if (texture_name_hack == -1)
-    {
-        const char *sgi = getenv( "SteamGameId" );
-
-        texture_name_hack = sgi && (!strcmp( sgi, "6020" ) || !strcmp( sgi, "2200" ) || !strcmp( sgi, "2350" ) || !strcmp( sgi, "273590" ));
-    }
-
-    if (!texture_name_hack || opengl_funcs.gl.p_glIsTexture( texture_names[type] ))
-    {
-        if (texture_name_hack) FIXME( "Texture %u already exists.\n", texture_names[type] );
-        opengl_funcs.gl.p_glGenTextures( 1, tex );
-        return;
-    }
-    /* Star Wars Jedi Knight: Jedi Academy uses texture names without allocating
-     * them with glGenTextures(). Trying to use a texture name which has low chances
-     * to overlap with what games may use. */
-    if (!once++) FIXME( "Using texture name hack.\n" );
-    *tex = texture_names[type];
-}
-
-static void fs_hack_init_context( struct wgl_context *ctx, struct gl_drawable *gl )
-{
-    GLuint prev_draw_fbo, prev_read_fbo, prev_texture, prev_renderbuffer, prev_pixel_pack_buffer;
-    float prev_clear_color[4], prev_clear_depth;
-    int prev_clear_stencil;
-    unsigned int i;
-    struct fs_hack_fbo_attachments_config config;
-    struct fs_hack_fbconfig_attribs attribs;
-    static const struct fbconfig_attribs_query
-    {
-        int attribute;
-        unsigned int offset;
-    }
-    queries[] =
-    {
-        {GLX_RENDER_TYPE, offsetof(struct fs_hack_fbconfig_attribs, render_type)},
-        {GLX_BUFFER_SIZE, offsetof(struct fs_hack_fbconfig_attribs, buffer_size)},
-        {GLX_RED_SIZE, offsetof(struct fs_hack_fbconfig_attribs, red_size)},
-        {GLX_GREEN_SIZE, offsetof(struct fs_hack_fbconfig_attribs, green_size)},
-        {GLX_BLUE_SIZE, offsetof(struct fs_hack_fbconfig_attribs, blue_size)},
-        {GLX_ALPHA_SIZE, offsetof(struct fs_hack_fbconfig_attribs, alpha_size)},
-        {GLX_DEPTH_SIZE, offsetof(struct fs_hack_fbconfig_attribs, depth_size)},
-        {GLX_STENCIL_SIZE, offsetof(struct fs_hack_fbconfig_attribs, stencil_size)},
-        {GLX_DOUBLEBUFFER, offsetof(struct fs_hack_fbconfig_attribs, doublebuffer)},
-        {GLX_SAMPLES_ARB, offsetof(struct fs_hack_fbconfig_attribs, samples)},
-    };
-    BYTE *ptr = (BYTE *)&attribs;
-    int width, height;
-    RECT rect = {0};
-    GLuint profile;
-    HWND hwnd;
-
-    hwnd = NtUserWindowFromDC( ctx->hdc );
-    NtUserGetClientRect( hwnd, &rect, NtUserGetDpiForWindow( hwnd ) );
-
-    width = rect.right - rect.left;
-    height = rect.bottom - rect.top;
-
-    TRACE( "Render buffer width:%d height:%d\n", width, height );
 
-    opengl_funcs.gl.p_glGetIntegerv( GL_CONTEXT_PROFILE_MASK, (GLint *)&profile );
-    ctx->is_core = (profile & GL_CONTEXT_CORE_PROFILE_BIT) != 0;
-    ctx->fs_hack = TRUE;
-
-    opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
-    opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
-    opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&prev_texture );
-    opengl_funcs.gl.p_glGetIntegerv( GL_RENDERBUFFER_BINDING, (GLint *)&prev_renderbuffer );
-    opengl_funcs.gl.p_glGetIntegerv( GL_PIXEL_UNPACK_BUFFER_BINDING, (GLint *)&prev_pixel_pack_buffer );
-    opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
-    opengl_funcs.gl.p_glGetFloatv( GL_DEPTH_CLEAR_VALUE, &prev_clear_depth );
-    opengl_funcs.gl.p_glGetIntegerv( GL_STENCIL_CLEAR_VALUE, &prev_clear_stencil );
-    TRACE( "Previous draw FBO %u, read FBO %u for ctx %p\n", prev_draw_fbo, prev_read_fbo, ctx );
-
-    pglBindBuffer( GL_PIXEL_UNPACK_BUFFER, 0 );
-
-    if (!ctx->fs_hack_fbo)
-    {
-        pglGenFramebuffers( 1, &ctx->fs_hack_fbo );
-        TRACE( "Created FBO %u for fullscreen hack.\n", ctx->fs_hack_fbo );
-    }
-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
-
-    for (i = 0; i < ARRAY_SIZE(queries); ++i)
-        pglXGetFBConfigAttrib( gdi_display, gl->format->fbconfig, queries[i].attribute,
-                               (int *)&ptr[queries[i].offset] );
-
-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
-
-    fs_hack_get_attachments_config( gl, &attribs, &config );
-
-    if (!ctx->fs_hack_color_texture)
-        gen_texture( ctx, &ctx->fs_hack_color_texture, FSHACK_TEXTURE_COLOUR );
-
-    opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
-    opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.color_internalformat, width,
-                                    height, 0, config.color_format, config.color_type, NULL );
-    opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0 );
-    opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
-                                       ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
-    opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
-    TRACE( "Created texture %u for fullscreen hack.\n", ctx->fs_hack_color_texture );
-
-    if (config.samples)
-    {
-        gl->fs_hack_needs_resolve = TRUE;
-
-        if (!ctx->fs_hack_resolve_fbo)
-        {
-            pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
-            TRACE( "Created resolve FBO %u for fullscreen hack.\n", ctx->fs_hack_resolve_fbo );
-        }
-
-        if (!ctx->fs_hack_color_renderbuffer)
-            pglGenRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
-        pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
-        pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
-                                           config.color_internalformat, width, height );
-        pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER,
-                                    ctx->fs_hack_color_renderbuffer );
-        TRACE( "Created renderbuffer %u and FBO %u for fullscreen hack.\n",
-               ctx->fs_hack_color_renderbuffer, ctx->fs_hack_resolve_fbo );
-        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
-        pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
-                                 ctx->fs_hack_color_texture, 0 );
-        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
-        pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
-    }
-    else
-    {
-        gl->fs_hack_needs_resolve = FALSE;
-        pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
-                                 ctx->fs_hack_color_texture, 0 );
-    }
-
-    if (config.ds_internalformat)
-    {
-        if (config.samples)
-        {
-            if (!ctx->fs_hack_ds_renderbuffer) pglGenRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
-            pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
-            pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
-                                               config.ds_internalformat, width, height );
-            pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
-            if (attribs.depth_size)
-                pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
-                                            GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
-            if (attribs.stencil_size)
-                pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
-                                            GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
-            TRACE( "Created DS renderbuffer %u for fullscreen hack.\n", ctx->fs_hack_ds_renderbuffer );
-        }
-        else
-        {
-            if (!ctx->fs_hack_ds_texture)
-                gen_texture( ctx, &ctx->fs_hack_ds_texture, FSHACK_TEXTURE_DEPTH );
-
-            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_ds_texture );
-            opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.ds_internalformat, width,
-                                            height, 0, config.ds_format, config.ds_type, NULL );
-            opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0 );
-            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
-            if (attribs.depth_size)
-                pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
-                                         GL_TEXTURE_2D, ctx->fs_hack_ds_texture, 0 );
-            if (attribs.stencil_size)
-                pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
-                                         GL_TEXTURE_2D, ctx->fs_hack_ds_texture, 0 );
-            TRACE( "Created DS texture %u for fullscreen hack.\n", ctx->fs_hack_ds_texture );
-        }
-    }
-
-    fs_hack_setup_gamma_shader( ctx, gl );
-
-    if (!ctx->has_been_current) opengl_funcs.gl.p_glViewport( 0, 0, width, height );
-
-    if (!gl->fs_hack_context_set_up)
-    {
-        if (ctx->has_been_current)
-        {
-            GLbitfield mask = GL_COLOR_BUFFER_BIT;
-
-            if (attribs.depth_size) mask |= GL_DEPTH_BUFFER_BIT;
-            if (attribs.stencil_size) mask |= GL_STENCIL_BUFFER_BIT;
-
-            pglBindFramebuffer( GL_READ_FRAMEBUFFER, 0 );
-            pglBlitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, GL_NEAREST );
-        }
-        else
-        {
-            opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
-            opengl_funcs.gl.p_glClearDepth( 1.0 );
-            opengl_funcs.gl.p_glClearStencil( 0 );
-            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );
-        }
-    }
-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
-    pglDrawBuffer( GL_BACK );
-    if (!gl->fs_hack_context_set_up)
-    {
-        opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
-        opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1],
-                                        prev_clear_color[2], prev_clear_color[3] );
-        opengl_funcs.gl.p_glClearDepth( prev_clear_depth );
-        opengl_funcs.gl.p_glClearStencil( prev_clear_stencil );
-    }
-    wglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
-    wglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );
-
-    ctx->setup_for.x = width;
-    ctx->setup_for.y = height;
-    gl->has_scissor_indexed = has_extension( glExtensions, "GL_ARB_viewport_array" );
-    gl->has_clip_control = has_extension( glExtensions, "GL_ARB_clip_control" );
-    gl->has_ati_frag_shader = !ctx->is_core &&
-                              has_extension( glExtensions, "GL_ATI_fragment_shader" );
-    gl->has_fragment_program = !ctx->is_core &&
-                               has_extension( glExtensions, "GL_ARB_fragment_program" );
-    gl->has_vertex_program = !ctx->is_core &&
-                             has_extension( glExtensions, "GL_ARB_vertex_program" );
-    ctx->fs_hack_integer = fs_hack_is_integer();
-    ctx->fs_hack_needs_resolve = gl->fs_hack_needs_resolve;
-    gl->fs_hack_context_set_up = TRUE;
-
-    pglBindBuffer( GL_PIXEL_UNPACK_BUFFER, prev_pixel_pack_buffer );
-}
-
-static void fs_hack_reset_context( struct wgl_context *ctx, struct gl_drawable *gl )
-{
-    TRACE( "Releasing fullscreen hack texture %u and FBO %u\n", ctx->fs_hack_color_texture, ctx->fs_hack_fbo );
-    if (ctx->current_draw_fbo == ctx->fs_hack_fbo)
-    {
-        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
-        ctx->current_draw_fbo = 0;
-    }
-    if (ctx->current_read_fbo == ctx->fs_hack_fbo)
-    {
-        pglBindFramebuffer( GL_READ_FRAMEBUFFER, 0 );
-        ctx->current_read_fbo = 0;
-    }
-    ctx->fs_hack = FALSE;
-    gl->fs_hack_context_set_up = FALSE;
-}
-
-static void fs_hack_update_context( struct wgl_context *ctx, struct gl_drawable *old_gl, struct gl_drawable *new_gl )
-{
-    assert( !!new_gl );
-
-    if (new_gl->fs_hack && (!ctx->fs_hack || new_gl != old_gl || !new_gl->fs_hack_context_set_up))
-        fs_hack_init_context( ctx, new_gl );
-    else if (!new_gl->fs_hack && ctx->fs_hack)
-        fs_hack_reset_context( ctx, new_gl );
+    *onscreen_count = onscreen_size;
+    return size;
 }
 
-static void fs_hack_destroy_context( struct wgl_context *ctx )
+static struct glx_pixel_format *glx_pixel_format_from_format( int format )
 {
-    GLXContext prev_context;
-    GLXDrawable prev_drawable;
-
-    if (!ctx->drawables[0]) return;
-
-    prev_context = pglXGetCurrentContext();
-    prev_drawable = pglXGetCurrentDrawable();
-    pglXMakeCurrent( gdi_display, ctx->drawables[0]->drawable, ctx->ctx );
-
-    pglDeleteBuffers( 1, &ctx->ramp_ubo );
-    pglDeleteProgram( ctx->fs_hack_gamma_pgm );
-    ctx->fs_hack_gamma_pgm = 0;
-
-    if (ctx->fs_hack_ds_renderbuffer) pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
-    if (ctx->fs_hack_color_renderbuffer) pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
-    if (ctx->fs_hack_ds_texture) opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
-    if (ctx->fs_hack_color_texture) opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
-    ctx->fs_hack_color_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
-    ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
-    if (ctx->fs_hack_resolve_fbo) pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
-    if (ctx->fs_hack_fbo) pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
-    ctx->fs_hack_resolve_fbo = ctx->fs_hack_fbo = 0;
-
-    pglXMakeCurrent( gdi_display, prev_drawable, prev_context );
+    assert( format > 0 && format <= nb_pixel_formats );
+    return &pixel_formats[format - 1];
 }
 
-/* Mark any allocated context using the glx drawable 'old' to use 'new' */
-static void mark_drawable_dirty( struct gl_drawable *old, struct gl_drawable *new )
+static void x11drv_surface_destroy( struct opengl_drawable *base )
 {
-    struct wgl_context *ctx;
+    struct gl_drawable *gl = impl_from_opengl_drawable( base );
 
-    pthread_mutex_lock( &context_mutex );
-    LIST_FOR_EACH_ENTRY( ctx, &context_list, struct wgl_context, entry )
-    {
-        if (old == ctx->drawables[0] || old == ctx->new_drawables[0])
-        {
-            release_gl_drawable( ctx->new_drawables[0] );
-            ctx->new_drawables[0] = grab_gl_drawable( new );
-        }
-        if (old == ctx->drawables[1] || old == ctx->new_drawables[1])
-        {
-            release_gl_drawable( ctx->new_drawables[1] );
-            ctx->new_drawables[1] = grab_gl_drawable( new );
-        }
-    }
-    pthread_mutex_unlock( &context_mutex );
-}
-
-/* Given the current context, make sure its drawable is sync'd */
-static inline void sync_context(struct wgl_context *context)
-{
-    BOOL refresh = FALSE;
-    struct gl_drawable *old[2] = { NULL };
+    TRACE( "drawable %s\n", debugstr_opengl_drawable( base ) );
 
-    pthread_mutex_lock( &context_mutex );
-    if (context->new_drawables[0])
-    {
-        old[0] = context->drawables[0];
-        context->drawables[0] = context->new_drawables[0];
-        context->new_drawables[0] = NULL;
-        refresh = TRUE;
-    }
-    if (context->new_drawables[1])
-    {
-        old[1] = context->drawables[1];
-        context->drawables[1] = context->new_drawables[1];
-        context->new_drawables[1] = NULL;
-        refresh = TRUE;
-    }
-    if (refresh)
-    {
-        if (glxRequireVersion(3))
-            pglXMakeContextCurrent(gdi_display, context->drawables[0]->drawable,
-                                   context->drawables[1]->drawable, context->ctx);
-        else
-            pglXMakeCurrent(gdi_display, context->drawables[0]->drawable, context->ctx);
-        fs_hack_update_context( context, old[0], context->drawables[0] );
-        release_gl_drawable( old[0] );
-        release_gl_drawable( old[1] );
-    }
-    pthread_mutex_unlock( &context_mutex );
+    if (gl->drawable) pglXDestroyWindow( gdi_display, gl->drawable );
+    if (gl->colormap) XFreeColormap( gdi_display, gl->colormap );
 }
 
-static BOOL set_swap_interval(GLXDrawable drawable, int interval)
+static BOOL set_swap_interval( struct gl_drawable *gl, int interval )
 {
     BOOL ret = TRUE;
 
+    if (interval < 0 && !has_swap_control_tear) interval = -interval;
+
     switch (swap_control_method)
     {
     case GLX_SWAP_CONTROL_EXT:
         X11DRV_expect_error(gdi_display, GLXErrorHandler, NULL);
-        pglXSwapIntervalEXT(gdi_display, drawable, interval);
+        pglXSwapIntervalEXT( gdi_display, gl->drawable, interval );
         XSync(gdi_display, False);
         ret = !X11DRV_check_error();
         break;
@@ -1802,426 +905,65 @@
     return ret;
 }
 
-static struct gl_drawable *get_gl_drawable( HWND hwnd, HDC hdc )
-{
-    struct gl_drawable *gl;
-
-    pthread_mutex_lock( &context_mutex );
-    if (hwnd && !XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&gl ))
-        gl = grab_gl_drawable( gl );
-    else if (hdc && !XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&gl ))
-        gl = grab_gl_drawable( gl );
-    else
-        gl = NULL;
-    pthread_mutex_unlock( &context_mutex );
-    return gl;
-}
-
-static GLXContext create_glxcontext(Display *display, struct wgl_context *context, GLXContext shareList)
+static GLXContext create_glxcontext( int format, GLXContext share, const int *attribs )
 {
+    struct glx_pixel_format *fmt = glx_pixel_format_from_format( format );
     GLXContext ctx;
 
-    if(context->gl3_context)
-    {
-        if(context->numAttribs)
-            ctx = pglXCreateContextAttribsARB(gdi_display, context->fmt->fbconfig, shareList, GL_TRUE, context->attribList);
-        else
-            ctx = pglXCreateContextAttribsARB(gdi_display, context->fmt->fbconfig, shareList, GL_TRUE, NULL);
-    }
-    else if(context->fmt->visual)
-        ctx = pglXCreateContext(gdi_display, context->fmt->visual, shareList, GL_TRUE);
-    else /* Create a GLX Context for a pbuffer */
-        ctx = pglXCreateNewContext(gdi_display, context->fmt->fbconfig, context->fmt->render_type, shareList, TRUE);
+    if (attribs) ctx = pglXCreateContextAttribsARB( gdi_display, fmt->fbconfig, share, TRUE, attribs );
+    else if (fmt->visual) ctx = pglXCreateContext( gdi_display, fmt->visual, share, TRUE );
+    else ctx = pglXCreateNewContext( gdi_display, fmt->fbconfig, fmt->render_type, share, TRUE );
 
     return ctx;
 }
 
-BOOL enable_fullscreen_hack( HWND hwnd, BOOL check_gamma )
+static BOOL x11drv_surface_create( HWND hwnd, int format, struct opengl_drawable **drawable )
 {
-    static int disable_fshack = -1;
-    if (disable_fshack == -1) {
-        const char *env = getenv("WINE_DISABLE_FULLSCREEN_HACK");
-        disable_fshack = env && atoi(env);
-    }
-
-    if (disable_fshack) return FALSE;
-    if (NtUserGetDpiForWindow( hwnd ) != NtUserGetWinMonitorDpi( hwnd, MDT_RAW_DPI )) return TRUE; /* needs DPI scaling */
-    if (check_gamma && X11DRV_HasWindowManager( "xwayland" ) && gl_renderer && strstr( gl_renderer, "NVIDIA" ))
-    {
-        static int skip_cached = -1;
-        if (skip_cached == -1)
-        {
-            const char *sgi = getenv( "SteamGameId" );
-            skip_cached = sgi && !strcmp( sgi, "582660" );
-        }
-        if (!skip_cached)
-        {
-            /* Force fshack on XWayland / NVidia because drawing to front buffer doesn't get presented there and fshack works
-             * that around as a side effect. */
-            TRACE( "Forcing fshack on xwayland / NVIDIA.\n" );
-            return TRUE;
-        }
-    }
-    return check_gamma && ReadNoFence( &gamma_serial );
-}
-
-static BOOL get_client_rect( HWND hwnd, BOOL raw, RECT *rect )
-{
-    UINT dpi = NtUserGetDpiForWindow( hwnd );
-
-    if (!NtUserGetClientRect( hwnd, rect, dpi )) return FALSE;
-    if (!raw) return TRUE;
-    *rect = map_rect_virt_to_raw_for_monitor( NtUserMonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST ), *rect, dpi );
-    OffsetRect( rect, -rect->left, -rect->top );
-    return TRUE;
-}
-
-/***********************************************************************
- *              create_gl_drawable
- */
-static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct glx_pixel_format *format, BOOL known_child,
-                                               BOOL mutable_pf )
-{
-    static const WCHAR displayW[] = {'D','I','S','P','L','A','Y'};
-    UNICODE_STRING device_str = RTL_CONSTANT_STRING(displayW);
-    struct gl_drawable *gl, *prev;
-    XVisualInfo *visual = format->visual;
+    struct glx_pixel_format *fmt = glx_pixel_format_from_format( format );
+    struct opengl_drawable *previous;
+    struct client_surface *client;
+    struct gl_drawable *gl;
+    Colormap colormap;
+    Window window;
     RECT rect;
-    int width, height;
-    BOOL enable_fshack = enable_fullscreen_hack( hwnd, TRUE );
-
-    if (!get_client_rect( hwnd, enable_fshack, &rect ))
-    {
-        ERR( "get_client_rect failed.\n" );
-        return NULL;
-    }
-    width  = min( max( 1, rect.right ), 65535 );
-    height = min( max( 1, rect.bottom ), 65535 );
-
-    if (!(gl = calloc( 1, sizeof(*gl) ))) return NULL;
-
-    /* Default GLX and WGL swap interval is 1, but in case of glXSwapIntervalSGI
-     * there is no way to query it, so we have to store it here.
-     */
-    gl->swap_interval = 1;
-    gl->refresh_swap_interval = TRUE;
-    gl->format = format;
-    gl->ref = 1;
-    gl->hwnd = hwnd;
-    gl->rect = rect;
-    gl->mutable_pf = mutable_pf;
-
-    if (!needs_offscreen_rendering( hwnd, known_child, TRUE ))
-    {
-        gl->type = DC_GL_WINDOW;
-        gl->colormap = XCreateColormap( gdi_display, get_dummy_parent(), visual->visual,
-                                        (visual->class == PseudoColor || visual->class == GrayScale ||
-                                         visual->class == DirectColor) ? AllocAll : AllocNone );
-        gl->window = create_client_window( hwnd, gl->rect, visual, gl->colormap );
-        if (gl->window)
-        {
-            gl->drawable = pglXCreateWindow( gdi_display, gl->format->fbconfig, gl->window, NULL );
-            gl->hdc_src = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-            set_dc_drawable( gl->hdc_src, gl->window, &gl->rect, IncludeInferiors );
-        }
-        gl->fs_hack = enable_fshack;
-        TRACE( "%p created client %lx drawable %lx\n", hwnd, gl->window, gl->drawable );
-        if (gl->fs_hack) WARN( "Window %p has the fullscreen hack enabled\n", hwnd );
-    }
-#ifdef SONAME_LIBXCOMPOSITE
-    else if(usexcomposite)
-    {
-        unsigned int allow_flip = 0;
-
-        gl->type = DC_GL_CHILD_WIN;
-        gl->colormap = XCreateColormap( gdi_display, get_dummy_parent(), visual->visual,
-                                        (visual->class == PseudoColor || visual->class == GrayScale ||
-                                         visual->class == DirectColor) ? AllocAll : AllocNone );
-        gl->window = create_client_window( hwnd, gl->rect, visual, gl->colormap );
-        gl->fs_hack = enable_fshack;
-        gl->swap_interval = 0;
-        if (gl->window)
-        {
-            struct x11drv_win_data *data;
-
-            gl->drawable = pglXCreateWindow( gdi_display, gl->format->fbconfig, gl->window, NULL );
-            pXCompositeRedirectWindow( gdi_display, gl->window, CompositeRedirectManual );
-            XChangeProperty( gdi_display, gl->window, x11drv_atom(_WINE_ALLOW_FLIP), XA_CARDINAL, 32,
-                             PropModeReplace, (unsigned char *)&allow_flip, sizeof(allow_flip) / 4 );
-            if ((data = get_win_data( hwnd )))
-            {
-                detach_client_window( data, gl->window );
-                release_win_data( data );
-            }
-
-            gl->hdc_dst = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-            gl->hdc_src = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-            set_dc_drawable( gl->hdc_src, gl->window, &gl->rect, IncludeInferiors );
-        }
-
-        TRACE( "%p created child %lx drawable %lx\n", hwnd, gl->window, gl->drawable );
-        if (gl->fs_hack) WARN( "Window %p has the fullscreen hack enabled\n", hwnd );
-    }
-#endif
-    else
-    {
-        static unsigned int once;
-
-        if (!once++)
-            ERR_(winediag)("XComposite is not available, using GLXPixmap hack.\n");
-        WARN("XComposite is not available, using GLXPixmap hack.\n");
-
-        gl->type = DC_GL_PIXMAP_WIN;
-        gl->pixmap = XCreatePixmap( gdi_display, root_window, width, height, visual->depth );
-        if (gl->pixmap)
-        {
-            gl->drawable = pglXCreatePixmap( gdi_display, gl->format->fbconfig, gl->pixmap, NULL );
-            if (!gl->drawable) XFreePixmap( gdi_display, gl->pixmap );
-
-            gl->hdc_dst = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-            gl->hdc_src = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-            set_dc_drawable( gl->hdc_src, gl->pixmap, &gl->rect, IncludeInferiors );
-        }
-    }
-
-    if (!gl->drawable)
-    {
-        free( gl );
-        return NULL;
-    }
-
-    pthread_mutex_lock( &context_mutex );
-    if (!XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&prev ))
-    {
-        gl->swap_interval = prev->swap_interval;
-        release_gl_drawable( prev );
-    }
-    XSaveContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char *)grab_gl_drawable(gl) );
-    pthread_mutex_unlock( &context_mutex );
-    return gl;
-}
 
+    if ((previous = *drawable) && previous->format == format) return TRUE;
+    NtUserGetClientRect( hwnd, &rect, NtUserGetDpiForWindow( hwnd ) );
 
-/***********************************************************************
- *              set_win_format
- */
-static BOOL set_win_format( HWND hwnd, const struct glx_pixel_format *format, BOOL internal )
-{
-    struct gl_drawable *old, *gl;
-
-    if (!format->visual) return FALSE;
-
-    if (!(old = get_gl_drawable( hwnd, 0 )) || old->format != format)
-    {
-        if (!(gl = create_gl_drawable( hwnd, format, FALSE, internal )))
-        {
-            release_gl_drawable( old );
-            return FALSE;
-        }
-
-        TRACE( "created GL drawable %lx for win %p %s\n",
-               gl->drawable, hwnd, debugstr_fbconfig( format->fbconfig ));
-
-        if (old)
-            mark_drawable_dirty( old, gl );
-
-        XFlush( gdi_display );
-        release_gl_drawable( gl );
-    }
-
-    release_gl_drawable( old );
-
-    win32u_set_window_pixel_format( hwnd, pixel_format_index( format ), internal );
-    return TRUE;
-}
-
-
-static BOOL set_pixel_format( HDC hdc, int format, BOOL internal )
-{
-    const struct glx_pixel_format *fmt;
-    int value;
-    HWND hwnd = NtUserWindowFromDC( hdc );
-    int prev;
-
-    TRACE("(%p,%d)\n", hdc, format);
+    colormap = XCreateColormap( gdi_display, get_dummy_parent(), fmt->visual->visual,
+                                (fmt->visual->class == PseudoColor || fmt->visual->class == GrayScale ||
+                                 fmt->visual->class == DirectColor) ? AllocAll : AllocNone );
+    if (!colormap) return FALSE;
+
+    if (!(window = x11drv_client_surface_create( hwnd, fmt->visual, colormap, &client ))) goto failed;
+    gl = opengl_drawable_create( sizeof(*gl), &x11drv_surface_funcs, format, client );
+    client_surface_release( client );
+    if (!gl) goto failed;
+    gl->colormap = colormap;
 
-    if (!hwnd || hwnd == NtUserGetDesktopWindow())
+    if (!(gl->drawable = pglXCreateWindow( gdi_display, fmt->fbconfig, window, NULL )))
     {
-        WARN( "not a valid window DC %p/%p\n", hdc, hwnd );
+        opengl_drawable_release( &gl->base );
         return FALSE;
     }
 
-    fmt = get_pixel_format(gdi_display, format, FALSE /* Offscreen */);
-    if (!fmt)
-    {
-        ERR( "Invalid format %d\n", format );
-        return FALSE;
-    }
-
-    pglXGetFBConfigAttrib(gdi_display, fmt->fbconfig, GLX_DRAWABLE_TYPE, &value);
-    if (!(value & GLX_WINDOW_BIT))
-    {
-        WARN( "Pixel format %d is not compatible for window rendering\n", format );
-        return FALSE;
-    }
-
-    /* Even for internal pixel format fail setting it if the app has already set a
-     * different pixel format. Let wined3d create a backup GL context instead.
-     * Switching pixel format involves drawable recreation and is much more expensive
-     * than blitting from backup context. */
-    if ((prev = win32u_get_window_pixel_format( hwnd )))
-        return prev == format;
-
-    return set_win_format( hwnd, fmt, internal );
-}
-
-static void update_gl_drawable_size( struct gl_drawable *gl )
-{
-    struct gl_drawable *new_gl;
-    XWindowChanges changes;
-    RECT rect;
-
-    if (!get_client_rect( gl->hwnd, gl->fs_hack, &rect ))
-    {
-        WARN( "get_client_rect failed.\n" );
-        return;
-    }
-
-    if (EqualRect( &rect, &gl->rect )) return;
-
-    changes.width  = min( max( 1, rect.right ), 65535 );
-    changes.height = min( max( 1, rect.bottom ), 65535 );
-
-    switch (gl->type)
-    {
-    case DC_GL_WINDOW:
-    case DC_GL_CHILD_WIN:
-        gl->rect = rect;
-        XConfigureWindow( gdi_display, gl->window, CWWidth | CWHeight, &changes );
-        set_dc_drawable( gl->hdc_src, gl->window, &gl->rect, IncludeInferiors );
-        break;
-    case DC_GL_PIXMAP_WIN:
-        new_gl = create_gl_drawable( gl->hwnd, gl->format, TRUE, gl->mutable_pf );
-        mark_drawable_dirty( gl, new_gl );
-        release_gl_drawable( new_gl );
-    default:
-        break;
-    }
-}
-
-/***********************************************************************
- *              sync_gl_drawable
- */
-void sync_gl_drawable( HWND hwnd, BOOL known_child )
-{
-    struct gl_drawable *old, *new;
-    BOOL is_offscreen, enable_fshack;
-
-    if (!(old = get_gl_drawable( hwnd, 0 ))) return;
-
-    switch (old->type)
-    {
-    case DC_GL_WINDOW:
-    case DC_GL_CHILD_WIN:
-        is_offscreen = old->type == DC_GL_CHILD_WIN;
-        enable_fshack = enable_fullscreen_hack( hwnd, TRUE );
-        if (enable_fshack == old->fs_hack && is_offscreen == needs_offscreen_rendering( hwnd, known_child, TRUE ))
-        {
-            update_gl_drawable_size( old );
-            break;
-        }
-        /* fall through */
-    case DC_GL_PIXMAP_WIN:
-        if (!(new = create_gl_drawable( hwnd, old->format, known_child, old->mutable_pf ))) break;
-        mark_drawable_dirty( old, new );
-        XFlush( gdi_display );
-        TRACE( "Recreated GL drawable %lx to replace %lx\n", new->drawable, old->drawable );
-        release_gl_drawable( new );
-        break;
-    default:
-        break;
-    }
-    release_gl_drawable( old );
-}
-
-
-/***********************************************************************
- *              set_gl_drawable_parent
- */
-void set_gl_drawable_parent( HWND hwnd, HWND parent )
-{
-    struct gl_drawable *old, *new;
-
-    if (!(old = get_gl_drawable( hwnd, 0 ))) return;
-
-    TRACE( "setting drawable %lx parent %p\n", old->drawable, parent );
-
-    switch (old->type)
-    {
-    case DC_GL_WINDOW:
-        break;
-    case DC_GL_CHILD_WIN:
-    case DC_GL_PIXMAP_WIN:
-        if (parent == NtUserGetDesktopWindow()) break;
-        /* fall through */
-    default:
-        release_gl_drawable( old );
-        return;
-    }
-
-    if ((new = create_gl_drawable( hwnd, old->format, FALSE, old->mutable_pf )))
-    {
-        mark_drawable_dirty( old, new );
-        release_gl_drawable( new );
-    }
-    else
-    {
-        destroy_gl_drawable( hwnd );
-        win32u_set_window_pixel_format( hwnd, 0, FALSE );
-    }
-    release_gl_drawable( old );
-}
-
+    TRACE( "Created drawable %s with client window %lx\n", debugstr_opengl_drawable( &gl->base ), window );
+    XFlush( gdi_display );
 
-/***********************************************************************
- *              destroy_gl_drawable
- */
-void destroy_gl_drawable( HWND hwnd )
-{
-    struct gl_drawable *gl;
+    if (previous) opengl_drawable_release( previous );
+    *drawable = &gl->base;
+    return TRUE;
 
-    pthread_mutex_lock( &context_mutex );
-    if (!XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&gl ))
-    {
-        XDeleteContext( gdi_display, (XID)hwnd, gl_hwnd_context );
-        release_gl_drawable( gl );
-    }
-    pthread_mutex_unlock( &context_mutex );
+failed:
+    XFreeColormap( gdi_display, colormap );
+    return FALSE;
 }
 
-
-/**
- * describe_pixel_format
- *
- * Get the wgl_pixel_format description for the given id
- */
-static int describe_pixel_format( int iPixelFormat, struct wgl_pixel_format *pf )
+static BOOL x11drv_describe_pixel_format( int format, struct wgl_pixel_format *pf )
 {
     int value, drawable_type = 0, render_type = 0;
+    struct glx_pixel_format *fmt = glx_pixel_format_from_format( format );
     int rb, gb, bb, ab;
-    const struct glx_pixel_format *fmt;
-
-    if (!has_opengl()) return 0;
-
-    /* Look for the iPixelFormat in our list of supported formats. If it is
-     * supported we get the index in the FBConfig table and the number of
-     * supported formats back */
-    fmt = get_pixel_format( gdi_display, iPixelFormat, TRUE /* Offscreen */);
-    if (!fmt)
-    {
-        WARN( "unexpected format %d\n", iPixelFormat );
-        return 0;
-    }
 
     /* If we can't get basic information, there is no point continuing */
     if (pglXGetFBConfigAttrib( gdi_display, fmt->fbconfig, GLX_DRAWABLE_TYPE, &drawable_type )) return 0;
@@ -2393,8 +1135,7 @@
     if (pglXGetFBConfigAttrib( gdi_display, fmt->fbconfig, GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, &value )) value = -1;
     pf->framebuffer_srgb_capable = value;
 
-    pf->bind_to_texture_rgb = pf->bind_to_texture_rgba =
-        use_render_texture_emulation && render_type != GLX_COLOR_INDEX_BIT && (drawable_type & GLX_PBUFFER_BIT);
+    pf->bind_to_texture_rgb = pf->bind_to_texture_rgba = render_type != GLX_COLOR_INDEX_BIT && (drawable_type & GLX_PBUFFER_BIT);
     pf->bind_to_texture_rectangle_rgb = pf->bind_to_texture_rectangle_rgba = GL_FALSE;
 
     if (pglXGetFBConfigAttrib( gdi_display, fmt->fbconfig, GLX_FLOAT_COMPONENTS_NV, &value )) value = -1;
@@ -2402,1684 +1143,183 @@
 
     if (TRACE_ON(wgl)) dump_PIXELFORMATDESCRIPTOR( &pf->pfd );
 
-    return nb_onscreen_formats;
-}
-
-
-/***********************************************************************
- *		glxdrv_wglGetPixelFormat
- */
-static int glxdrv_wglGetPixelFormat( HDC hdc )
-{
-    struct gl_drawable *gl;
-    int ret = 0;
-    HWND hwnd;
-
-    if ((hwnd = NtUserWindowFromDC( hdc )))
-        return win32u_get_window_pixel_format( hwnd );
-
-    if ((gl = get_gl_drawable( NULL, hdc )))
-    {
-        ret = pixel_format_index( gl->format );
-        /* Offscreen formats can't be used with traditional WGL calls.
-         * As has been verified on Windows GetPixelFormat doesn't fail but returns iPixelFormat=1. */
-        if (!is_onscreen_pixel_format( ret )) ret = 1;
-        release_gl_drawable( gl );
-    }
-    TRACE( "%p -> %d\n", hdc, ret );
-    return ret;
-}
-
-/***********************************************************************
- *		glxdrv_wglSetPixelFormat
- */
-static BOOL glxdrv_wglSetPixelFormat( HDC hdc, int iPixelFormat, const PIXELFORMATDESCRIPTOR *ppfd )
-{
-    return set_pixel_format(hdc, iPixelFormat, FALSE);
-}
-
-/***********************************************************************
- *		glxdrv_wglCopyContext
- */
-static BOOL glxdrv_wglCopyContext(struct wgl_context *src, struct wgl_context *dst, UINT mask)
-{
-    TRACE("%p -> %p mask %#x\n", src, dst, mask);
-
-    X11DRV_expect_error( gdi_display, GLXErrorHandler, NULL );
-    pglXCopyContext( gdi_display, src->ctx, dst->ctx, mask );
-    XSync( gdi_display, False );
-    if (X11DRV_check_error())
-    {
-        static unsigned int once;
-
-        if (!once++)
-        {
-            ERR("glXCopyContext failed. glXCopyContext() for direct rendering contexts not "
-                "implemented in the host graphics driver?\n");
-        }
-        return FALSE;
-    }
-
     return TRUE;
 }
 
-static int share_all_contexts = -1;
-
-static GLXContext get_common_context( GLXFBConfig fbconfig )
-{
-    static GLXContext common_context;
-
-    if (share_all_contexts == -1)
-    {
-        const char *e = getenv( "WINE_SHARE_ALL_GL_CONTEXTS" );
-        const char *sgi = getenv( "SteamGameId" );
-
-        if (e)
-            share_all_contexts = !!atoi(e);
-        else
-        {
-            share_all_contexts = sgi && (!strcmp( sgi, "232050" ) || !strcmp( sgi, "333420" ));
-            if (!share_all_contexts)
-            {
-                static const WCHAR ea_desktop[] = u"EADesktop.exe";
-                UNICODE_STRING *name;
-                DWORD len, name_len;
-
-                name = &NtCurrentTeb()->Peb->ProcessParameters->ImagePathName;
-                len = name->Length / sizeof(WCHAR);
-                if (len && !name->Buffer[len]) --len;
-                name_len = sizeof(ea_desktop) / sizeof(*ea_desktop) - 1;
-
-                if (len >= name_len)
-                    share_all_contexts = !memcmp( name->Buffer + len - name_len, ea_desktop,
-                                                  name_len * sizeof(*ea_desktop) );
-            }
-        }
-        if (share_all_contexts)
-            FIXME( "HACK: sharing all the GL contexts.\n" );
-    }
-
-    if (!share_all_contexts) return NULL;
-
-    if (!common_context)
-        common_context = pglXCreateNewContext( gdi_display, fbconfig, GLX_RGBA_TYPE, NULL, TRUE );
-
-    return common_context;
-}
-
-/***********************************************************************
- *		glxdrv_wglCreateContext
- */
-static struct wgl_context *glxdrv_wglCreateContext( HDC hdc )
-{
-    struct wgl_context *ret;
-    struct gl_drawable *gl;
-
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
-    {
-        RtlSetLastWin32Error( ERROR_INVALID_PIXEL_FORMAT );
-        return NULL;
-    }
-
-    if ((ret = calloc( 1, sizeof(*ret) )))
-    {
-        ret->hdc = hdc;
-        ret->fmt = gl->format;
-        ret->ctx = create_glxcontext(gdi_display, ret, get_common_context( ret->fmt->fbconfig ));
-        pthread_mutex_lock( &context_mutex );
-        list_add_head( &context_list, &ret->entry );
-        pthread_mutex_unlock( &context_mutex );
-    }
-    release_gl_drawable( gl );
-    TRACE( "%p -> %p\n", hdc, ret );
-    return ret;
-}
-
 /***********************************************************************
  *		glxdrv_wglDeleteContext
  */
-static BOOL glxdrv_wglDeleteContext(struct wgl_context *ctx)
+static BOOL x11drv_context_destroy( void *context )
 {
-    struct wgl_pbuffer *pb;
-
-    TRACE("(%p)\n", ctx);
-
-    fs_hack_destroy_context( ctx );
-
-    pthread_mutex_lock( &context_mutex );
-    list_remove( &ctx->entry );
-    LIST_FOR_EACH_ENTRY( pb, &pbuffer_list, struct wgl_pbuffer, entry )
-    {
-        if (pb->prev_context == ctx->ctx) {
-            pglXDestroyContext(gdi_display, pb->tmp_context);
-            pb->prev_context = pb->tmp_context = NULL;
-        }
-    }
-    pthread_mutex_unlock( &context_mutex );
-
-    if (ctx->ctx) pglXDestroyContext( gdi_display, ctx->ctx );
-    release_gl_drawable( ctx->drawables[0] );
-    release_gl_drawable( ctx->drawables[1] );
-    release_gl_drawable( ctx->new_drawables[0] );
-    release_gl_drawable( ctx->new_drawables[1] );
-    free( ctx );
+    TRACE("(%p)\n", context);
+    pglXDestroyContext( gdi_display, context );
     return TRUE;
 }
 
-/***********************************************************************
- *		glxdrv_wglGetProcAddress
- */
-static PROC glxdrv_wglGetProcAddress(LPCSTR lpszProc)
-{
-    if (!strncmp(lpszProc, "wgl", 3)) return NULL;
-    if (!strcmp( lpszProc, "glBindFramebuffer" )) return (PROC)(void *)wglBindFramebuffer;
-    if (!strcmp( lpszProc, "glBindFramebufferEXT" )) return (PROC)(void *)wglBindFramebufferEXT;
-    if (!strcmp( lpszProc, "glFramebufferTexture2D" )) return (PROC)(void *)wglFramebufferTexture2D;
-    return pglXGetProcAddressARB((const GLubyte*)lpszProc);
-}
-
-static void set_context_drawables( struct wgl_context *ctx, struct gl_drawable *draw,
-                                   struct gl_drawable *read )
+static void *x11drv_get_proc_address( const char *name )
 {
-    struct gl_drawable *prev[4];
-    int i;
-
-    prev[0] = ctx->drawables[0];
-    prev[1] = ctx->drawables[1];
-    prev[2] = ctx->new_drawables[0];
-    prev[3] = ctx->new_drawables[1];
-    ctx->drawables[0] = grab_gl_drawable( draw );
-    ctx->drawables[1] = read ? grab_gl_drawable( read ) : NULL;
-    ctx->new_drawables[0] = ctx->new_drawables[1] = NULL;
-    fs_hack_update_context( ctx, prev[0], ctx->drawables[0] );
-    for (i = 0; i < 4; i++) release_gl_drawable( prev[i] );
+    void *ptr;
+    if ((ptr = dlsym( opengl_handle, name ))) return ptr;
+    return pglXGetProcAddressARB( (const GLubyte *)name );
 }
 
-/***********************************************************************
- *		glxdrv_wglMakeCurrent
- */
-static BOOL glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
+static BOOL x11drv_make_current( struct opengl_drawable *draw_base, struct opengl_drawable *read_base, void *context )
 {
-    BOOL ret = FALSE;
-    struct gl_drawable *gl;
-
-    TRACE("(%p,%p)\n", hdc, ctx);
-
-    if (!ctx)
-    {
-        pglXMakeCurrent(gdi_display, None, NULL);
-        NtCurrentTeb()->glContext = NULL;
-        return TRUE;
-    }
-
-    if ((gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
-    {
-        if (ctx->fmt != gl->format)
-        {
-            WARN( "mismatched pixel format hdc %p %p ctx %p %p\n", hdc, gl->format, ctx, ctx->fmt );
-            RtlSetLastWin32Error( ERROR_INVALID_PIXEL_FORMAT );
-            goto done;
-        }
-
-        TRACE("hdc %p drawable %lx fmt %p ctx %p %s\n", hdc, gl->drawable, gl->format, ctx->ctx,
-              debugstr_fbconfig( gl->format->fbconfig ));
-
-        pthread_mutex_lock( &context_mutex );
-        ret = pglXMakeCurrent(gdi_display, gl->drawable, ctx->ctx);
-        if (ret)
-        {
-            NtCurrentTeb()->glContext = ctx;
-            ctx->hdc = hdc;
-            set_context_drawables( ctx, gl, gl );
-            ctx->has_been_current = TRUE;
-            pthread_mutex_unlock( &context_mutex );
-            goto done;
-        }
-        pthread_mutex_unlock( &context_mutex );
-    }
-    RtlSetLastWin32Error( ERROR_INVALID_HANDLE );
-
-done:
-    release_gl_drawable( gl );
-    TRACE( "%p,%p returning %d\n", hdc, ctx, ret );
-    return ret;
-}
-
-static void wglFramebufferTexture2D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
-{
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-
-    TRACE( "target %#x, attachment %#x, textarget %#x, texture %u, level %u.\n", target, attachment,
-           textarget, texture, level );
-
-    if (ctx->fs_hack)
-    {
-        /* glFramebufferTexture2D should fail for default framebuffer 0.
-         * Let it fail and relay appropriate error instead of breaking fs_hack FBO. */
-        if (ctx->current_read_fbo == ctx->fs_hack_fbo) pglBindFramebuffer( GL_READ_FRAMEBUFFER, 0 );
-        if (ctx->current_draw_fbo == ctx->fs_hack_fbo) pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
-    }
-    pglFramebufferTexture2D( target, attachment, textarget, texture, level );
-    if (ctx->fs_hack)
-    {
-        if (ctx->current_read_fbo == ctx->fs_hack_fbo)
-            pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );
-        if (ctx->current_draw_fbo == ctx->fs_hack_fbo)
-            pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
-    }
-}
-
-static void wglBindFramebuffer( GLenum target, GLuint framebuffer )
-{
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-
-    TRACE( "target %#x, framebuffer %u\n", target, framebuffer );
-    if (ctx->fs_hack && !framebuffer) framebuffer = ctx->fs_hack_fbo;
-
-    if (target == GL_DRAW_FRAMEBUFFER || target == GL_FRAMEBUFFER) ctx->current_draw_fbo = framebuffer;
-    if (target == GL_READ_FRAMEBUFFER || target == GL_FRAMEBUFFER) ctx->current_read_fbo = framebuffer;
-
-    pglBindFramebuffer( target, framebuffer );
-}
-
-static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer )
-{
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-
-    TRACE( "target %#x, framebuffer %u\n", target, framebuffer );
-    if (ctx->fs_hack && !framebuffer) framebuffer = ctx->fs_hack_fbo;
-
-    if (target == GL_DRAW_FRAMEBUFFER || target == GL_FRAMEBUFFER) ctx->current_draw_fbo = framebuffer;
-    if (target == GL_READ_FRAMEBUFFER || target == GL_FRAMEBUFFER) ctx->current_read_fbo = framebuffer;
-
-    pglBindFramebufferEXT( target, framebuffer );
-}
-
-static void wglDrawBuffer( GLenum buffer )
-{
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-
-    TRACE( "buffer %#x.\n", buffer );
-
-    if (!ctx->current_draw_fbo || (ctx->fs_hack && ctx->current_draw_fbo == ctx->fs_hack_fbo))
-        ctx->drawing_to_front = (buffer == GL_FRONT || buffer == GL_FRONT_AND_BACK);
-
-    if (ctx->fs_hack && ctx->current_draw_fbo == ctx->fs_hack_fbo)
-    {
-        TRACE( "Overriding %#x with GL_COLOR_ATTACHMENT0\n", buffer );
-        buffer = GL_COLOR_ATTACHMENT0;
-    }
-    pglDrawBuffer( buffer );
-}
-
-static void wglReadBuffer( GLenum buffer )
-{
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-
-    if (ctx->fs_hack && ctx->current_read_fbo == ctx->fs_hack_fbo)
-    {
-        TRACE( "Overriding %#x with GL_COLOR_ATTACHMENT0\n", buffer );
-        buffer = GL_COLOR_ATTACHMENT0;
-    }
-    pglReadBuffer( buffer );
-}
-
-static BOOL resolve_fs_hack_fbo( GLuint *old_read_fbo )
-{
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-    GLuint old_draw_fbo;
-    unsigned int cx, cy;
-    RECT user_rect;
-    HWND hwnd;
-
-    if (!ctx || !ctx->fs_hack || !ctx->fs_hack_needs_resolve) return FALSE;
-    if (!ctx->fs_hack_needs_resolve) return FALSE;
-    if (ctx->current_read_fbo != ctx->fs_hack_fbo) return FALSE;
-    if (!(hwnd = NtUserWindowFromDC( ctx->hdc ))) return FALSE;
-
-    NtUserGetClientRect( hwnd, &user_rect, NtUserGetDpiForWindow( hwnd ) );
-    cx = user_rect.right - user_rect.left;
-    cy = user_rect.bottom - user_rect.top;
-
-    TRACE( "resolving fbo, %ux%u.\n", cx, cy );
-
-    opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)old_read_fbo );
-    opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&old_draw_fbo );
-
-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
-    pglBlitFramebuffer( 0, 0, cx, cy, 0, 0, cx, cy, GL_COLOR_BUFFER_BIT, GL_NEAREST );
-    pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, old_draw_fbo );
-
-    return TRUE;
-}
-
-static void wglCopyTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
-{
-    GLuint old_read_fbo;
-    BOOL restore;
-
-    TRACE( "target %#x, level %d, offset %dx%d, origin %dx%d, size %dx%d.\n",
-            target, level, xoffset, yoffset, x, y, width, height );
-
-    restore = resolve_fs_hack_fbo( &old_read_fbo );
-    pglCopyTexSubImage2D( target, level, xoffset, yoffset, x, y, width, height );
-    if (restore) pglBindFramebuffer( GL_READ_FRAMEBUFFER, old_read_fbo );
-}
-
-static void wglCopyTexImage2D( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
-{
-    GLuint old_read_fbo;
-    BOOL restore;
-
-    TRACE( "target %#x, level %d, internalformat %#x, origin %dx%d, size %dx%d, border %d.\n",
-            target, level, internalformat, x, y, width, height, border );
-
-    restore = resolve_fs_hack_fbo( &old_read_fbo );
-    pglCopyTexImage2D( target, level, internalformat, x, y, width, height, border );
-    if (restore) pglBindFramebuffer( GL_READ_FRAMEBUFFER, old_read_fbo );
-}
-
-static void wglReadPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)
-{
-    GLuint old_read_fbo;
-    BOOL restore;
-
-    TRACE( "origin %dx%d, size %dx%d, format %#x, type %#x, data %p.\n", x, y, width, height, format, type, data );
-
-    restore = resolve_fs_hack_fbo( &old_read_fbo );
-    pglReadPixels( x, y, width, height, format, type, data );
-    if (restore) pglBindFramebuffer( GL_READ_FRAMEBUFFER, old_read_fbo );
-}
-
-struct fs_hack_gl_state
-{
-    GLuint draw_fbo;
-    GLuint read_fbo;
-    GLuint program;
-    GLuint bound_texture;
-    GLint active_texture;
-    GLint clip_origin, clip_depth_mode;
-    GLuint ubo;
-    GLint64 ubo_size, ubo_start;
-    GLint viewporti[4];
-    GLfloat viewportf[4];
-    float clear_color[4];
-    GLboolean scissor_test, cull_face, blend, alpha_test, depth_test, stencil_test;
-    GLboolean arb_frag, arb_vert, ati_frag, fb_srgb;
-    GLboolean clip_distance[8];
-    GLboolean color_mask[4];
-    GLuint sampler;
-};
-
-#define SET 0
-#define RESET 1
-
-static void fs_hack_handle_enable_switch( int mode, GLenum cap, GLboolean *b, BOOL new )
-{
-    if (mode == SET)
-    {
-        *b = opengl_funcs.gl.p_glIsEnabled( cap );
-        if (new) opengl_funcs.gl.p_glEnable( cap );
-        else opengl_funcs.gl.p_glDisable( cap );
-    }
-    else
-    {
-        if (*b) opengl_funcs.gl.p_glEnable( cap );
-        else opengl_funcs.gl.p_glDisable( cap );
-    }
-}
-
-static void fs_hack_handle_fbo_state( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                      struct fs_hack_gl_state *state )
-{
-    if (mode == SET)
-    {
-        opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&state->draw_fbo );
-        opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&state->read_fbo );
-        TRACE( "Previous draw FBO %u, read FBO %u\n", state->draw_fbo, state->read_fbo );
-    }
-    else
-    {
-        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, state->draw_fbo );
-        pglBindFramebuffer( GL_READ_FRAMEBUFFER, state->read_fbo );
-    }
-}
-
-static void fs_hack_handle_clip_control( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                         struct fs_hack_gl_state *state )
-{
-    if (!gl->has_clip_control) return;
-
-    if (mode == SET)
-    {
-        opengl_funcs.gl.p_glGetIntegerv( GL_CLIP_ORIGIN, (GLint *)&state->clip_origin );
-        opengl_funcs.gl.p_glGetIntegerv( GL_CLIP_DEPTH_MODE, (GLint *)&state->clip_depth_mode );
-
-        pglClipControl( GL_LOWER_LEFT, GL_NEGATIVE_ONE_TO_ONE );
-    }
-    else
-    {
-        pglClipControl( state->clip_origin, state->clip_depth_mode );
-    }
-}
-
-static void fs_hack_handle_shaders( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                    struct fs_hack_gl_state *state )
-{
-    if (gl->has_fragment_program)
-        fs_hack_handle_enable_switch( mode, GL_FRAGMENT_PROGRAM_ARB, &state->arb_frag, FALSE );
-    if (gl->has_vertex_program)
-        fs_hack_handle_enable_switch( mode, GL_VERTEX_PROGRAM_ARB, &state->arb_vert, FALSE );
-    fs_hack_handle_enable_switch( mode, GL_FRAMEBUFFER_SRGB, &state->fb_srgb, FALSE );
-
-    if (gl->has_ati_frag_shader)
-        fs_hack_handle_enable_switch( mode, GL_FRAGMENT_SHADER_ATI, &state->ati_frag, FALSE );
-
-    if (mode == SET)
-    {
-        opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&state->program );
-
-        pglGetIntegeri_v( GL_UNIFORM_BUFFER_BINDING, 0, (GLint *)&state->ubo );
-        pglGetInteger64i_v( GL_UNIFORM_BUFFER_START, 0, &state->ubo_start );
-        pglGetInteger64i_v( GL_UNIFORM_BUFFER_SIZE, 0, &state->ubo_size );
-
-        opengl_funcs.gl.p_glGetIntegerv( GL_ACTIVE_TEXTURE, &state->active_texture );
-        pglActiveTexture( GL_TEXTURE0 );
-        opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&state->bound_texture );
-        pglGetIntegeri_v( GL_SAMPLER_BINDING, 0, (GLint *)&state->sampler );
-
-        pglBindBufferBase( GL_UNIFORM_BUFFER, 0, ctx->ramp_ubo );
-
-        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
-        pglBindSampler( 0, 0 );
-
-        pglUseProgram( ctx->fs_hack_gamma_pgm );
-    }
-    else
-    {
-        pglUseProgram( state->program );
-
-        pglBindSampler( 0, state->sampler );
-
-        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, state->bound_texture );
-        pglActiveTexture( state->active_texture );
-
-        pglBindBufferRange( GL_UNIFORM_BUFFER, 0, state->ubo, state->ubo_start, state->ubo_size );
-    }
-}
-
-static void fs_hack_handle_viewport( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                     struct fs_hack_gl_state *state )
-{
-    if (mode == SET)
-    {
-        if (gl->has_scissor_indexed)
-        {
-            pglGetFloati_v( GL_VIEWPORT, 0, state->viewportf );
-        }
-        else
-        {
-            opengl_funcs.gl.p_glGetIntegerv( GL_VIEWPORT, state->viewporti );
-        }
-    }
-    else
-    {
-        if (gl->has_scissor_indexed)
-        {
-            pglViewportIndexedfv( 0, state->viewportf );
-        }
-        else
-        {
-            opengl_funcs.gl.p_glViewport( state->viewporti[0], state->viewporti[1],
-                                          state->viewporti[2], state->viewporti[3] );
-        }
-    }
-}
-
-static void fs_hack_handle_clear_color( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                        struct fs_hack_gl_state *state )
-{
-    if (mode == SET)
-    {
-        opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, state->clear_color );
-        opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
-    }
-    else
-    {
-        opengl_funcs.gl.p_glClearColor( state->clear_color[0], state->clear_color[1],
-                                        state->clear_color[2], state->clear_color[3] );
-    }
-}
-
-static void fs_hack_handle_clip_distance( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                          struct fs_hack_gl_state *state )
-{
-    unsigned int i;
-    if (mode == SET)
-    {
-        for (i = 0; i < ARRAY_SIZE(state->clip_distance); ++i)
-        {
-            state->clip_distance[i] = opengl_funcs.gl.p_glIsEnabled( GL_CLIP_DISTANCE0 + i );
-            opengl_funcs.gl.p_glDisable( GL_CLIP_DISTANCE0 + i );
-        }
-    }
-    else
-    {
-        for (i = 0; i < ARRAY_SIZE(state->clip_distance); ++i)
-        {
-            if (state->clip_distance[i]) opengl_funcs.gl.p_glEnable( GL_CLIP_DISTANCE0 + i );
-        }
-    }
-}
-
-static void fs_hack_handle_color_mask( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                       struct fs_hack_gl_state *state )
-{
-    if (mode == SET)
-    {
-        pglGetBooleani_v( GL_COLOR_WRITEMASK, 0, state->color_mask );
-
-        pglColorMaski( 0, GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );
-    }
-    else
-    {
-        pglColorMaski( 0, state->color_mask[0], state->color_mask[1], state->color_mask[2], state->color_mask[3] );
-    }
-}
-
-static void fs_hack_handle_scissor( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                    struct fs_hack_gl_state *state )
-{
-    fs_hack_handle_enable_switch( mode, GL_SCISSOR_TEST, &state->scissor_test, FALSE );
-}
-
-static void fs_hack_handle_cull_face( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                      struct fs_hack_gl_state *state )
-{
-    fs_hack_handle_enable_switch( mode, GL_CULL_FACE, &state->cull_face, FALSE );
-}
-
-static void fs_hack_handle_blend( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                  struct fs_hack_gl_state *state )
-{
-    fs_hack_handle_enable_switch( mode, GL_BLEND, &state->blend, FALSE );
-}
-
-static void fs_hack_handle_alpha_test( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                       struct fs_hack_gl_state *state )
-{
-    if (ctx->is_core) return;
-
-    fs_hack_handle_enable_switch( mode, GL_ALPHA_TEST, &state->alpha_test, FALSE );
-}
-
-static void fs_hack_handle_ds_test( int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                                    struct fs_hack_gl_state *state )
-{
-    fs_hack_handle_enable_switch( mode, GL_DEPTH_TEST, &state->depth_test, FALSE );
-    fs_hack_handle_enable_switch( mode, GL_STENCIL_TEST, &state->stencil_test, FALSE );
-}
-
-static BOOL fs_hack_direct_front_blit(void)
-{
-    static int cached = -1;
-
-    if (cached == -1)
-    {
-        const char *sgi = getenv( "SteamGameId" );
-
-        cached = sgi && !strcmp( sgi, "500810" );
-    }
-
-    return cached;
-}
-
-static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer )
-{
-    static const struct
-    {
-        void (*state_handler)(int mode, struct gl_drawable *gl, struct wgl_context *ctx,
-                struct fs_hack_gl_state *state);
-    }
-    general_state_handlers[] =
-    {
-        {fs_hack_handle_fbo_state},
-        {fs_hack_handle_scissor},
-        {fs_hack_handle_clear_color},
-    },
-    draw_state_handlers[] =
-    {
-        {fs_hack_handle_clip_control},
-        {fs_hack_handle_shaders},
-        {fs_hack_handle_viewport},
-        {fs_hack_handle_cull_face},
-        {fs_hack_handle_clip_distance},
-        {fs_hack_handle_color_mask},
-        {fs_hack_handle_blend},
-        {fs_hack_handle_alpha_test},
-        {fs_hack_handle_ds_test},
-    };
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-    struct fs_hack_gl_state state;
-    RECT src, dst;
-    const float *gamma_ramp;
-    LONG gamma_serial = 0;
-    unsigned int i;
-
-    if (!ctx)
-    {
-        WARN( "NULL ctx.\n" );
-        return;
-    }
-
-    NtUserGetClientRect( gl->hwnd, &src, NtUserGetDpiForWindow( gl->hwnd ) );
-    dst = gl->rect;
-
-    TRACE( "Stretching from FBO %u %s to %s\n", ctx->fs_hack_fbo, wine_dbgstr_rect( &src ), wine_dbgstr_rect( &dst ) );
-
-    if (ctx->setup_for.x != src.right || ctx->setup_for.y != src.bottom) fs_hack_init_context( ctx, gl );
-
-    gamma_ramp = fs_hack_get_current_gamma_ramp( &gamma_serial );
-
-    /* Can't stretch blit with multisampled renderbuffers */
-    if (gl->fs_hack_needs_resolve && !gamma_ramp)
-    {
-        gamma_ramp = fs_hack_get_default_gamma_ramp();
-        gamma_serial = 0;
-    }
-
-    for (i = 0; i < ARRAY_SIZE(general_state_handlers); i++)
-        general_state_handlers[i].state_handler( SET, gl, ctx, &state );
-
-    if (gamma_ramp)
-    {
-        for (i = 0; i < ARRAY_SIZE(draw_state_handlers); i++)
-            draw_state_handlers[i].state_handler( SET, gl, ctx, &state );
-
-        if (gl->has_scissor_indexed) pglViewportIndexedf( 0, 0, 0, dst.right, dst.bottom );
-        else opengl_funcs.gl.p_glViewport( 0, 0, dst.right, dst.bottom );
-    }
-
-    pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );
-
-    if (gl->fs_hack_needs_resolve)
-    {
-        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
-        pglBlitFramebuffer( 0, 0, src.right, src.bottom, 0, 0, src.right, src.bottom,
-                            GL_COLOR_BUFFER_BIT, GL_NEAREST );
-        pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
-    }
-
-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
-
-    if (draw_buffer == GL_FRONT && fs_hack_direct_front_blit()) pglDrawBuffer( GL_FRONT );
-    else                                                        pglDrawBuffer( GL_BACK );
-
-    opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
-
-    if (gamma_ramp)
-    {
-        if (gamma_serial != gl->last_gamma_serial)
-        {
-            TRACE( "updating gamma ramp (serial: %u)\n", (int)gamma_serial );
-
-            pglBufferData( GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, gamma_ramp, GL_DYNAMIC_DRAW );
-
-            gl->last_gamma_serial = gamma_serial;
-        }
-
-        pglDrawArrays( GL_TRIANGLE_STRIP, 0, 4 );
-    }
-    else
-    {
-        pglBlitFramebuffer( 0, 0, src.right, src.bottom, 0, 0, dst.right, dst.bottom,
-                            GL_COLOR_BUFFER_BIT, ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
-    }
-
-    if (draw_buffer == GL_FRONT)
-    {
-        if (fs_hack_direct_front_blit()) pglFlush();
-        else                             pglXSwapBuffers( gdi_display, gl->drawable );
-    }
-
-    if (gamma_ramp)
-    {
-        for (i = 0; i < ARRAY_SIZE(draw_state_handlers); i++)
-            draw_state_handlers[i].state_handler( RESET, gl, ctx, &state );
-    }
-
-    for (i = 0; i < ARRAY_SIZE(general_state_handlers); i++)
-        general_state_handlers[i].state_handler( RESET, gl, ctx, &state );
-}
-
-/***********************************************************************
- *		X11DRV_wglMakeContextCurrentARB
- */
-static BOOL X11DRV_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct wgl_context *ctx )
-{
-    BOOL ret = FALSE;
-    struct gl_drawable *draw_gl, *read_gl = NULL;
-
-    TRACE("(%p,%p,%p)\n", draw_hdc, read_hdc, ctx);
-
-    if (!ctx)
-    {
-        pglXMakeCurrent(gdi_display, None, NULL);
-        NtCurrentTeb()->glContext = NULL;
-        return TRUE;
-    }
-
-    if (!pglXMakeContextCurrent) return FALSE;
+    struct gl_drawable *draw = impl_from_opengl_drawable( draw_base ), *read = impl_from_opengl_drawable( read_base );
+    BOOL ret;
 
-    if ((draw_gl = get_gl_drawable( NtUserWindowFromDC( draw_hdc ), draw_hdc )))
-    {
-        read_gl = get_gl_drawable( NtUserWindowFromDC( read_hdc ), read_hdc );
+    TRACE( "draw %s, read %s, context %p\n", debugstr_opengl_drawable( draw_base ), debugstr_opengl_drawable( read_base ), context );
 
-        pthread_mutex_lock( &context_mutex );
-        ret = pglXMakeContextCurrent(gdi_display, draw_gl->drawable,
-                                     read_gl ? read_gl->drawable : 0, ctx->ctx);
-        if (ret)
-        {
-            ctx->hdc = draw_hdc;
-            set_context_drawables( ctx, draw_gl, read_gl );
-            ctx->has_been_current = TRUE;
-            NtCurrentTeb()->glContext = ctx;
-            pthread_mutex_unlock( &context_mutex );
-            goto done;
-        }
-        pthread_mutex_unlock( &context_mutex );
-    }
-    RtlSetLastWin32Error( ERROR_INVALID_HANDLE );
-done:
-    release_gl_drawable( read_gl );
-    release_gl_drawable( draw_gl );
-    TRACE( "%p,%p,%p returning %d\n", draw_hdc, read_hdc, ctx, ret );
+    if (!pglXMakeContextCurrent || !context) ret = pglXMakeCurrent( gdi_display, context ? draw->drawable : None, context );
+    else ret = pglXMakeContextCurrent( gdi_display, draw->drawable, read->drawable, context );
+    if (ret) NtCurrentTeb()->glReserved2 = context;
     return ret;
 }
 
-/***********************************************************************
- *		glxdrv_wglShareLists
- */
-static BOOL glxdrv_wglShareLists(struct wgl_context *org, struct wgl_context *dest)
+static void x11drv_surface_flush( struct opengl_drawable *base, UINT flags )
 {
-    struct wgl_context *keep, *clobber;
-
-    TRACE("(%p, %p)\n", org, dest);
-
-    /* Sharing of display lists works differently in GLX and WGL. In case of GLX it is done
-     * at context creation time but in case of WGL it is done using wglShareLists.
-     * In the past we tried to emulate wglShareLists by delaying GLX context creation until
-     * either a wglMakeCurrent or wglShareLists. This worked fine for most apps but it causes
-     * issues for OpenGL 3 because there wglCreateContextAttribsARB can fail in a lot of cases,
-     * so there delaying context creation doesn't work.
-     *
-     * The new approach is to create a GLX context in wglCreateContext / wglCreateContextAttribsARB
-     * and when a program requests sharing we recreate the destination or source context if it
-     * hasn't been made current and it hasn't shared display lists before.
-     */
+    struct gl_drawable *gl = impl_from_opengl_drawable( base );
 
-    if (share_all_contexts == 1) return TRUE;
+    TRACE( "%s flags %#x\n", debugstr_opengl_drawable( base ), flags );
 
-    if (!dest->has_been_current && !dest->sharing)
-    {
-        keep = org;
-        clobber = dest;
-    }
-    else if (!org->has_been_current && !org->sharing)
-    {
-        keep = dest;
-        clobber = org;
-    }
-    else
-    {
-        ERR("Could not share display lists because both of the contexts have already been current or shared\n");
-        return FALSE;
-    }
-
-    pglXDestroyContext(gdi_display, clobber->ctx);
-    clobber->ctx = create_glxcontext(gdi_display, clobber, keep->ctx);
-    TRACE("re-created context (%p) for Wine context %p (%s) sharing lists with ctx %p (%s)\n",
-          clobber->ctx, clobber, debugstr_fbconfig(clobber->fmt->fbconfig),
-          keep->ctx, debugstr_fbconfig(keep->fmt->fbconfig));
-
-    org->sharing = TRUE;
-    dest->sharing = TRUE;
-    return TRUE;
-}
+    if (flags & GL_FLUSH_INTERVAL) set_swap_interval( gl, base->interval );
 
-static void present_gl_drawable( HWND hwnd, HDC hdc, struct gl_drawable *gl, BOOL flush, BOOL gl_finish )
-{
-    struct window_surface *surface;
-    struct x11drv_win_data *data;
-    Drawable window, drawable;
-    RECT rect_dst, rect;
-    HWND toplevel;
-    HRGN region;
-    UINT dpi;
-
-    if (!gl) return;
-    switch (gl->type)
-    {
-    case DC_GL_PIXMAP_WIN: drawable = gl->pixmap; break;
-    case DC_GL_CHILD_WIN: drawable = gl->window; break;
-    default: drawable = 0; break;
-    }
-
-    if (hwnd && (surface = window_surface_get( hwnd )))
-    {
-        HDC hdc_dst;
-
-        TRACE("surface %p, alpha_mask %#x.\n", surface, surface->alpha_mask);
-        if (surface->alpha_mask)
-        {
-            /* GL drawing to ULW window never gets onscreen directly, only though UpdateLayeredWindow(). */
-            window_surface_release( surface );
-            if (!drawable) sync_gl_drawable( hwnd, FALSE );
-            return;
-        }
-        TRACE( "Surface is present.\n" );
-        hdc_dst = NtUserGetDCEx( hwnd, 0, DCX_CACHE | DCX_USESTYLE );
-        region = get_dc_monitor_region( hwnd, hdc );
-        if (region) NtGdiExtSelectClipRgn( hdc_dst, region, RGN_COPY );
-        NtGdiStretchBlt( hdc_dst, 0, 0, gl->rect.right - gl->rect.left, gl->rect.bottom - gl->rect.top,
-                         gl->hdc_src, 0, 0, gl->rect.right, gl->rect.bottom, SRCCOPY, 0 );
-        NtUserReleaseDC( hwnd, hdc_dst );
-        if (region) NtGdiDeleteObjectApp( region );
-        window_surface_release( surface );
-        return;
-    }
-
-    if (!drawable) return;
-
-    if (gl_finish) pglFinish();
-    if (flush) XFlush( gdi_display );
-
-    toplevel = NtUserGetAncestor( hwnd, GA_ROOT );
-    dpi = NtUserGetDpiForWindow( hwnd );
-    NtUserGetClientRect( hwnd, &rect_dst, dpi );
-    NtUserMapWindowPoints( hwnd, toplevel, (POINT *)&rect_dst, 2, dpi );
-    if (IsRectEmpty( &rect_dst ) || IsRectEmpty( &gl->rect )) return;
-    rect_dst = map_rect_virt_to_raw_for_monitor( NtUserMonitorFromWindow( toplevel, MONITOR_DEFAULTTONEAREST ), rect_dst, dpi );
-    if ((data = get_win_data( toplevel )))
-    {
-        OffsetRect( &rect_dst, data->rects.client.left - data->rects.visible.left,
-                    data->rects.client.top - data->rects.visible.top );
-        release_win_data( data );
-    }
-
-    window = get_dc_drawable( hdc, &rect );
-    region = get_dc_monitor_region( hwnd, hdc );
-
-    if (get_dc_drawable( gl->hdc_dst, &rect ) != window || !EqualRect( &rect, &rect_dst ))
-        set_dc_drawable( gl->hdc_dst, window, &rect_dst, IncludeInferiors );
-    if (region) NtGdiExtSelectClipRgn( gl->hdc_dst, region, RGN_COPY );
-
-    NtGdiStretchBlt( gl->hdc_dst, 0, 0, rect_dst.right - rect_dst.left, rect_dst.bottom - rect_dst.top,
-                     gl->hdc_src, 0, 0, gl->rect.right, gl->rect.bottom, SRCCOPY, 0 );
-
-    if (region) NtGdiDeleteObjectApp( region );
-}
-
-static void wglFinish(void)
-{
-    struct gl_drawable *gl;
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-    HWND hwnd = NtUserWindowFromDC( ctx->hdc );
-
-    if (!(gl = get_gl_drawable( hwnd, 0 ))) pglFinish();
-    else
-    {
-        sync_context(ctx);
-        if (gl->fs_hack && (!gl->fs_hack_did_swapbuf || ctx->drawing_to_front))
-            fs_hack_blit_framebuffer( gl, GL_FRONT );
-        pglFinish();
-        present_gl_drawable( hwnd, ctx->hdc, gl, TRUE, FALSE );
-        release_gl_drawable( gl );
-    }
-}
-
-static void wglFlush(void)
-{
-    struct gl_drawable *gl;
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-    HWND hwnd = NtUserWindowFromDC( ctx->hdc );
-
-    if (!(gl = get_gl_drawable( hwnd, 0 ))) pglFlush();
-    else
-    {
-        sync_context(ctx);
-        if (gl->fs_hack && (!gl->fs_hack_did_swapbuf || ctx->drawing_to_front))
-            fs_hack_blit_framebuffer( gl, GL_FRONT );
-        pglFlush();
-        present_gl_drawable( hwnd, ctx->hdc, gl, TRUE, TRUE );
-        release_gl_drawable( gl );
-    }
-}
-
-static const GLubyte *wglGetString(GLenum name)
-{
-    static int override_vendor = -1;
-    if (override_vendor == -1)
+    if (InterlockedCompareExchange( &base->client->offscreen, 0, 0 ))
     {
-        int fd;
-        char buffer[4096], *env;
-        int sz;
-
-        override_vendor = 0;
-        if ((env = getenv("WINE_GL_VENDOR_REPORT_AMD")))
-        {
-            override_vendor = env[0] != '0';
-        }
-        else
-        {
-            fd = open("/proc/self/cmdline", O_RDONLY);
-            if (fd != -1)
-            {
-                if ((sz = read(fd, buffer, sizeof(buffer) - 1)) > 0)
-                {
-                    buffer[sz] = 0;
-                    if (strstr(buffer, "\\Paradox Launcher.exe") || strstr(buffer, "Red Tie Runner.exe"))
-                    {
-                        FIXME("HACK: overriding GL vendor and renderer.\n");
-                        override_vendor = 1;
-                    }
-                }
-                close(fd);
-            }
-        }
-    }
-    if (override_vendor)
-    {
-        const GLubyte *s;
-        if (name == GL_RENDERER)
-        {
-            s = pglGetString(name);
-            if (s && (strstr((const char *)s, "NVIDIA") || strstr((const char *)s, "Intel")))
-            {
-                return (const GLubyte *)"AMD Radeon Graphics";
-            }
-            return s;
-        }
-        else if (name == GL_VENDOR)
-        {
-            s = pglGetString(name);
-            if (s && (strstr((const char *)s, "NVIDIA") || strstr((const char *)s, "Intel")))
-            {
-                return (const GLubyte *)"AMD";
-            }
-            return s;
-        }
+        if (!(flags & GL_FLUSH_FINISHED)) funcs->p_glFinish();
+        XFlush( gdi_display );
+        client_surface_present( base->client );
     }
-    if (name == GL_EXTENSIONS && glExtensions) return (const GLubyte *)glExtensions;
-    return pglGetString(name);
 }
 
 /***********************************************************************
  *		X11DRV_wglCreateContextAttribsARB
  */
-static struct wgl_context *X11DRV_wglCreateContextAttribsARB( HDC hdc, struct wgl_context *hShareContext,
-                                                              const int* attribList )
+static BOOL x11drv_context_create( int format, void *share, const int *attribList, void **context )
 {
-    struct wgl_context *ret;
-    struct gl_drawable *gl;
+    int glx_attribs[16] = {0}, *pContextAttribList = glx_attribs;
     int err = 0;
 
-    TRACE("(%p %p %p)\n", hdc, hShareContext, attribList);
+    TRACE("(%d %p %p)\n", format, share, attribList);
 
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
+    if (attribList)
     {
-        RtlSetLastWin32Error( ERROR_INVALID_PIXEL_FORMAT );
-        return NULL;
-    }
-
-    if ((ret = calloc( 1, sizeof(*ret) )))
-    {
-        ret->hdc = hdc;
-        ret->fmt = gl->format;
-        ret->gl3_context = TRUE;
-        if (attribList)
+        /* attribList consists of pairs {token, value] terminated with 0 */
+        while(attribList[0] != 0)
         {
-            int *pContextAttribList = &ret->attribList[0];
-            /* attribList consists of pairs {token, value] terminated with 0 */
-            while(attribList[0] != 0)
+            TRACE("%#x %#x\n", attribList[0], attribList[1]);
+            switch(attribList[0])
             {
-                TRACE("%#x %#x\n", attribList[0], attribList[1]);
-                switch(attribList[0])
-                {
-                case WGL_CONTEXT_MAJOR_VERSION_ARB:
-                    pContextAttribList[0] = GLX_CONTEXT_MAJOR_VERSION_ARB;
-                    pContextAttribList[1] = attribList[1];
-                    pContextAttribList += 2;
-                    ret->numAttribs++;
-                    break;
-                case WGL_CONTEXT_MINOR_VERSION_ARB:
-                    pContextAttribList[0] = GLX_CONTEXT_MINOR_VERSION_ARB;
-                    pContextAttribList[1] = attribList[1];
-                    pContextAttribList += 2;
-                    ret->numAttribs++;
-                    break;
-                case WGL_CONTEXT_LAYER_PLANE_ARB:
-                    break;
-                case WGL_CONTEXT_FLAGS_ARB:
-                    pContextAttribList[0] = GLX_CONTEXT_FLAGS_ARB;
-                    pContextAttribList[1] = attribList[1];
-                    pContextAttribList += 2;
-                    ret->numAttribs++;
-                    break;
-                case WGL_CONTEXT_OPENGL_NO_ERROR_ARB:
-                    pContextAttribList[0] = GLX_CONTEXT_OPENGL_NO_ERROR_ARB;
-                    pContextAttribList[1] = attribList[1];
-                    pContextAttribList += 2;
-                    ret->numAttribs++;
-                    break;
-                case WGL_CONTEXT_PROFILE_MASK_ARB:
-                    pContextAttribList[0] = GLX_CONTEXT_PROFILE_MASK_ARB;
-                    pContextAttribList[1] = attribList[1];
-                    pContextAttribList += 2;
-                    ret->numAttribs++;
-                    break;
-                case WGL_RENDERER_ID_WINE:
-                    pContextAttribList[0] = GLX_RENDERER_ID_MESA;
-                    pContextAttribList[1] = attribList[1];
-                    pContextAttribList += 2;
-                    ret->numAttribs++;
-                    break;
-                default:
-                    ERR("Unhandled attribList pair: %#x %#x\n", attribList[0], attribList[1]);
-                }
-                attribList += 2;
-            }
-        }
-
-        X11DRV_expect_error(gdi_display, GLXErrorHandler, NULL);
-        ret->ctx = create_glxcontext(gdi_display, ret,
-                                     hShareContext ? hShareContext->ctx : get_common_context( ret->fmt->fbconfig ));
-        XSync(gdi_display, False);
-        if ((err = X11DRV_check_error()) || !ret->ctx)
-        {
-            /* In the future we should convert the GLX error to a win32 one here if needed */
-            WARN("Context creation failed (error %#x).\n", err);
-            free( ret );
-            ret = NULL;
-        }
-        else
-        {
-            pthread_mutex_lock( &context_mutex );
-            list_add_head( &context_list, &ret->entry );
-            pthread_mutex_unlock( &context_mutex );
-        }
-    }
-
-    release_gl_drawable( gl );
-    TRACE( "%p -> %p\n", hdc, ret );
-    return ret;
-}
-
-/**
- * X11DRV_wglGetExtensionsStringARB
- *
- * WGL_ARB_extensions_string: wglGetExtensionsStringARB
- */
-static const char *X11DRV_wglGetExtensionsStringARB(HDC hdc)
-{
-    TRACE("() returning \"%s\"\n", wglExtensions);
-    return wglExtensions;
-}
-
-/**
- * X11DRV_wglCreatePbufferARB
- *
- * WGL_ARB_pbuffer: wglCreatePbufferARB
- */
-static struct wgl_pbuffer *X11DRV_wglCreatePbufferARB( HDC hdc, int iPixelFormat, int iWidth, int iHeight,
-                                                       const int *piAttribList )
-{
-    struct wgl_pbuffer* object;
-    const struct glx_pixel_format *fmt;
-    int attribs[256];
-    int nAttribs = 0;
-
-    TRACE("(%p, %d, %d, %d, %p)\n", hdc, iPixelFormat, iWidth, iHeight, piAttribList);
-
-    /* Convert the WGL pixelformat to a GLX format, if it fails then the format is invalid */
-    fmt = get_pixel_format(gdi_display, iPixelFormat, TRUE /* Offscreen */);
-    if(!fmt) {
-        ERR("(%p): invalid pixel format %d\n", hdc, iPixelFormat);
-        RtlSetLastWin32Error(ERROR_INVALID_PIXEL_FORMAT);
-        return NULL;
-    }
-
-    object = calloc( 1, sizeof(*object) );
-    if (NULL == object) {
-        RtlSetLastWin32Error(ERROR_NO_SYSTEM_RESOURCES);
-        return NULL;
-    }
-    object->width = iWidth;
-    object->height = iHeight;
-    object->fmt = fmt;
-
-    PUSH2(attribs, GLX_PBUFFER_WIDTH,  iWidth);
-    PUSH2(attribs, GLX_PBUFFER_HEIGHT, iHeight); 
-    while (piAttribList && 0 != *piAttribList) {
-        int attr_v;
-        switch (*piAttribList) {
-            case WGL_PBUFFER_LARGEST_ARB: {
-                ++piAttribList;
-                attr_v = *piAttribList;
-                TRACE("WGL_LARGEST_PBUFFER_ARB = %d\n", attr_v);
-                PUSH2(attribs, GLX_LARGEST_PBUFFER, attr_v);
+            case WGL_CONTEXT_MAJOR_VERSION_ARB:
+                pContextAttribList[0] = GLX_CONTEXT_MAJOR_VERSION_ARB;
+                pContextAttribList[1] = attribList[1];
+                pContextAttribList += 2;
                 break;
-            }
-
-            case WGL_TEXTURE_FORMAT_ARB: {
-                ++piAttribList;
-                attr_v = *piAttribList;
-                TRACE("WGL_render_texture Attribute: WGL_TEXTURE_FORMAT_ARB as %x\n", attr_v);
-                if (WGL_NO_TEXTURE_ARB == attr_v) {
-                    object->use_render_texture = 0;
-                } else {
-                    if (!use_render_texture_emulation) {
-                        RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                        goto create_failed;
-                    }
-                    switch (attr_v) {
-                        case WGL_TEXTURE_RGB_ARB:
-                            object->use_render_texture = GL_RGB;
-                            object->texture_bpp = 3;
-                            object->texture_format = GL_RGB;
-                            object->texture_type = GL_UNSIGNED_BYTE;
-                            break;
-                        case WGL_TEXTURE_RGBA_ARB:
-                            object->use_render_texture = GL_RGBA;
-                            object->texture_bpp = 4;
-                            object->texture_format = GL_RGBA;
-                            object->texture_type = GL_UNSIGNED_BYTE;
-                            break;
-
-                        /* WGL_FLOAT_COMPONENTS_NV */
-                        case WGL_TEXTURE_FLOAT_R_NV:
-                            object->use_render_texture = GL_FLOAT_R_NV;
-                            object->texture_bpp = 4;
-                            object->texture_format = GL_RED;
-                            object->texture_type = GL_FLOAT;
-                            break;
-                        case WGL_TEXTURE_FLOAT_RG_NV:
-                            object->use_render_texture = GL_FLOAT_RG_NV;
-                            object->texture_bpp = 8;
-                            object->texture_format = GL_LUMINANCE_ALPHA;
-                            object->texture_type = GL_FLOAT;
-                            break;
-                        case WGL_TEXTURE_FLOAT_RGB_NV:
-                            object->use_render_texture = GL_FLOAT_RGB_NV;
-                            object->texture_bpp = 12;
-                            object->texture_format = GL_RGB;
-                            object->texture_type = GL_FLOAT;
-                            break;
-                        case WGL_TEXTURE_FLOAT_RGBA_NV:
-                            object->use_render_texture = GL_FLOAT_RGBA_NV;
-                            object->texture_bpp = 16;
-                            object->texture_format = GL_RGBA;
-                            object->texture_type = GL_FLOAT;
-                            break;
-                        default:
-                            ERR("Unknown texture format: %x\n", attr_v);
-                            RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                            goto create_failed;
-                    }
-                }
+            case WGL_CONTEXT_MINOR_VERSION_ARB:
+                pContextAttribList[0] = GLX_CONTEXT_MINOR_VERSION_ARB;
+                pContextAttribList[1] = attribList[1];
+                pContextAttribList += 2;
                 break;
-            }
-
-            case WGL_TEXTURE_TARGET_ARB: {
-                ++piAttribList;
-                attr_v = *piAttribList;
-                TRACE("WGL_render_texture Attribute: WGL_TEXTURE_TARGET_ARB as %x\n", attr_v);
-                if (WGL_NO_TEXTURE_ARB == attr_v) {
-                    object->texture_target = 0;
-                } else {
-                    if (!use_render_texture_emulation) {
-                        RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                        goto create_failed;
-                    }
-                    switch (attr_v) {
-                        case WGL_TEXTURE_CUBE_MAP_ARB: {
-                            if (iWidth != iHeight) {
-                                RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                                goto create_failed;
-                            }
-                            object->texture_target = GL_TEXTURE_CUBE_MAP;
-                            object->texture_bind_target = GL_TEXTURE_BINDING_CUBE_MAP;
-                           break;
-                        }
-                        case WGL_TEXTURE_1D_ARB: {
-                            if (1 != iHeight) {
-                                RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                                goto create_failed;
-                            }
-                            object->texture_target = GL_TEXTURE_1D;
-                            object->texture_bind_target = GL_TEXTURE_BINDING_1D;
-                            break;
-                        }
-                        case WGL_TEXTURE_2D_ARB: {
-                            object->texture_target = GL_TEXTURE_2D;
-                            object->texture_bind_target = GL_TEXTURE_BINDING_2D;
-                            break;
-                        }
-                        case WGL_TEXTURE_RECTANGLE_NV: {
-                            object->texture_target = GL_TEXTURE_RECTANGLE_NV;
-                            object->texture_bind_target = GL_TEXTURE_BINDING_RECTANGLE_NV;
-                            break;
-                        }
-                        default:
-                            ERR("Unknown texture target: %x\n", attr_v);
-                            RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                            goto create_failed;
-                    }
-                }
+            case WGL_CONTEXT_LAYER_PLANE_ARB:
                 break;
-            }
-
-            case WGL_MIPMAP_TEXTURE_ARB: {
-                ++piAttribList;
-                attr_v = *piAttribList;
-                TRACE("WGL_render_texture Attribute: WGL_MIPMAP_TEXTURE_ARB as %x\n", attr_v);
-                if (!use_render_texture_emulation) {
-                    RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                    goto create_failed;
-                }
+            case WGL_CONTEXT_FLAGS_ARB:
+                pContextAttribList[0] = GLX_CONTEXT_FLAGS_ARB;
+                pContextAttribList[1] = attribList[1];
+                pContextAttribList += 2;
+                break;
+            case WGL_CONTEXT_OPENGL_NO_ERROR_ARB:
+                pContextAttribList[0] = GLX_CONTEXT_OPENGL_NO_ERROR_ARB;
+                pContextAttribList[1] = attribList[1];
+                pContextAttribList += 2;
+                break;
+            case WGL_CONTEXT_PROFILE_MASK_ARB:
+                pContextAttribList[0] = GLX_CONTEXT_PROFILE_MASK_ARB;
+                pContextAttribList[1] = attribList[1];
+                pContextAttribList += 2;
+                break;
+            case WGL_RENDERER_ID_WINE:
+                pContextAttribList[0] = GLX_RENDERER_ID_MESA;
+                pContextAttribList[1] = attribList[1];
+                pContextAttribList += 2;
                 break;
+            default:
+                ERR("Unhandled attribList pair: %#x %#x\n", attribList[0], attribList[1]);
             }
+            attribList += 2;
         }
-        ++piAttribList;
     }
 
-    PUSH1(attribs, None);
-    if (!(object->gl = calloc( 1, sizeof(*object->gl) )))
+    X11DRV_expect_error(gdi_display, GLXErrorHandler, NULL);
+    *context = create_glxcontext( format, share, attribList ? glx_attribs : NULL );
+    XSync(gdi_display, False);
+    if ((err = X11DRV_check_error()) || !*context)
     {
-        RtlSetLastWin32Error(ERROR_NO_SYSTEM_RESOURCES);
-        goto create_failed;
-    }
-    object->gl->type = DC_GL_PBUFFER;
-    object->gl->format = object->fmt;
-    object->gl->ref = 1;
-
-    object->gl->drawable = pglXCreatePbuffer(gdi_display, fmt->fbconfig, attribs);
-    TRACE("new Pbuffer drawable as %p (%lx)\n", object->gl, object->gl->drawable);
-    if (!object->gl->drawable) {
-        free( object->gl );
-        RtlSetLastWin32Error(ERROR_NO_SYSTEM_RESOURCES);
-        goto create_failed; /* unexpected error */
-    }
-    pthread_mutex_lock( &context_mutex );
-    list_add_head( &pbuffer_list, &object->entry );
-    pthread_mutex_unlock( &context_mutex );
-    TRACE("->(%p)\n", object);
-    return object;
-
-create_failed:
-    free( object );
-    TRACE("->(FAILED)\n");
-    return NULL;
-}
-
-/**
- * X11DRV_wglDestroyPbufferARB
- *
- * WGL_ARB_pbuffer: wglDestroyPbufferARB
- */
-static BOOL X11DRV_wglDestroyPbufferARB( struct wgl_pbuffer *object )
-{
-    TRACE("(%p)\n", object);
-
-    pthread_mutex_lock( &context_mutex );
-    list_remove( &object->entry );
-    pthread_mutex_unlock( &context_mutex );
-    release_gl_drawable( object->gl );
-    if (object->tmp_context)
-        pglXDestroyContext(gdi_display, object->tmp_context);
-    free( object );
-    return GL_TRUE;
-}
-
-/**
- * X11DRV_wglGetPbufferDCARB
- *
- * WGL_ARB_pbuffer: wglGetPbufferDCARB
- */
-static HDC X11DRV_wglGetPbufferDCARB( struct wgl_pbuffer *object )
-{
-    struct x11drv_escape_set_drawable escape;
-    struct gl_drawable *prev;
-    HDC hdc;
-
-    hdc = NtGdiOpenDCW( NULL, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-    if (!hdc) return 0;
-
-    pthread_mutex_lock( &context_mutex );
-    if (!XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&prev ))
-        release_gl_drawable( prev );
-    grab_gl_drawable( object->gl );
-    XSaveContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char *)object->gl );
-    pthread_mutex_unlock( &context_mutex );
-
-    escape.code = X11DRV_SET_DRAWABLE;
-    escape.drawable = object->gl->drawable;
-    escape.mode = IncludeInferiors;
-    SetRect( &escape.dc_rect, 0, 0, object->width, object->height );
-    escape.visual = default_visual;
-    NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
-
-    TRACE( "(%p)->(%p)\n", object, hdc );
-    return hdc;
-}
-
-/**
- * X11DRV_wglQueryPbufferARB
- *
- * WGL_ARB_pbuffer: wglQueryPbufferARB
- */
-static BOOL X11DRV_wglQueryPbufferARB( struct wgl_pbuffer *object, int iAttribute, int *piValue )
-{
-    TRACE("(%p, 0x%x, %p)\n", object, iAttribute, piValue);
-
-    switch (iAttribute) {
-        case WGL_PBUFFER_WIDTH_ARB:
-            pglXQueryDrawable(gdi_display, object->gl->drawable, GLX_WIDTH, (unsigned int*) piValue);
-            break;
-        case WGL_PBUFFER_HEIGHT_ARB:
-            pglXQueryDrawable(gdi_display, object->gl->drawable, GLX_HEIGHT, (unsigned int*) piValue);
-            break;
-
-        case WGL_PBUFFER_LOST_ARB:
-            /* GLX Pbuffers cannot be lost by default. We can support this by
-             * setting GLX_PRESERVED_CONTENTS to False and using glXSelectEvent
-             * to receive pixel buffer clobber events, however that may or may
-             * not give any benefit */
-            *piValue = GL_FALSE;
-            break;
-
-        case WGL_TEXTURE_FORMAT_ARB:
-            if (!object->use_render_texture) {
-                *piValue = WGL_NO_TEXTURE_ARB;
-            } else {
-                if (!use_render_texture_emulation) {
-                    RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
-                    return GL_FALSE;
-                }
-                switch(object->use_render_texture) {
-                    case GL_RGB:
-                        *piValue = WGL_TEXTURE_RGB_ARB;
-                        break;
-                    case GL_RGBA:
-                        *piValue = WGL_TEXTURE_RGBA_ARB;
-                        break;
-                    /* WGL_FLOAT_COMPONENTS_NV */
-                    case GL_FLOAT_R_NV:
-                        *piValue = WGL_TEXTURE_FLOAT_R_NV;
-                        break;
-                    case GL_FLOAT_RG_NV:
-                        *piValue = WGL_TEXTURE_FLOAT_RG_NV;
-                        break;
-                    case GL_FLOAT_RGB_NV:
-                        *piValue = WGL_TEXTURE_FLOAT_RGB_NV;
-                        break;
-                    case GL_FLOAT_RGBA_NV:
-                        *piValue = WGL_TEXTURE_FLOAT_RGBA_NV;
-                        break;
-                    default:
-                        ERR("Unknown texture format: %x\n", object->use_render_texture);
-                }
-            }
-            break;
-
-        case WGL_TEXTURE_TARGET_ARB:
-            if (!object->texture_target){
-                *piValue = WGL_NO_TEXTURE_ARB;
-            } else {
-                if (!use_render_texture_emulation) {
-                    RtlSetLastWin32Error(ERROR_INVALID_DATA);
-                    return GL_FALSE;
-                }
-                switch (object->texture_target) {
-                    case GL_TEXTURE_1D:       *piValue = WGL_TEXTURE_1D_ARB; break;
-                    case GL_TEXTURE_2D:       *piValue = WGL_TEXTURE_2D_ARB; break;
-                    case GL_TEXTURE_CUBE_MAP: *piValue = WGL_TEXTURE_CUBE_MAP_ARB; break;
-                    case GL_TEXTURE_RECTANGLE_NV: *piValue = WGL_TEXTURE_RECTANGLE_NV; break;
-                }
-            }
-            break;
-
-        case WGL_MIPMAP_TEXTURE_ARB:
-            *piValue = GL_FALSE; /** don't support that */
-            FIXME("unsupported WGL_ARB_render_texture attribute query for 0x%x\n", iAttribute);
-            break;
-
-        default:
-            FIXME("unexpected attribute %x\n", iAttribute);
-            break;
+        /* In the future we should convert the GLX error to a win32 one here if needed */
+        WARN("Context creation failed (error %#x).\n", err);
+        return FALSE;
     }
 
-    return GL_TRUE;
+    TRACE( "-> %p\n", *context );
+    return TRUE;
 }
 
-/**
- * X11DRV_wglReleasePbufferDCARB
- *
- * WGL_ARB_pbuffer: wglReleasePbufferDCARB
- */
-static int X11DRV_wglReleasePbufferDCARB( struct wgl_pbuffer *object, HDC hdc )
+static BOOL x11drv_pbuffer_create( HDC hdc, int format, BOOL largest, GLenum texture_format, GLenum texture_target,
+                                   GLint max_level, GLsizei *width, GLsizei *height, struct opengl_drawable **drawable )
 {
+    const struct glx_pixel_format *fmt = glx_pixel_format_from_format( format );
+    int glx_attribs[7], count = 0;
     struct gl_drawable *gl;
+    RECT rect;
 
-    TRACE("(%p, %p)\n", object, hdc);
-
-    pthread_mutex_lock( &context_mutex );
+    TRACE( "hdc %p, format %d, largest %u, texture_format %#x, texture_target %#x, max_level %#x, width %d, height %d, drawable %p\n",
+           hdc, format, largest, texture_format, texture_target, max_level, *width, *height, drawable );
 
-    if (!XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&gl ))
+    glx_attribs[count++] = GLX_PBUFFER_WIDTH;
+    glx_attribs[count++] = *width;
+    glx_attribs[count++] = GLX_PBUFFER_HEIGHT;
+    glx_attribs[count++] = *height;
+    if (largest)
     {
-        XDeleteContext( gdi_display, (XID)hdc, gl_pbuffer_context );
-        release_gl_drawable( gl );
-    }
-    else hdc = 0;
-
-    pthread_mutex_unlock( &context_mutex );
-
-    return hdc && NtGdiDeleteObjectApp(hdc);
-}
-
-/**
- * X11DRV_wglSetPbufferAttribARB
- *
- * WGL_ARB_pbuffer: wglSetPbufferAttribARB
- */
-static BOOL X11DRV_wglSetPbufferAttribARB( struct wgl_pbuffer *object, const int *piAttribList )
-{
-    GLboolean ret = GL_FALSE;
-
-    WARN("(%p, %p): alpha-testing, report any problem\n", object, piAttribList);
-
-    if (!object->use_render_texture) {
-        RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
-        return GL_FALSE;
+        glx_attribs[count++] = GLX_LARGEST_PBUFFER;
+        glx_attribs[count++] = 1;
     }
-    if (use_render_texture_emulation) {
-        return GL_TRUE;
-    }
-    return ret;
-}
-
-/**
- * X11DRV_wglBindTexImageARB
- *
- * WGL_ARB_render_texture: wglBindTexImageARB
- */
-static BOOL X11DRV_wglBindTexImageARB( struct wgl_pbuffer *object, int iBuffer )
-{
-    GLboolean ret = GL_FALSE;
-
-    TRACE("(%p, %d)\n", object, iBuffer);
-
-    if (!object->use_render_texture) {
-        RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
-        return GL_FALSE;
-    }
-
-    if (use_render_texture_emulation) {
-        static BOOL initialized = FALSE;
-        int prev_binded_texture = 0;
-        GLXContext prev_context;
-        GLXDrawable prev_drawable;
+    glx_attribs[count++] = 0;
 
-        prev_context = pglXGetCurrentContext();
-        prev_drawable = pglXGetCurrentDrawable();
+    if (!(gl = opengl_drawable_create( sizeof(*gl), &x11drv_pbuffer_funcs, format, NULL ))) return FALSE;
 
-        /* Our render_texture emulation is basic and lacks some features (1D/Cube support).
-           This is mostly due to lack of demos/games using them. Further the use of glReadPixels
-           isn't ideal performance wise but I wasn't able to get other ways working.
-        */
-        if(!initialized) {
-            initialized = TRUE; /* Only show the FIXME once for performance reasons */
-            FIXME("partial stub!\n");
-        }
-
-        TRACE("drawable=%p (%lx), context=%p\n", object->gl, object->gl->drawable, prev_context);
-        if (!object->tmp_context || object->prev_context != prev_context) {
-            if (object->tmp_context)
-                pglXDestroyContext(gdi_display, object->tmp_context);
-            object->tmp_context = pglXCreateNewContext(gdi_display, object->fmt->fbconfig, object->fmt->render_type, prev_context, True);
-            object->prev_context = prev_context;
-        }
-
-        opengl_funcs.gl.p_glGetIntegerv(object->texture_bind_target, &prev_binded_texture);
-
-        /* Switch to our pbuffer */
-        pglXMakeCurrent(gdi_display, object->gl->drawable, object->tmp_context);
-
-        /* Make sure that the prev_binded_texture is set as the current texture state isn't shared between contexts.
-         * After that copy the pbuffer texture data. */
-        opengl_funcs.gl.p_glBindTexture(object->texture_target, prev_binded_texture);
-        opengl_funcs.gl.p_glCopyTexImage2D(object->texture_target, 0, object->use_render_texture, 0, 0, object->width, object->height, 0);
-
-        /* Switch back to the original drawable and context */
-        pglXMakeCurrent(gdi_display, prev_drawable, prev_context);
-        return GL_TRUE;
+    gl->drawable = pglXCreatePbuffer( gdi_display, fmt->fbconfig, glx_attribs );
+    TRACE( "new Pbuffer drawable as %p (%lx)\n", gl, gl->drawable );
+    if (!gl->drawable)
+    {
+        opengl_drawable_release( &gl->base );
+        return FALSE;
     }
+    pglXQueryDrawable( gdi_display, gl->drawable, GLX_WIDTH, (unsigned int *)width );
+    pglXQueryDrawable( gdi_display, gl->drawable, GLX_HEIGHT, (unsigned int *)height );
+    SetRect( &rect, 0, 0, *width, *height );
+    set_dc_drawable( hdc, gl->drawable, &rect, IncludeInferiors );
 
-    return ret;
+    *drawable = &gl->base;
+    return TRUE;
 }
 
-/**
- * X11DRV_wglReleaseTexImageARB
- *
- * WGL_ARB_render_texture: wglReleaseTexImageARB
- */
-static BOOL X11DRV_wglReleaseTexImageARB( struct wgl_pbuffer *object, int iBuffer )
+static void x11drv_pbuffer_destroy( struct opengl_drawable *base )
 {
-    GLboolean ret = GL_FALSE;
+    struct gl_drawable *gl = impl_from_opengl_drawable( base );
 
-    TRACE("(%p, %d)\n", object, iBuffer);
+    TRACE( "drawable %s\n", debugstr_opengl_drawable( base ) );
 
-    if (!object->use_render_texture) {
-        RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
-        return GL_FALSE;
-    }
-    if (use_render_texture_emulation) {
-        return GL_TRUE;
-    }
-    return ret;
+    if (gl->drawable) pglXDestroyPbuffer( gdi_display, gl->drawable );
 }
 
-/**
- * X11DRV_wglGetExtensionsStringEXT
- *
- * WGL_EXT_extensions_string: wglGetExtensionsStringEXT
- */
-static const char *X11DRV_wglGetExtensionsStringEXT(void)
-{
-    TRACE("() returning \"%s\"\n", wglExtensions);
-    return wglExtensions;
-}
-
-/**
- * X11DRV_wglGetSwapIntervalEXT
- *
- * WGL_EXT_swap_control: wglGetSwapIntervalEXT
- */
-static int X11DRV_wglGetSwapIntervalEXT(void)
+static BOOL x11drv_pbuffer_updated( HDC hdc, struct opengl_drawable *base, GLenum cube_face, GLint mipmap_level )
 {
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-    struct gl_drawable *gl;
-    int swap_interval;
-
-    TRACE("()\n");
-
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), ctx->hdc )))
-    {
-        /* This can't happen because a current WGL context is required to get
-         * here. Likely the application is buggy.
-         */
-        WARN("No GL drawable found, returning swap interval 0\n");
-        return 0;
-    }
-
-    swap_interval = gl->swap_interval;
-    release_gl_drawable(gl);
-
-    return swap_interval;
-}
-
-/**
- * X11DRV_wglSwapIntervalEXT
- *
- * WGL_EXT_swap_control: wglSwapIntervalEXT
- */
-static BOOL X11DRV_wglSwapIntervalEXT(int interval)
-{
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
-    struct gl_drawable *gl;
-    BOOL ret;
-
-    TRACE("(%d)\n", interval);
-
-    /* Without WGL/GLX_EXT_swap_control_tear a negative interval
-     * is invalid.
-     */
-    if (interval < 0 && !has_swap_control_tear)
-    {
-        RtlSetLastWin32Error(ERROR_INVALID_DATA);
-        return FALSE;
-    }
-
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), ctx->hdc )))
-    {
-        RtlSetLastWin32Error(ERROR_DC_NOT_FOUND);
-        return FALSE;
-    }
-
-    pthread_mutex_lock( &context_mutex );
-    ret = set_swap_interval(gl->drawable, interval);
-    gl->refresh_swap_interval = FALSE;
-    if (ret)
-        gl->swap_interval = interval;
-    else
-        RtlSetLastWin32Error(ERROR_DC_NOT_FOUND);
-
-    pthread_mutex_unlock( &context_mutex );
-    release_gl_drawable(gl);
-
-    return ret;
+    return GL_TRUE;
 }
 
-/**
- * X11DRV_wglSetPixelFormatWINE
- *
- * WGL_WINE_pixel_format_passthrough: wglSetPixelFormatWINE
- * This is a WINE-specific wglSetPixelFormat which can set the pixel format multiple times.
- */
-static BOOL X11DRV_wglSetPixelFormatWINE(HDC hdc, int format)
+static UINT x11drv_pbuffer_bind( HDC hdc, struct opengl_drawable *base, GLenum buffer )
 {
-    return set_pixel_format(hdc, format, TRUE);
+    return -1; /* use default implementation */
 }
 
 static BOOL X11DRV_wglQueryCurrentRendererIntegerWINE( GLenum attribute, GLuint *value )
@@ -4122,55 +1362,14 @@
     TRACE("'%s'\n", ext);
 }
 
-/**
- * X11DRV_WineGL_LoadExtensions
- */
-static void X11DRV_WineGL_LoadExtensions(void)
+static const char *x11drv_init_wgl_extensions( struct opengl_funcs *funcs )
 {
     wglExtensions[0] = 0;
 
     /* ARB Extensions */
 
-    if (has_extension( glxExtensions, "GLX_ARB_create_context"))
-    {
-        register_extension( "WGL_ARB_create_context" );
-        opengl_funcs.ext.p_wglCreateContextAttribsARB = X11DRV_wglCreateContextAttribsARB;
-
-        if (has_extension( glxExtensions, "GLX_ARB_create_context_no_error" ))
-            register_extension( "WGL_ARB_create_context_no_error" );
-        if (has_extension( glxExtensions, "GLX_ARB_create_context_profile"))
-            register_extension("WGL_ARB_create_context_profile");
-    }
-
-
-    register_extension( "WGL_ARB_extensions_string" );
-    opengl_funcs.ext.p_wglGetExtensionsStringARB = X11DRV_wglGetExtensionsStringARB;
-
-    if (glxRequireVersion(3))
-    {
-        register_extension( "WGL_ARB_make_current_read" );
-        opengl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
-        opengl_funcs.ext.p_wglMakeContextCurrentARB = X11DRV_wglMakeContextCurrentARB;
-    }
-
     if (has_extension( glxExtensions, "GLX_ARB_multisample")) register_extension( "WGL_ARB_multisample" );
 
-    if (glxRequireVersion(3))
-    {
-        register_extension( "WGL_ARB_pbuffer" );
-        opengl_funcs.ext.p_wglCreatePbufferARB    = X11DRV_wglCreatePbufferARB;
-        opengl_funcs.ext.p_wglDestroyPbufferARB   = X11DRV_wglDestroyPbufferARB;
-        opengl_funcs.ext.p_wglGetPbufferDCARB     = X11DRV_wglGetPbufferDCARB;
-        opengl_funcs.ext.p_wglQueryPbufferARB     = X11DRV_wglQueryPbufferARB;
-        opengl_funcs.ext.p_wglReleasePbufferDCARB = X11DRV_wglReleasePbufferDCARB;
-        opengl_funcs.ext.p_wglSetPbufferAttribARB = X11DRV_wglSetPbufferAttribARB;
-    }
-
-    register_extension( "WGL_ARB_pixel_format" );
-    opengl_funcs.ext.p_wglChoosePixelFormatARB      = (void *)1; /* never called */
-    opengl_funcs.ext.p_wglGetPixelFormatAttribfvARB = (void *)1; /* never called */
-    opengl_funcs.ext.p_wglGetPixelFormatAttribivARB = (void *)1; /* never called */
-
     if (has_extension( glxExtensions, "GLX_ARB_fbconfig_float"))
     {
         register_extension("WGL_ARB_pixel_format_float");
@@ -4178,13 +1377,8 @@
     }
 
     /* Support WGL_ARB_render_texture when there's support or pbuffer based emulation */
-    if (has_extension( glxExtensions, "GLX_ARB_render_texture") ||
-        (glxRequireVersion(3) && use_render_texture_emulation))
+    if (has_extension( glxExtensions, "GLX_ARB_render_texture" ) || glxRequireVersion( 3 ))
     {
-        register_extension( "WGL_ARB_render_texture" );
-        opengl_funcs.ext.p_wglBindTexImageARB    = X11DRV_wglBindTexImageARB;
-        opengl_funcs.ext.p_wglReleaseTexImageARB = X11DRV_wglReleaseTexImageARB;
-
         /* The WGL version of GLX_NV_float_buffer requires render_texture */
         if (has_extension( glxExtensions, "GLX_NV_float_buffer"))
             register_extension("WGL_NV_float_buffer");
@@ -4196,15 +1390,6 @@
 
     /* EXT Extensions */
 
-    register_extension( "WGL_EXT_extensions_string" );
-    opengl_funcs.ext.p_wglGetExtensionsStringEXT = X11DRV_wglGetExtensionsStringEXT;
-
-    /* Load this extension even when it isn't backed by a GLX extension because it is has been around for ages.
-     * Games like Call of Duty and K.O.T.O.R. rely on it. Further our emulation is good enough. */
-    register_extension( "WGL_EXT_swap_control" );
-    opengl_funcs.ext.p_wglSwapIntervalEXT = X11DRV_wglSwapIntervalEXT;
-    opengl_funcs.ext.p_wglGetSwapIntervalEXT = X11DRV_wglGetSwapIntervalEXT;
-
     if (has_extension( glxExtensions, "GLX_EXT_framebuffer_sRGB"))
         register_extension("WGL_EXT_framebuffer_sRGB");
 
@@ -4214,11 +1399,7 @@
     if (has_extension( glxExtensions, "GLX_EXT_swap_control"))
     {
         swap_control_method = GLX_SWAP_CONTROL_EXT;
-        if (has_extension( glxExtensions, "GLX_EXT_swap_control_tear"))
-        {
-            register_extension("WGL_EXT_swap_control_tear");
-            has_swap_control_tear = TRUE;
-        }
+        has_swap_control_tear = has_extension( glxExtensions, "GLX_EXT_swap_control_tear" );
     }
     else if (has_extension( glxExtensions, "GLX_MESA_swap_control"))
     {
@@ -4233,8 +1414,8 @@
     if (has_extension(glExtensions, "GL_NV_vertex_array_range"))
     {
         register_extension( "WGL_NV_vertex_array_range" );
-        opengl_funcs.ext.p_wglAllocateMemoryNV = pglXAllocateMemoryNV;
-        opengl_funcs.ext.p_wglFreeMemoryNV = pglXFreeMemoryNV;
+        funcs->p_wglAllocateMemoryNV = pglXAllocateMemoryNV;
+        funcs->p_wglFreeMemoryNV = pglXFreeMemoryNV;
     }
 
     if (has_extension(glxExtensions, "GLX_OML_swap_method"))
@@ -4242,162 +1423,126 @@
 
     /* WINE-specific WGL Extensions */
 
-    /* In WineD3D we need the ability to set the pixel format more than once (e.g. after a device reset).
-     * The default wglSetPixelFormat doesn't allow this, so add our own which allows it.
-     */
-    register_extension( "WGL_WINE_pixel_format_passthrough" );
-    opengl_funcs.ext.p_wglSetPixelFormatWINE = X11DRV_wglSetPixelFormatWINE;
-
     if (has_extension( glxExtensions, "GLX_MESA_query_renderer" ))
     {
         register_extension( "WGL_WINE_query_renderer" );
-        opengl_funcs.ext.p_wglQueryCurrentRendererIntegerWINE = X11DRV_wglQueryCurrentRendererIntegerWINE;
-        opengl_funcs.ext.p_wglQueryCurrentRendererStringWINE = X11DRV_wglQueryCurrentRendererStringWINE;
-        opengl_funcs.ext.p_wglQueryRendererIntegerWINE = X11DRV_wglQueryRendererIntegerWINE;
-        opengl_funcs.ext.p_wglQueryRendererStringWINE = X11DRV_wglQueryRendererStringWINE;
+        funcs->p_wglQueryCurrentRendererIntegerWINE = X11DRV_wglQueryCurrentRendererIntegerWINE;
+        funcs->p_wglQueryCurrentRendererStringWINE = X11DRV_wglQueryCurrentRendererStringWINE;
+        funcs->p_wglQueryRendererIntegerWINE = X11DRV_wglQueryRendererIntegerWINE;
+        funcs->p_wglQueryRendererStringWINE = X11DRV_wglQueryRendererStringWINE;
     }
+
+    return wglExtensions;
 }
 
-/**
- * glxdrv_SwapBuffers
- *
- * Swap the buffers of this DC
- */
-static BOOL glxdrv_wglSwapBuffers( HDC hdc )
+static BOOL x11drv_surface_swap( struct opengl_drawable *base )
 {
-    struct gl_drawable *gl;
-    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    GLXContext ctx = NtCurrentTeb()->glReserved2;
+    struct gl_drawable *gl = impl_from_opengl_drawable( base );
     INT64 ust, msc, sbc, target_sbc = 0;
-    HWND hwnd = NtUserWindowFromDC( hdc );
-    Drawable drawable = 0;
+    BOOL offscreen;
 
-    TRACE("(%p)\n", hdc);
-
-    if (!(gl = get_gl_drawable( hwnd, hdc )))
-    {
-        RtlSetLastWin32Error( ERROR_INVALID_HANDLE );
-        return FALSE;
-    }
+    TRACE( "drawable %s\n", debugstr_opengl_drawable( base ) );
 
-    pthread_mutex_lock( &context_mutex );
-    if (gl->refresh_swap_interval)
+    if ((offscreen = InterlockedCompareExchange( &base->client->offscreen, 0, 0 )) ||
+        !ctx || !pglXSwapBuffersMscOML) pglXSwapBuffers( gdi_display, gl->drawable );
+    else
     {
-        set_swap_interval(gl->drawable, gl->swap_interval);
-        gl->refresh_swap_interval = FALSE;
+        funcs->p_glFlush();
+        target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
+        if (pglXWaitForSbcOML) pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );
     }
-    pthread_mutex_unlock( &context_mutex );
 
-    switch (gl->type)
+    if (offscreen)
     {
-    case DC_GL_PIXMAP_WIN:
-        if (ctx) sync_context( ctx );
-        drawable = gl->pixmap;
-        if (ctx && pglXCopySubBufferMESA) {
-            /* (glX)SwapBuffers has an implicit glFlush effect, however
-             * GLX_MESA_copy_sub_buffer doesn't. Make sure GL is flushed before
-             * copying */
-            pglFlush();
-            pglXCopySubBufferMESA( gdi_display, gl->drawable, 0, 0,
-                                   gl->rect.right, gl->rect.bottom );
-            break;
-        }
-        if (ctx && pglXSwapBuffersMscOML)
-        {
-            pglFlush();
-            target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
-            break;
-        }
-        pglXSwapBuffers(gdi_display, gl->drawable);
-        break;
-    case DC_GL_WINDOW:
-    case DC_GL_CHILD_WIN:
-        if (ctx) sync_context( ctx );
-        if (gl->type == DC_GL_CHILD_WIN) drawable = gl->window;
-        /* fall through */
-    default:
-        if (gl->fs_hack)
-        {
-            fs_hack_blit_framebuffer( gl, GL_BACK );
-            gl->fs_hack_did_swapbuf = TRUE;
-        }
-        if (ctx && drawable && pglXSwapBuffersMscOML)
-        {
-            pglFlush();
-            target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
-            break;
-        }
-        pglXSwapBuffers(gdi_display, gl->drawable);
-        break;
+        if (!pglXWaitForSbcOML) XFlush( gdi_display );
+        client_surface_present( base->client );
     }
 
-    if (ctx && drawable && pglXWaitForSbcOML)
-        pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );
-
-    present_gl_drawable( hwnd, ctx ? ctx->hdc : hdc, gl, !pglXWaitForSbcOML, FALSE );
-    update_gl_drawable_size( gl );
-    release_gl_drawable( gl );
     return TRUE;
 }
 
-static void glxdrv_get_pixel_formats( struct wgl_pixel_format *formats,
-                                      UINT max_formats, UINT *num_formats,
-                                      UINT *num_onscreen_formats )
+static void x11drv_egl_surface_destroy( struct opengl_drawable *base )
 {
-    UINT i;
+    TRACE( "drawable %s\n", debugstr_opengl_drawable( base ) );
+}
 
-    if (!has_opengl())
-    {
-        *num_formats = *num_onscreen_formats = 0;
-        return;
-    }
-    if (formats)
+static void x11drv_egl_surface_flush( struct opengl_drawable *base, UINT flags )
+{
+    TRACE( "%s\n", debugstr_opengl_drawable( base ) );
+
+    if (flags & GL_FLUSH_INTERVAL) funcs->p_eglSwapInterval( egl->display, abs( base->interval ) );
+
+    if (InterlockedCompareExchange( &base->client->offscreen, 0, 0 ))
     {
-        for (i = 0; i < min( max_formats, nb_pixel_formats ); ++i)
-            describe_pixel_format( i + 1, &formats[i] );
+        if (!(flags & GL_FLUSH_FINISHED)) funcs->p_glFinish();
+        XFlush( gdi_display );
+        client_surface_present( base->client );
     }
-    *num_formats = nb_pixel_formats;
-    *num_onscreen_formats = nb_onscreen_formats;
 }
 
-static struct opengl_funcs opengl_funcs =
+static BOOL x11drv_egl_surface_swap( struct opengl_drawable *base )
 {
+    struct gl_drawable *gl = impl_from_opengl_drawable( base );
+
+    TRACE( "%s\n", debugstr_opengl_drawable( base ) );
+
+    funcs->p_eglSwapBuffers( egl->display, gl->base.surface );
+
+    if (InterlockedCompareExchange( &base->client->offscreen, 0, 0 ))
     {
-        glxdrv_wglCopyContext,              /* p_wglCopyContext */
-        glxdrv_wglCreateContext,            /* p_wglCreateContext */
-        glxdrv_wglDeleteContext,            /* p_wglDeleteContext */
-        glxdrv_wglGetPixelFormat,           /* p_wglGetPixelFormat */
-        glxdrv_wglGetProcAddress,           /* p_wglGetProcAddress */
-        glxdrv_wglMakeCurrent,              /* p_wglMakeCurrent */
-        glxdrv_wglSetPixelFormat,           /* p_wglSetPixelFormat */
-        glxdrv_wglShareLists,               /* p_wglShareLists */
-        glxdrv_wglSwapBuffers,              /* p_wglSwapBuffers */
-        glxdrv_get_pixel_formats,           /* p_get_pixel_formats */
+        XFlush( gdi_display );
+        client_surface_present( base->client );
     }
+
+    return TRUE;
+}
+
+static struct opengl_driver_funcs x11drv_driver_funcs =
+{
+    .p_get_proc_address = x11drv_get_proc_address,
+    .p_init_pixel_formats = x11drv_init_pixel_formats,
+    .p_describe_pixel_format = x11drv_describe_pixel_format,
+    .p_init_wgl_extensions = x11drv_init_wgl_extensions,
+    .p_surface_create = x11drv_surface_create,
+    .p_context_create = x11drv_context_create,
+    .p_context_destroy = x11drv_context_destroy,
+    .p_make_current = x11drv_make_current,
+    .p_pbuffer_create = x11drv_pbuffer_create,
+    .p_pbuffer_updated = x11drv_pbuffer_updated,
+    .p_pbuffer_bind = x11drv_pbuffer_bind,
 };
 
-struct opengl_funcs *get_glx_driver( UINT version )
+static const struct opengl_drawable_funcs x11drv_surface_funcs =
 {
-    if (version != WINE_WGL_DRIVER_VERSION)
-    {
-        ERR( "version mismatch, opengl32 wants %u but driver has %u\n", version, WINE_WGL_DRIVER_VERSION );
-        return NULL;
-    }
-    if (has_opengl()) return &opengl_funcs;
-    return NULL;
-}
+    .destroy = x11drv_surface_destroy,
+    .flush = x11drv_surface_flush,
+    .swap = x11drv_surface_swap,
+};
 
-#else  /* no OpenGL includes */
+static const struct opengl_drawable_funcs x11drv_pbuffer_funcs =
+{
+    .destroy = x11drv_pbuffer_destroy,
+};
 
-struct opengl_funcs *get_glx_driver( UINT version )
+static const struct opengl_drawable_funcs x11drv_egl_surface_funcs =
 {
-    return NULL;
-}
+    .destroy = x11drv_egl_surface_destroy,
+    .flush = x11drv_egl_surface_flush,
+    .swap = x11drv_egl_surface_swap,
+};
+
+#else  /* no OpenGL includes */
 
-void sync_gl_drawable( HWND hwnd, BOOL known_child )
+/**********************************************************************
+ *           X11DRV_OpenglInit
+ */
+UINT X11DRV_OpenGLInit( UINT version, const struct opengl_funcs *opengl_funcs, const struct opengl_driver_funcs **driver_funcs )
 {
+    return STATUS_NOT_IMPLEMENTED;
 }
 
-void set_gl_drawable_parent( HWND hwnd, HWND parent )
+void sync_gl_drawable( HWND hwnd )
 {
 }
 
diff -urN proton_wine10.0/dlls/winex11.drv/vulkan.c wine-10.15/dlls/winex11.drv/vulkan.c
--- proton_wine10.0/dlls/winex11.drv/vulkan.c	2025-11-16 17:00:20.247403279 +0800
+++ wine-10.15/dlls/winex11.drv/vulkan.c	2025-09-13 03:36:38.000000000 +0800
@@ -27,7 +27,6 @@
 #include "config.h"
 
 #include <stdarg.h>
-#include <stdlib.h>
 #include <stdio.h>
 #include <dlfcn.h>
 
@@ -40,341 +39,43 @@
 #include "x11drv.h"
 #include "xcomposite.h"
 
+#define WINE_VULKAN_NO_X11_TYPES
 #include "wine/vulkan.h"
 #include "wine/vulkan_driver.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
-#ifdef SONAME_LIBVULKAN
-
-#define VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR 1000004000
-
-typedef struct VkXlibSurfaceCreateInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkXlibSurfaceCreateFlagsKHR flags;
-    Display *dpy;
-    Window window;
-} VkXlibSurfaceCreateInfoKHR;
-
-static VkResult (*pvkCreateXlibSurfaceKHR)(VkInstance, const VkXlibSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
-static VkBool32 (*pvkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice, uint32_t, Display *, VisualID);
-
 static const struct vulkan_driver_funcs x11drv_vulkan_driver_funcs;
 
-struct x11drv_vulkan_surface
-{
-    Window window;
-    RECT rect;
-
-    BOOL offscreen;
-    HDC hdc_src;
-    HDC hdc_dst;
-    BOOL other_process;
-};
-
-static void vulkan_surface_destroy( HWND hwnd, struct x11drv_vulkan_surface *surface )
-{
-    destroy_client_window( hwnd, surface->window );
-    if (surface->hdc_dst) NtGdiDeleteObjectApp( surface->hdc_dst );
-    if (surface->hdc_src) NtGdiDeleteObjectApp( surface->hdc_src );
-    free( surface );
-}
-
-static BOOL get_client_rect( HWND hwnd, BOOL raw, RECT *rect )
-{
-    UINT dpi = NtUserGetDpiForWindow( hwnd );
-
-    if (!NtUserGetClientRect( hwnd, rect, dpi )) return FALSE;
-    if (!raw) return TRUE;
-    *rect = map_rect_virt_to_raw_for_monitor( NtUserMonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST ), *rect, dpi );
-    OffsetRect( rect, -rect->left, -rect->top );
-    return TRUE;
-}
-
-static BOOL disable_opwr(void)
-{
-    static int disable = -1;
-
-    if (disable == -1)
-    {
-        const char *e = getenv( "WINE_DISABLE_VULKAN_OPWR" );
-        disable = e && atoi( e );
-    }
-    return disable;
-}
-
-static VkResult X11DRV_vulkan_surface_create( HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *handle, void **private )
+static VkResult X11DRV_vulkan_surface_create( HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *handle,
+                                              struct client_surface **client )
 {
     VkXlibSurfaceCreateInfoKHR info =
     {
         .sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
         .dpy = gdi_display,
     };
-    struct x11drv_vulkan_surface *surface;
-    BOOL enable_fshack = enable_fullscreen_hack( hwnd, FALSE );
-    DWORD hwnd_pid, hwnd_thread_id;
 
-    TRACE( "%p %p %p %p\n", hwnd, instance, handle, private );
+    TRACE( "%p %p %p %p\n", hwnd, instance, handle, client );
 
-    if (!(surface = calloc(1, sizeof(*surface))))
-    {
-        ERR("Failed to allocate vulkan surface for hwnd=%p\n", hwnd);
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-
-    if (!get_client_rect( hwnd, enable_fshack, &surface->rect ))
-    {
-        ERR( "get_client_rect failed.\n" );
-        free( surface );
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-
-    hwnd_thread_id = NtUserGetWindowThread(hwnd, &hwnd_pid);
-    if (hwnd_thread_id && hwnd_pid != GetCurrentProcessId())
-    {
-        XSetWindowAttributes attr;
-        RECT rect = surface->rect;
-        unsigned int width, height;
-
-        WARN("Other process window %p.\n", hwnd);
-
-        if (disable_opwr() && hwnd != NtUserGetDesktopWindow())
-        {
-            ERR( "HACK: Failing surface creation for other process window %p.\n", hwnd );
-            free( surface );
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
-        }
-
-        width = max( rect.right - rect.left, 1 );
-        height = max( rect.bottom - rect.top, 1 );
-        attr.colormap = default_colormap;
-        attr.bit_gravity = NorthWestGravity;
-        attr.win_gravity = NorthWestGravity;
-        attr.backing_store = NotUseful;
-        attr.border_pixel = 0;
-        surface->window = XCreateWindow( gdi_display, get_dummy_parent(), 0, 0, width, height, 0, default_visual.depth, InputOutput,
-                                         default_visual.visual, CWBitGravity | CWWinGravity | CWBackingStore | CWColormap | CWBorderPixel, &attr );
-        if (surface->window)
-        {
-            XMapWindow( gdi_display, surface->window );
-            XSync( gdi_display, False );
-            surface->other_process = TRUE;
-        }
-    }
-
-    if (!surface->window && !(surface->window = create_client_window( hwnd, surface->rect, &default_visual, default_colormap )))
-    {
-        ERR("Failed to allocate client window for hwnd=%p\n", hwnd);
-        free( surface );
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-
-    info.window = surface->window;
-    if (pvkCreateXlibSurfaceKHR( instance->host.instance, &info, NULL /* allocator */, handle ))
+    if (!(info.window = x11drv_client_surface_create( hwnd, &default_visual, default_colormap, client ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    if (instance->p_vkCreateXlibSurfaceKHR( instance->host.instance, &info, NULL /* allocator */, handle ))
     {
         ERR("Failed to create Xlib surface\n");
-        vulkan_surface_destroy( hwnd, surface );
+        client_surface_release( *client );
         return VK_ERROR_OUT_OF_HOST_MEMORY;
     }
 
-    *private = (void *)surface;
-
-    TRACE("Created surface 0x%s, private %p\n", wine_dbgstr_longlong(*handle), *private);
+    TRACE( "Created surface 0x%s, client %s\n", wine_dbgstr_longlong( *handle ), debugstr_client_surface( *client ) );
     return VK_SUCCESS;
 }
 
-static void X11DRV_vulkan_surface_destroy( HWND hwnd, void *private )
+static VkBool32 X11DRV_get_physical_device_presentation_support( struct vulkan_physical_device *physical_device, uint32_t index )
 {
-    struct x11drv_vulkan_surface *surface = private;
-
-    TRACE( "%p %p\n", hwnd, private );
-
-    vulkan_surface_destroy( hwnd, surface );
-}
-
-static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private )
-{
-    struct x11drv_vulkan_surface *surface = private;
-    Window client_window = surface->window;
-    struct x11drv_win_data *data;
-
-    TRACE( "%p %p\n", hwnd, private );
-
-    if ((data = get_win_data( hwnd )))
-    {
-        detach_client_window( data, client_window );
-        release_win_data( data );
-    }
-}
-
-static void vulkan_surface_update_size( HWND hwnd, struct x11drv_vulkan_surface *surface )
-{
-    BOOL enable_fshack = enable_fullscreen_hack( hwnd, FALSE );
-    XWindowChanges changes;
-    RECT rect;
-
-    if (!get_client_rect( hwnd, enable_fshack, &rect ))
-    {
-        WARN( "get_client_rect failed.\n" );
-        return;
-    }
-    if (EqualRect( &surface->rect, &rect )) return;
-
-    changes.width  = min( max( 1, rect.right ), 65535 );
-    changes.height = min( max( 1, rect.bottom ), 65535 );
-    XConfigureWindow( gdi_display, surface->window, CWWidth | CWHeight, &changes );
-    surface->rect = rect;
-}
-
-static void vulkan_surface_update_offscreen( HWND hwnd, struct x11drv_vulkan_surface *surface )
-{
-    BOOL offscreen = needs_offscreen_rendering( hwnd, FALSE, FALSE );
-    struct x11drv_win_data *data;
-
-    if (surface->other_process) offscreen = TRUE;
-    if (offscreen == surface->offscreen)
-    {
-        if (!offscreen && (data = get_win_data( hwnd )))
-        {
-            attach_client_window( data, surface->window );
-            release_win_data( data );
-        }
-        return;
-    }
-    surface->offscreen = offscreen;
-
-    if (!surface->offscreen)
-    {
-#ifdef SONAME_LIBXCOMPOSITE
-        if (usexcomposite) pXCompositeUnredirectWindow( gdi_display, surface->window, CompositeRedirectManual );
-#endif
-        if (surface->hdc_dst)
-        {
-            NtGdiDeleteObjectApp( surface->hdc_dst );
-            surface->hdc_dst = NULL;
-        }
-        if (surface->hdc_src)
-        {
-            NtGdiDeleteObjectApp( surface->hdc_src );
-            surface->hdc_src = NULL;
-        }
-    }
-    else
-    {
-        static const WCHAR displayW[] = {'D','I','S','P','L','A','Y'};
-        UNICODE_STRING device_str = RTL_CONSTANT_STRING(displayW);
-        surface->hdc_dst = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-        surface->hdc_src = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-        set_dc_drawable( surface->hdc_src, surface->window, &surface->rect, IncludeInferiors );
-#ifdef SONAME_LIBXCOMPOSITE
-        if (usexcomposite) pXCompositeRedirectWindow( gdi_display, surface->window, CompositeRedirectManual );
-#endif
-    }
-
-    if ((data = get_win_data( hwnd )))
-    {
-        if (surface->offscreen) detach_client_window( data, surface->window );
-        else attach_client_window( data, surface->window );
-        release_win_data( data );
-    }
-}
-
-static void X11DRV_vulkan_surface_update( HWND hwnd, void *private )
-{
-    struct x11drv_vulkan_surface *surface = private;
-
-    TRACE( "%p %p\n", hwnd, private );
-
-    vulkan_surface_update_size( hwnd, surface );
-    vulkan_surface_update_offscreen( hwnd, surface );
-}
-
-static int force_present_to_surface(void)
-{
-    static int cached = -1;
-
-    if (cached == -1)
-    {
-        const char *sgi = getenv( "SteamGameId" );
-
-        cached = sgi &&
-                 (
-                    !strcmp(sgi, "803600")
-                 );
-    }
-    return cached;
-}
-
-static void X11DRV_vulkan_surface_presented( HWND hwnd, void *private, VkResult result )
-{
-    struct x11drv_vulkan_surface *surface = private;
-    struct window_surface *win_surface;
-    struct x11drv_win_data *data;
-    RECT rect_dst, rect;
-    Drawable window;
-    HWND toplevel;
-    HRGN region;
-    UINT dpi;
-    HDC hdc;
-
-    vulkan_surface_update_size( hwnd, surface );
-    vulkan_surface_update_offscreen( hwnd, surface );
-
-    if (!surface->offscreen) return;
-
-    if (force_present_to_surface() && (win_surface = window_surface_get( hwnd )))
-    {
-        TRACE("blitting to surface win_surface %p.\n", win_surface);
-        if (!(hdc = NtUserGetDCEx( hwnd, 0, DCX_CACHE | DCX_USESTYLE ))) return;
-        NtGdiStretchBlt( hdc, 0, 0, surface->rect.right - surface->rect.left, surface->rect.bottom - surface->rect.top,
-                         surface->hdc_src, 0, 0, surface->rect.right, surface->rect.bottom, SRCCOPY, 0 );
-        NtUserReleaseDC( hwnd, hdc );
-        window_surface_release( win_surface );
-        return;
-    }
-
-    toplevel = NtUserGetAncestor( hwnd, GA_ROOT );
-    dpi = NtUserGetDpiForWindow( hwnd );
-    NtUserGetClientRect( hwnd, &rect_dst, dpi );
-    NtUserMapWindowPoints( hwnd, toplevel, (POINT *)&rect_dst, 2, dpi );
-    if (IsRectEmpty( &rect_dst ) || IsRectEmpty( &surface->rect )) return;
-    rect_dst = map_rect_virt_to_raw_for_monitor( NtUserMonitorFromWindow( toplevel, MONITOR_DEFAULTTONEAREST ), rect_dst, dpi );
-    if ((data = get_win_data( toplevel )))
-    {
-        OffsetRect( &rect_dst, data->rects.client.left - data->rects.visible.left,
-                    data->rects.client.top - data->rects.visible.top );
-        release_win_data( data );
-    }
-
-    if (!(hdc = NtUserGetDCEx( hwnd, 0, DCX_CACHE | DCX_USESTYLE ))) return;
-    window = X11DRV_get_whole_window( toplevel );
-    region = get_dc_monitor_region( hwnd, hdc );
-
-    if (get_dc_drawable( surface->hdc_dst, &rect ) != window || !EqualRect( &rect, &rect_dst ))
-        set_dc_drawable( surface->hdc_dst, window, &rect_dst, IncludeInferiors );
-    if (region) NtGdiExtSelectClipRgn( surface->hdc_dst, region, RGN_COPY );
-
-    NtGdiStretchBlt( surface->hdc_dst, 0, 0, rect_dst.right - rect_dst.left, rect_dst.bottom - rect_dst.top,
-                     surface->hdc_src, 0, 0, surface->rect.right, surface->rect.bottom, SRCCOPY, 0 );
-
-    if (region) NtGdiDeleteObjectApp( region );
-    if (hdc) NtUserReleaseDC( hwnd, hdc );
-}
-
-static BOOL X11DRV_vulkan_surface_enable_fshack( HWND hwnd, void *private )
-{
-    return enable_fullscreen_hack( hwnd, FALSE );
-}
-
-static VkBool32 X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice phys_dev,
-        uint32_t index)
-{
-    TRACE("%p %u\n", phys_dev, index);
-
-    return pvkGetPhysicalDeviceXlibPresentationSupportKHR(phys_dev, index, gdi_display,
-            default_visual.visual->visualid);
+    struct vulkan_instance *instance = physical_device->instance;
+    TRACE( "%p %u\n", physical_device, index );
+    return instance->p_vkGetPhysicalDeviceXlibPresentationSupportKHR( physical_device->host.physical_device, index, gdi_display,
+                                                                      default_visual.visual->visualid );
 }
 
 static const char *X11DRV_get_host_surface_extension(void)
@@ -385,13 +86,7 @@
 static const struct vulkan_driver_funcs x11drv_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = X11DRV_vulkan_surface_create,
-    .p_vulkan_surface_destroy = X11DRV_vulkan_surface_destroy,
-    .p_vulkan_surface_detach = X11DRV_vulkan_surface_detach,
-    .p_vulkan_surface_update = X11DRV_vulkan_surface_update,
-    .p_vulkan_surface_presented = X11DRV_vulkan_surface_presented,
-    .p_vulkan_surface_enable_fshack = X11DRV_vulkan_surface_enable_fshack,
-
-    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_get_physical_device_presentation_support = X11DRV_get_physical_device_presentation_support,
     .p_get_host_surface_extension = X11DRV_get_host_surface_extension,
 };
 
@@ -403,21 +98,6 @@
         return STATUS_INVALID_PARAMETER;
     }
 
-#define LOAD_FUNCPTR( f ) if (!(p##f = dlsym( vulkan_handle, #f ))) return STATUS_PROCEDURE_NOT_FOUND;
-    LOAD_FUNCPTR( vkCreateXlibSurfaceKHR );
-    LOAD_FUNCPTR( vkGetPhysicalDeviceXlibPresentationSupportKHR );
-#undef LOAD_FUNCPTR
-
     *driver_funcs = &x11drv_vulkan_driver_funcs;
     return STATUS_SUCCESS;
 }
-
-#else /* No vulkan */
-
-UINT X11DRV_VulkanInit( UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs )
-{
-    ERR( "Wine was built without Vulkan support.\n" );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-#endif /* SONAME_LIBVULKAN */
diff -urN proton_wine10.0/dlls/winex11.drv/window.c wine-10.15/dlls/winex11.drv/window.c
--- proton_wine10.0/dlls/winex11.drv/window.c	2025-11-16 17:00:20.248403252 +0800
+++ wine-10.15/dlls/winex11.drv/window.c	2025-09-13 03:36:38.000000000 +0800
@@ -82,7 +82,6 @@
     XATOM__KDE_NET_WM_STATE_SKIP_SWITCHER,
     XATOM__NET_WM_STATE_FULLSCREEN,
     XATOM__NET_WM_STATE_ABOVE,
-    XATOM__NET_WM_STATE_BELOW,
     XATOM__NET_WM_STATE_MAXIMIZED_VERT,
     XATOM__NET_WM_STATE_SKIP_PAGER,
     XATOM__NET_WM_STATE_SKIP_TASKBAR
@@ -112,6 +111,11 @@
     return wine_dbg_sprintf( "%lx,%lx", hints->functions, hints->decorations );
 }
 
+static const char *debugstr_monitor_indices( const struct monitor_indices *monitors )
+{
+    return wine_dbg_sprintf( "%ld,%ld,%ld,%ld", monitors->indices[0], monitors->indices[1], monitors->indices[2], monitors->indices[3] );
+}
+
 static pthread_mutex_t win_data_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static void host_window_add_ref( struct host_window *win )
@@ -253,7 +257,6 @@
     host_window_reparent( &win->parent, parent, win->window );
 }
 
-
 /***********************************************************************
  * http://standards.freedesktop.org/startup-notification-spec
  */
@@ -272,10 +275,7 @@
         return;
 
     if (!(id = getenv( "DESKTOP_STARTUP_ID" )) || !id[0]) return;
-
-    TRACE( "Using DESKTOP_STARTUP_ID %s\n", debugstr_a(id) );
-
-    if ((src = strstr( id, "_TIME" ))) update_user_time( data, atol( src + 5 ), FALSE );
+    if ((src = strstr( id, "_TIME" ))) window_set_user_time( data, atol( src + 5 ), FALSE );
 
     pos = snprintf(message, sizeof(message), "remove: ID=");
     message[pos++] = '"';
@@ -313,28 +313,6 @@
     }
 }
 
-static HWND hwnd_from_window( Display *display, Window window )
-{
-    unsigned long count, remaining;
-    unsigned long *xhwnd;
-    HWND hwnd = (HWND)-1;
-    int format;
-    Atom type;
-
-    if (!window) return 0;
-    if (!XFindContext( display, window, winContext, (char **)&hwnd )) return hwnd;
-
-    X11DRV_expect_error( display, host_window_error, NULL );
-    if (!XGetWindowProperty( display, window, x11drv_atom(_WINE_HWND), 0, 65536, False, XA_CARDINAL,
-                             &type, &format, &count, &remaining, (unsigned char **)&xhwnd ))
-    {
-        if (type == XA_CARDINAL && format == 32) hwnd = ULongToHandle(*xhwnd);
-        XFree( xhwnd );
-    }
-    if (X11DRV_check_error()) return (HWND)-1;
-    return hwnd;
-}
-
 static BOOL is_managed( HWND hwnd )
 {
     struct x11drv_win_data *data = get_win_data( hwnd );
@@ -343,7 +321,7 @@
     return ret;
 }
 
-HWND *build_hwnd_list(void)
+static HWND *build_hwnd_list(void)
 {
     NTSTATUS status;
     HWND *list;
@@ -378,6 +356,28 @@
     return ret;
 }
 
+/* returns the HWND for the X11 window, or the desktop window if it isn't a Wine window */
+static HWND hwnd_from_window( Display *display, Window window )
+{
+    HWND hwnd, desktop = NtUserGetDesktopWindow();
+    HWND *list;
+    UINT i;
+
+    if (!window) return 0;
+    if (window == root_window) return desktop;
+    if (!XFindContext( display, window, winContext, (char **)&hwnd )) return hwnd;
+
+    if (!(list = build_hwnd_list())) return desktop;
+
+    for (i = 0; list[i] != HWND_BOTTOM; i++)
+        if (window == X11DRV_get_whole_window( list[i] ))
+            break;
+    hwnd = list[i] == HWND_BOTTOM ? desktop : list[i];
+
+    free( list );
+
+    return hwnd;
+}
 
 /***********************************************************************
  *              alloc_win_data
@@ -399,31 +399,6 @@
 }
 
 
-static BOOL thickframe_managed( DWORD style )
-{
-    static int cached = -1;
-
-    if (!(style & WS_POPUP)) return TRUE;
-
-    if (cached == -1)
-    {
-        static const WCHAR app_name[] = u"\\SocialClubHelper.exe";
-        UNICODE_STRING *name;
-        DWORD len, name_len;
-
-        cached = 1;
-
-        name = &NtCurrentTeb()->Peb->ProcessParameters->ImagePathName;
-        len = name->Length / sizeof(WCHAR);
-        name_len = ARRAY_SIZE(app_name) - 1;
-        if (len >= name_len)
-            cached = !!memcmp( name->Buffer + len - name_len, app_name, name_len * sizeof(*app_name) );
-        if (!cached) FIXME( "HACK: making popups with WS_THICKFRAME not managed.\n" );
-    }
-    return cached;
-}
-
-
 /***********************************************************************
  *		is_window_managed
  *
@@ -444,7 +419,7 @@
     /* windows with caption are managed */
     if ((style & WS_CAPTION) == WS_CAPTION) return TRUE;
     /* windows with thick frame are managed */
-    if (style & WS_THICKFRAME && thickframe_managed( style )) return TRUE;
+    if (style & WS_THICKFRAME) return TRUE;
     if (style & WS_POPUP)
     {
         /* popup with sysmenu == caption are managed */
@@ -470,28 +445,6 @@
 static inline BOOL is_window_resizable( struct x11drv_win_data *data, DWORD style )
 {
     if (style & WS_THICKFRAME) return TRUE;
-    /* CW bug 24654: Tidy Cauldron (2708320) doesn't specify WS_THICKFRAME for its game window. And
-     * KWin refuses to both maximize and restore from maximization if a window is not resizable.
-     * Please see the isMaximizable() check at kwin-5.27.11/src/x11window.cpp#X11Window::maximize().
-     * Removing the resizable check on KWin introduces other bugs. See a previous MR that tried to
-     * do it at https://invent.kde.org/plasma/kwin/-/merge_requests/3248 */
-    if (X11DRV_HasWindowManager( "KWin" ))
-    {
-        static const WCHAR UnityWndClassW[] = {'U','n','i','t','y','W','n','d','C','l','a','s','s',0};
-        WCHAR class_name[80];
-        UNICODE_STRING name = { .Buffer = class_name, .MaximumLength = sizeof(class_name) };
-        const char *sgi;
-
-        NtUserGetClassName( data->hwnd, FALSE, &name );
-        if ((sgi = getenv( "SteamGameId" )) && !strcmp( sgi, "2708320" )
-            && !wcscmp( class_name, UnityWndClassW ))
-            return TRUE;
-
-        /* Some games fail to get proper fullscreen window size with KWin if we set window size hints,
-         * as the windows may briefly not be covering the entire screen when they becomes fullscreen.
-         */
-        if (sgi && !strcmp( sgi, "2552430" )) return TRUE;
-    }
     /* Metacity needs the window to be resizable to make it fullscreen */
     return data->is_fullscreen;
 }
@@ -503,8 +456,6 @@
 {
     unsigned long ret = 0;
 
-    if (X11DRV_HasWindowManager( "Mutter" )) return 0;
-
     if (ex_style & WS_EX_TOOLWINDOW) return 0;
     if (ex_style & WS_EX_LAYERED) return 0;
 
@@ -514,11 +465,7 @@
         if (style & WS_SYSMENU) ret |= MWM_DECOR_MENU;
         if (style & WS_MINIMIZEBOX) ret |= MWM_DECOR_MINIMIZE;
         if (style & WS_MAXIMIZEBOX) ret |= MWM_DECOR_MAXIMIZE;
-        if (style & WS_THICKFRAME) ret |= MWM_DECOR_RESIZEH;
     }
-    if (ex_style & WS_EX_DLGMODALFRAME) ret |= MWM_DECOR_BORDER;
-    else if (style & WS_THICKFRAME) return ret;
-    else if ((style & (WS_DLGFRAME|WS_BORDER)) == WS_DLGFRAME) ret |= MWM_DECOR_BORDER;
     return ret;
 }
 
@@ -568,6 +515,8 @@
         XSetWindowAttributes attr;
         int mask = get_window_attributes( data, &attr );
 
+        TRACE( "window %p/%lx changing attributes mask %#x, serial %lu\n", data->hwnd,
+               data->whole_window, mask, NextRequest( data->display ) );
         XChangeWindowAttributes( data->display, data->whole_window, mask, &attr );
         x11drv_xinput2_enable( data->display, data->whole_window );
     }
@@ -955,21 +904,63 @@
             size_hints->flags |= PMinSize | PMaxSize;
         }
     }
+
+    TRACE( "window %p/%lx requesting WM_NORMAL_HINTS flags %#lx, serial %lu\n", data->hwnd,
+           data->whole_window, size_hints->flags, NextRequest( data->display ) );
     XSetWMNormalHints( data->display, data->whole_window, size_hints );
     XFree( size_hints );
 }
 
+/* bits that can trigger spurious ConfigureNotify events */
+static const UINT config_notify_mask = (1 << NET_WM_STATE_MAXIMIZED) | (1 << NET_WM_STATE_FULLSCREEN) |
+                                       (1 << NET_WM_STATE_ABOVE);
+
+static BOOL window_needs_mwm_hints_change_delay( struct x11drv_win_data *data )
+{
+    if (data->pending_state.wm_state == WithdrawnState) return FALSE; /* window is unmapped, should be safe to make any change */
+    if (!data->configure_serial && !data->net_wm_state_serial) return FALSE; /* no other requests are pending, should be safe */
+    /* check whether we have a pending configure, either directly or because of a _NET_WM_STATE change which might trigger one  */
+    if (!data->configure_serial && !((data->pending_state.net_wm_state ^ data->current_state.net_wm_state) & config_notify_mask)) return FALSE;
+    /* delay any new _MOTIF_WM_HINTS change which might trigger a ConfigureNotify when a config/_NET_WM_STATE change is pending */
+    return (!data->desired_state.mwm_hints.decorations != !data->pending_state.mwm_hints.decorations);
+}
+
+static BOOL window_needs_net_wm_state_change_delay( struct x11drv_win_data *data )
+{
+    if (data->pending_state.wm_state == WithdrawnState) return FALSE; /* window is unmapped, should be safe to make any change */
+    if (!data->configure_serial && !data->mwm_hints_serial) return FALSE; /* no other requests are pending, should be safe */
+    /* check whether we have a pending configure, either directly or because _MOTIF_WM_HINTS decoration changed */
+    if (!data->configure_serial && !(!data->pending_state.mwm_hints.decorations != !data->current_state.mwm_hints.decorations)) return FALSE;
+    /* delay any new _NET_WM_STATE change which might trigger a ConfigureNotify when a config/_MOTIF_WM_HINTS change is pending */
+    return (data->desired_state.net_wm_state ^ data->pending_state.net_wm_state) & config_notify_mask;
+}
 
-static void window_set_wm_state( struct x11drv_win_data *data, UINT new_state, UINT swp_flags );
+static BOOL window_needs_config_change_delay( struct x11drv_win_data *data )
+{
+    if (!data->managed || data->embedded) return FALSE; /* window is not managed or is embedded, safe to make changes */
+    if (data->pending_state.wm_state == WithdrawnState) return FALSE; /* window is unmapped, should be safe to make any change */
+    if (data->configure_serial) return TRUE; /* another config update is pending, wait for it to complete */
+    /* delay any config request when a _NET_WM_STATE or _MOTIF_WM_HINTS change which might trigger a ConfigureNotify is in flight */
+    return (data->net_wm_state_serial && (data->pending_state.net_wm_state ^ data->current_state.net_wm_state) & config_notify_mask) ||
+           (data->mwm_hints_serial && (!data->pending_state.mwm_hints.decorations != !data->current_state.mwm_hints.decorations));
+}
 
-static void window_set_mwm_hints( struct x11drv_win_data *data, const MwmHints *new_hints, UINT swp_flags )
+static void window_set_mwm_hints( struct x11drv_win_data *data, const MwmHints *new_hints )
 {
     const MwmHints *old_hints = &data->pending_state.mwm_hints;
 
     data->desired_state.mwm_hints = *new_hints;
-    if (!data->whole_window) return; /* no window, nothing to update */
+    if (!data->whole_window || !data->managed || data->embedded) return; /* no window or not managed, nothing to update */
     if (!memcmp( old_hints, new_hints, sizeof(*new_hints) )) return; /* hints are the same, nothing to update */
 
+    if (window_needs_mwm_hints_change_delay( data ))
+    {
+        TRACE( "window %p/%lx is updating _NET_WM_STATE/config, delaying request\n", data->hwnd, data->whole_window );
+        return;
+    }
+
+    if (data->pending_state.wm_state == IconicState) return; /* window is iconic and may be mapped or not, don't update its state now */
+
     data->pending_state.mwm_hints = *new_hints;
     data->mwm_hints_serial = NextRequest( data->display );
     TRACE( "window %p/%lx, requesting _MOTIF_WM_HINTS %s serial %lu\n", data->hwnd, data->whole_window,
@@ -982,7 +973,7 @@
 /***********************************************************************
  *              set_mwm_hints
  */
-static void set_mwm_hints( struct x11drv_win_data *data, UINT style, UINT ex_style, UINT swp_flags )
+static void set_mwm_hints( struct x11drv_win_data *data, UINT style, UINT ex_style )
 {
     MwmHints mwm_hints;
 
@@ -1019,9 +1010,7 @@
     mwm_hints.flags = MWM_HINTS_FUNCTIONS | MWM_HINTS_DECORATIONS;
     mwm_hints.input_mode = 0;
     mwm_hints.status = 0;
-    TRACE( "%p setting mwm hints to %s (style %x exstyle %x)\n",
-           data->hwnd, debugstr_mwm_hints(&mwm_hints), style, ex_style );
-    window_set_mwm_hints( data, &mwm_hints, swp_flags );
+    window_set_mwm_hints( data, &mwm_hints );
 }
 
 
@@ -1057,6 +1046,8 @@
     else
         window_type = x11drv_atom(_NET_WM_WINDOW_TYPE_NORMAL);
 
+    TRACE( "window %p/%lx requesting _NET_WM_WINDOW_TYPE %#lx, serial %lu\n", data->hwnd,
+           data->whole_window, window_type, NextRequest( data->display ) );
     XChangeProperty(data->display, data->whole_window, x11drv_atom(_NET_WM_WINDOW_TYPE),
 		    XA_ATOM, 32, PropModeReplace, (unsigned char*)&window_type, 1);
 
@@ -1072,21 +1063,28 @@
             wm_hints->icon_mask = data->icon_mask;
             wm_hints->flags |= IconPixmapHint | IconMaskHint;
         }
+
+        TRACE( "window %p/%lx requesting WM_HINTS flags %#lx, serial %lu\n", data->hwnd,
+               data->whole_window, wm_hints->flags, NextRequest( data->display ) );
         XSetWMHints( data->display, data->whole_window, wm_hints );
         XFree( wm_hints );
     }
 
     if (data->icon_bits)
+    {
+        TRACE( "window %p/%lx requesting _NET_WM_ICON, serial %lu\n", data->hwnd,
+               data->whole_window, NextRequest( data->display ) );
         XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_ICON),
                          XA_CARDINAL, 32, PropModeReplace,
                          (unsigned char *)data->icon_bits, data->icon_size );
+    }
     else
+    {
+        TRACE( "window %p/%lx deleting _NET_WM_ICON, serial %lu\n", data->hwnd,
+               data->whole_window, NextRequest( data->display ) );
         XDeleteProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_ICON) );
+    }
 
-    XChangeProperty( data->display, data->whole_window, x11drv_atom(_WINE_HWND_STYLE), XA_CARDINAL, 32,
-                     PropModeReplace, (unsigned char *)&style, sizeof(style) / 4 );
-    XChangeProperty( data->display, data->whole_window, x11drv_atom(_WINE_HWND_EXSTYLE), XA_CARDINAL, 32,
-                     PropModeReplace, (unsigned char *)&ex_style, sizeof(ex_style) / 4 );
 }
 
 
@@ -1113,19 +1111,8 @@
     /* class hints */
     if ((class_hints = XAllocClassHint()))
     {
-        static char steam_proton[] = "steam_proton";
-        const char *app_id = getenv("SteamAppId");
-        char proton_app_class[128];
-
-        if(app_id && *app_id){
-            snprintf(proton_app_class, sizeof(proton_app_class), "steam_app_%s", app_id);
-            class_hints->res_name = proton_app_class;
-            class_hints->res_class = proton_app_class;
-        }else{
-            class_hints->res_name = steam_proton;
-            class_hints->res_class = steam_proton;
-        }
-
+        class_hints->res_name = process_name;
+        class_hints->res_class = process_name;
         XSetClassHint( display, window, class_hints );
         XFree( class_hints );
     }
@@ -1166,7 +1153,7 @@
  *
  * Set all the window manager hints for a window.
  */
-static void set_wm_hints( struct x11drv_win_data *data, UINT swp_flags )
+static void set_wm_hints( struct x11drv_win_data *data )
 {
     DWORD style, ex_style;
 
@@ -1183,7 +1170,7 @@
     }
 
     set_size_hints( data, style );
-    set_mwm_hints( data, style, ex_style, swp_flags );
+    set_mwm_hints( data, style, ex_style );
     set_style_hints( data, style, ex_style );
 }
 
@@ -1205,19 +1192,20 @@
 
 
 /***********************************************************************
- *     update_user_time
+ *     window_set_user_time
  */
-void update_user_time( struct x11drv_win_data *data, Time time, BOOL force )
+void window_set_user_time( struct x11drv_win_data *data, Time time, BOOL init )
 {
-    if (force) NtUserSetProp( data->hwnd, focus_time_prop, (HANDLE)time );
-    else if (!time) time = 1; /* time == 0 has reserved semantics */
+    if (init && data->managed) NtUserSetProp( data->hwnd, focus_time_prop, (HANDLE)time );
+    else if (!init && !time) time = 1; /* time == 0 has reserved semantics */
 
-    if (force ? !data->user_time == !time : data->user_time == time) return;
+    if (init && !data->user_time == !time) return;
+    if (!init && data->user_time == time) return;
     data->user_time = time;
 
     TRACE( "window %p/%lx, requesting _NET_WM_USER_TIME %ld serial %lu\n", data->hwnd, data->whole_window,
            data->user_time, NextRequest( data->display ) );
-    if (force && time) XDeleteProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_USER_TIME) );
+    if (init && time) XDeleteProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_USER_TIME) );
     else XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_USER_TIME), XA_CARDINAL,
                           32, PropModeReplace, (unsigned char *)&time, 1 );
 }
@@ -1226,7 +1214,7 @@
  * windows spanning multiple monitors */
 static void update_net_wm_fullscreen_monitors( struct x11drv_win_data *data )
 {
-    long monitors[4];
+    struct monitor_indices *old_monitors = &data->pending_state.monitors, monitors;
     XEvent xev;
 
     if (!(data->pending_state.net_wm_state & (1 << NET_WM_STATE_FULLSCREEN)) || is_virtual_desktop()
@@ -1239,27 +1227,19 @@
     if (!X11DRV_DisplayDevices_SupportEventHandlers())
         return;
 
-    if (!xinerama_get_fullscreen_monitors( &data->rects.visible, monitors ))
-        return;
+    xinerama_get_fullscreen_monitors( &data->rects.visible, &monitors.generation, monitors.indices );
+    data->desired_state.monitors = monitors;
 
-    /* If _NET_WM_FULLSCREEN_MONITORS is not set and the fullscreen monitors are spanning only one
-     * monitor then do not set _NET_WM_FULLSCREEN_MONITORS.
-     *
-     * If _NET_WM_FULLSCREEN_MONITORS is set then the property needs to be updated because it can't
-     * be deleted by sending a _NET_WM_FULLSCREEN_MONITORS client message to the root window
-     * according to the wm-spec version 1.5. Having the window spanning more than two monitors also
-     * needs the property set. In other cases, _NET_WM_FULLSCREEN_MONITORS doesn't need to be set.
-     * What's more, setting _NET_WM_FULLSCREEN_MONITORS adds a constraint on Mutter so that such a
-     * window can't be moved to another monitor by using the Shift+Super+Up/Down/Left/Right
-     * shortcut. So the property should be added only when necessary. */
-    if (monitors[0] == monitors[1] && monitors[1] == monitors[2] && monitors[2] == monitors[3]
-        && !data->net_wm_fullscreen_monitors_set)
-        return;
+    if (!memcmp( old_monitors, &monitors, sizeof(monitors) )) return; /* states are the same, nothing to update */
 
     if (data->pending_state.wm_state == WithdrawnState)
     {
-        XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_FULLSCREEN_MONITORS),
-                         XA_CARDINAL, 32, PropModeReplace, (unsigned char *)monitors, 4 );
+        memcpy( &data->pending_state.monitors, &monitors, sizeof(monitors) );
+        TRACE( "window %p/%lx, requesting _NET_WM_FULLSCREEN_MONITORS %s serial %lu\n", data->hwnd, data->whole_window,
+               debugstr_monitor_indices( &monitors ), NextRequest( data->display ) );
+        if (monitors.indices[0] == -1) XDeleteProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_FULLSCREEN_MONITORS) );
+        else XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_FULLSCREEN_MONITORS),
+                              XA_CARDINAL, 32, PropModeReplace, (unsigned char *)monitors.indices, 4 );
     }
     else
     {
@@ -1271,42 +1251,37 @@
         xev.xclient.send_event = True;
         xev.xclient.format = 32;
         xev.xclient.data.l[4] = 1;
-        memcpy( xev.xclient.data.l, monitors, sizeof(monitors) );
+        memcpy( xev.xclient.data.l, monitors.indices, sizeof(monitors.indices) );
+
+        memcpy( &data->pending_state.monitors, &monitors, sizeof(monitors) );
+        TRACE( "window %p/%lx, requesting _NET_WM_FULLSCREEN_MONITORS %s serial %lu\n", data->hwnd, data->whole_window,
+               debugstr_monitor_indices( &monitors ), NextRequest( data->display ) );
         XSendEvent( data->display, DefaultRootWindow( data->display ), False,
                     SubstructureRedirectMask | SubstructureNotifyMask, &xev );
     }
-    data->net_wm_fullscreen_monitors_set = TRUE;
+
+    /* assume it changes immediately, we don't track the property for now */
+    memcpy( &data->current_state.monitors, &monitors, sizeof(monitors) );
 }
 
 static void window_set_net_wm_state( struct x11drv_win_data *data, UINT new_state )
 {
-    static const UINT fullscreen_mask = (1 << NET_WM_STATE_MAXIMIZED) | (1 << NET_WM_STATE_FULLSCREEN);
-    UINT i, count, old_state = data->pending_state.net_wm_state, net_wm_bypass_compositor = 0;
-
-    /* Gamescope advertises _NET_WM_STATE_FULLSCREEN support but it then breaks its modeset emulation:
-     * Instead of upscaling the windows, it will make them cover the entire screen, increasing their
-     * pixel size even if the display mode is supposed to be at a lower resolution.
-     */
-    if (X11DRV_HasWindowManager( "steamcompmgr" )) new_state &= ~fullscreen_mask;
-
-    /* KWin sometimes combines NET_WM_STATE_FULLSCREEN with NET_WM_STATE_MAXIMIZED, but sometimes doesn't.
-     * Make sure we request both at the same time, so we don't get unexpected value when NET_WM_STATE_MAXIMIZED is added.
-     */
-    if (X11DRV_HasWindowManager( "KWin" ) && (new_state & (1 << NET_WM_STATE_FULLSCREEN))) new_state |= (1 << NET_WM_STATE_MAXIMIZED);
+    UINT i, count, old_state = data->pending_state.net_wm_state;
 
     new_state &= x11drv_thread_data()->net_wm_state_mask;
     data->desired_state.net_wm_state = new_state;
-    if (!data->whole_window) return; /* no window, nothing to update */
+    if (!data->whole_window || !data->managed || data->embedded) return; /* no window or not managed, nothing to update */
     if (data->wm_state_serial) return; /* another WM_STATE update is pending, wait for it to complete */
     /* we ignore and override previous _NET_WM_STATE update requests */
     if (old_state == new_state) return; /* states are the same, nothing to update */
 
-    /* On KWin wait for _NET_WM_STATE changes to complete when they touch maximized / fullscreen states */
-    if (X11DRV_HasWindowManager( "KWin" ) && data->pending_state.wm_state == NormalState &&
-        data->net_wm_state_serial && (old_state ^ new_state) & fullscreen_mask)
+    if (window_needs_net_wm_state_change_delay( data ))
+    {
+        TRACE( "window %p/%lx is updating config/_MOTIF_WM_HINTS, delaying request\n", data->hwnd, data->whole_window );
         return;
+    }
 
-    if (data->pending_state.wm_state == IconicState) return; /* window is iconic, don't update its state now */
+    if (data->pending_state.wm_state == IconicState) return; /* window is iconic and may be mapped or not, don't update its state now */
     if (data->pending_state.wm_state == WithdrawnState)  /* set the _NET_WM_STATE atom directly */
     {
         Atom atoms[NB_NET_WM_STATES + 1];
@@ -1342,6 +1317,7 @@
 
         for (i = 0; i < NB_NET_WM_STATES; i++)
         {
+            if (data->net_wm_state_serial) break; /* another _NET_WM_STATE update is pending, wait for it to complete */
             if (!((old_state ^ new_state) & (1 << i))) continue;
 
             xev.xclient.data.l[0] = (new_state & (1 << i)) ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
@@ -1349,7 +1325,7 @@
             xev.xclient.data.l[2] = ((net_wm_state_atoms[i] == XATOM__NET_WM_STATE_MAXIMIZED_VERT) ?
                                      x11drv_atom(_NET_WM_STATE_MAXIMIZED_HORZ) : 0);
 
-            data->pending_state.net_wm_state = new_state;
+            data->pending_state.net_wm_state ^= (1 << i);
             data->net_wm_state_serial = NextRequest( data->display );
             TRACE( "window %p/%lx, requesting _NET_WM_STATE %#x serial %lu\n", data->hwnd, data->whole_window,
                    data->pending_state.net_wm_state, data->net_wm_state_serial );
@@ -1358,58 +1334,41 @@
         }
     }
 
-    if (new_state & (1 << NET_WM_STATE_FULLSCREEN))
-    {
-        RECT virtual_screen = NtUserGetVirtualScreenRect( MDT_RAW_DPI );
-        net_wm_bypass_compositor = EqualRect( &data->rects.visible, &virtual_screen );
-    }
-
-    XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_BYPASS_COMPOSITOR), XA_CARDINAL,
-                     32, PropModeReplace, (unsigned char *)&net_wm_bypass_compositor, 1 );
-
     XFlush( data->display );
 }
 
-static void window_set_config( struct x11drv_win_data *data, const RECT *new_rect, BOOL above, UINT swp_flags )
+static void window_set_config( struct x11drv_win_data *data, RECT rect, BOOL above )
 {
-    static const UINT fullscreen_mask = (1 << NET_WM_STATE_MAXIMIZED) | (1 << NET_WM_STATE_FULLSCREEN);
-    UINT style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE ), mask = 0, net_wm_state = -1;
+    UINT style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE ), mask = 0;
     const RECT *old_rect = &data->pending_state.rect;
+    BOOL old_above = data->pending_state.above;
     XWindowChanges changes;
-    BOOL is_maximized;
+    RECT *new_rect = &rect;
+
+    /* resizing a managed maximized window is not allowed */
+    if ((style & WS_MAXIMIZE) && data->managed)
+    {
+        new_rect->right = new_rect->left + old_rect->right - old_rect->left;
+        new_rect->bottom = new_rect->top + old_rect->bottom - old_rect->top;
+    }
+    /* only the size is allowed to change for the desktop window or systray docked windows */
+    if (data->whole_window == root_window || data->embedded)
+    {
+        OffsetRect( new_rect, old_rect->left - new_rect->left, old_rect->top - new_rect->top );
+    }
 
     data->desired_state.rect = *new_rect;
+    data->desired_state.above = above;
     if (!data->whole_window) return; /* no window, nothing to update */
-    if (EqualRect( old_rect, new_rect ) && !above) return; /* rects are the same, no need to be raised, nothing to update */
-
-    /* Kwin internal maximized state tracking gets bogus if a window configure request is sent to a maximized
-     * window, and it loses track of whether the window was maximized state.
-     *
-     * Moving a maximized window to a different monitor requires sending a configure request but KWin bug makes
-     * no difference to requests with only position changes, and they trigger it all the same.
-     *
-     * Instead, explicitly request an unmap / map sequence ourselves and track the corresponding events, overriding
-     * the Mutter generated sequence, while achieving the same thing and getting WM_TAKE_FOCUS event when the
-     * window is mapped again.
-     */
-    is_maximized = (data->net_wm_state_serial ? data->pending_state.net_wm_state : data->current_state.net_wm_state) & fullscreen_mask;
-    if (X11DRV_HasWindowManager( "KWin" ) && data->managed && data->pending_state.wm_state == NormalState && is_maximized)
+    if (EqualRect( old_rect, new_rect ) && (old_above || !above || data->managed)) return; /* rects are the same, no need to be raised, nothing to update */
+    if (window_needs_config_change_delay( data ))
     {
-        if (data->wm_state_serial) return; /* another WM_STATE update is pending, wait for it to complete */
-        if (data->net_wm_state_serial) return; /* another _NET_WM_STATE update is pending, wait for it to complete */
-        WARN( "window %p/%lx is maximized/fullscreen, temporarily restoring\n", data->hwnd, data->whole_window );
-        data->net_wm_state_hack = 1;
-        net_wm_state = data->pending_state.net_wm_state;
-        window_set_net_wm_state( data, net_wm_state & ~fullscreen_mask );
+        TRACE( "window %p/%lx is updating _NET_WM_STATE/_MOTIF_WM_HINTS, delaying request\n", data->hwnd, data->whole_window );
+        return;
     }
 
-    /* Gamescope has broken _NET_WM_STATE_FULLSCREEN / _NET_WM_STATE_MAXIMIZED support, always allow resizing instead */
-    if (X11DRV_HasWindowManager( "steamcompmgr" )) style &= ~WS_MAXIMIZE;
-
-    /* resizing a managed maximized window is not allowed */
-    if ((old_rect->right - old_rect->left != new_rect->right - new_rect->left ||
-         old_rect->bottom - old_rect->top != new_rect->bottom - new_rect->top) &&
-        (!(style & WS_MAXIMIZE) || !data->managed))
+    if (old_rect->right - old_rect->left != new_rect->right - new_rect->left ||
+        old_rect->bottom - old_rect->top != new_rect->bottom - new_rect->top)
     {
         changes.width = new_rect->right - new_rect->left;
         changes.height = new_rect->bottom - new_rect->top;
@@ -1419,36 +1378,36 @@
         if (changes.height > 65535) changes.height = 65535;
         mask |= CWWidth | CWHeight;
     }
+    else
+    {
+        new_rect->right = new_rect->left + old_rect->right - old_rect->left;
+        new_rect->bottom = new_rect->top + old_rect->bottom - old_rect->top;
+    }
 
-    /* only the size is allowed to change for the desktop window or systray docked windows */
-    if ((old_rect->left != new_rect->left || old_rect->top != new_rect->top) &&
-        (data->whole_window != root_window && !data->embedded))
+    if (old_rect->left != new_rect->left || old_rect->top != new_rect->top)
     {
         POINT pt = virtual_screen_to_root( new_rect->left, new_rect->top );
         changes.x = pt.x;
         changes.y = pt.y;
         mask |= CWX | CWY;
     }
-
-    if (data->force_below_hack)
+    else
     {
-        changes.stack_mode = Below;
-        mask |= CWStackMode;
+        OffsetRect( new_rect, old_rect->left - new_rect->left, old_rect->top - new_rect->top );
     }
-    else if (above)
+
+    if (above)
     {
         changes.stack_mode = Above;
         mask |= CWStackMode;
     }
 
     data->pending_state.rect = *new_rect;
+    data->pending_state.above = above;
     data->configure_serial = NextRequest( data->display );
-    TRACE( "window %p/%lx, requesting config %s above %u mask %#x, serial %lu\n", data->hwnd, data->whole_window,
-           wine_dbgstr_rect(new_rect), above, mask, data->configure_serial );
+    TRACE( "window %p/%lx, requesting config %s mask %#x above %u, serial %lu\n", data->hwnd, data->whole_window,
+           wine_dbgstr_rect(new_rect), mask, above, data->configure_serial );
     XReconfigureWMWindow( data->display, data->whole_window, data->vis.screen, mask, &changes );
-    if (mask & (CWWidth | CWHeight)) clear_emulated_fullscreen_padding( data );
-
-    if (net_wm_state != -1) window_set_net_wm_state( data, net_wm_state );
 }
 
 /***********************************************************************
@@ -1459,18 +1418,15 @@
     static const UINT fullscreen_mask = (1 << NET_WM_STATE_MAXIMIZED) | (1 << NET_WM_STATE_FULLSCREEN);
     UINT style, ex_style, new_state = 0;
 
-    if (!data->managed || data->embedded) return;
+    if (data->embedded) return;
     if (data->whole_window == root_window)
     {
-        if (!is_virtual_desktop()) return;
-        new_state = is_desktop_fullscreen() ? fullscreen_mask : 0;
-        window_set_net_wm_state( data, new_state );
+        if (is_virtual_desktop()) window_set_net_wm_state( data, is_desktop_fullscreen() ? (1 << NET_WM_STATE_FULLSCREEN) : 0 );
         return;
     }
 
     style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
-    if (style & WS_MINIMIZE)
-        new_state |= data->desired_state.net_wm_state & fullscreen_mask;
+    if (style & WS_MINIMIZE) new_state |= data->desired_state.net_wm_state & fullscreen_mask;
     if (data->is_fullscreen)
     {
         if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION)
@@ -1482,17 +1438,7 @@
         new_state |= (1 << NET_WM_STATE_MAXIMIZED);
 
     ex_style = NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE );
-    if (data->force_below_hack)
-        new_state |= (1 << NET_WM_STATE_BELOW);
-    else if ((ex_style & WS_EX_TOPMOST) &&
-        /* This workaround was initially targetting some mutter and KDE issues, but
-         * removing it causes failure to focus out from exclusive fullscreen windows.
-         *
-         * Many games do not have any specific logic to get out of exclusive fullscreen
-         * mode, and we have currently no way to tell exclusive fullscreen from a window
-         * with topmost + fullscreen styles, so we cannot properly implement it either.
-         */
-        !(new_state & (1 << NET_WM_STATE_FULLSCREEN)))
+    if (ex_style & WS_EX_TOPMOST)
         new_state |= (1 << NET_WM_STATE_ABOVE);
     if (!data->add_taskbar)
     {
@@ -1543,11 +1489,6 @@
     if (!maximized_horz)
         new_state &= ~(1 << NET_WM_STATE_MAXIMIZED);
 
-    /* KWin sometimes combines NET_WM_STATE_FULLSCREEN with NET_WM_STATE_MAXIMIZED, but sometimes doesn't.
-     * Make sure both are always set in replies, so we don't change the win32 state unnecessarily.
-     */
-    if (X11DRV_HasWindowManager( "KWin" ) && (new_state & (1 << NET_WM_STATE_FULLSCREEN))) new_state |= (1 << NET_WM_STATE_MAXIMIZED);
-
     return new_state;
 }
 
@@ -1565,32 +1506,16 @@
                      x11drv_atom(_XEMBED_INFO), 32, PropModeReplace, (unsigned char*)info, 2 );
 }
 
-static int skip_iconify(void)
-{
-    static int cached = -1;
-    const char *env;
-
-    if (cached == -1)
-    {
-        cached = (env = getenv( "SteamGameId" )) && (0
-                    || !strcmp( env, "1827980" )
-                    || !strcmp( env, "1183470" )
-                 );
-        if (cached) FIXME( "HACK: skip_iconify.\n" );
-    }
-
-    return cached;
-}
-
-static void window_set_wm_state( struct x11drv_win_data *data, UINT new_state, UINT swp_flags )
+static void window_set_wm_state( struct x11drv_win_data *data, UINT new_state, BOOL activate )
 {
     UINT old_state = data->pending_state.wm_state;
     HWND foreground = NtUserGetForegroundWindow();
 
     data->desired_state.wm_state = new_state;
-    data->desired_state.swp_flags = swp_flags;
+    data->desired_state.activate = activate;
     if (!data->whole_window) return; /* no window, nothing to update */
-    if (data->wm_state_serial) return; /* another WM_STATE update is pending, wait for it to complete */
+    if (data->wm_state_serial && !data->current_state.wm_state != !data->pending_state.wm_state)
+        return; /* another map/unmap WM_STATE update is pending, wait for it to complete */
     if (old_state == new_state) return; /* states are the same, nothing to update */
 
     /* When transitioning a window from IconicState to NormalState and the window is managed, go
@@ -1598,14 +1523,12 @@
      * windows iconic/minimized as Mutter needs to support live preview for minimized windows. So on
      * Mutter, a window can be both iconic and mapped. If the window is mapped, then XMapWindow()
      * will have no effect according to the  XMapWindow() documentation. Thus we have to transition
-     * to WithdrawnState first, then to NormalState. Other window managers such as KWin don't need
-     * this because they unmap windows when making them iconic */
-    if (X11DRV_HasWindowManager( "Mutter" ) && data->managed
-        && MAKELONG(old_state, new_state) == MAKELONG(IconicState, NormalState))
+     * to WithdrawnState first, then to NormalState */
+    if (data->managed && MAKELONG(old_state, new_state) == MAKELONG(IconicState, NormalState))
     {
         WARN( "window %p/%lx is iconic, remapping to workaround Mutter issues.\n", data->hwnd, data->whole_window );
-        window_set_wm_state( data, WithdrawnState, 0 );
-        window_set_wm_state( data, NormalState, swp_flags );
+        window_set_wm_state( data, WithdrawnState, FALSE );
+        window_set_wm_state( data, NormalState, activate );
         return;
     }
 
@@ -1614,50 +1537,29 @@
     case MAKELONG(WithdrawnState, IconicState):
     case MAKELONG(WithdrawnState, NormalState):
         remove_startup_notification( data );
-        set_wm_hints( data, swp_flags );
+        set_wm_hints( data );
         update_net_wm_states( data );
         sync_window_style( data );
         update_net_wm_fullscreen_monitors( data );
         break;
     case MAKELONG(IconicState, NormalState):
     case MAKELONG(NormalState, IconicState):
-        set_wm_hints( data, swp_flags );
+        set_wm_hints( data );
         break;
     }
 
     if (new_state == NormalState)
     {
         /* try forcing activation if the window is supposed to be foreground or if it is fullscreen */
-        if (data->hwnd == foreground || data->is_fullscreen) swp_flags = 0;
-        if (swp_flags & SWP_NOACTIVATE) update_user_time( data, 0, TRUE );
-        else
-        {
-            /* Some older Mutter versions get confused when mapping a window while another has focus
-             * and if there's another window with _NET_WM_STATE_ABOVE. It then decides that the newly
-             * mapped window doesn't deserve to be raised or focused, even if the topmost window isn't
-             * the one with focus and even if it only slightly overlaps it. Reset focus before mapping
-             * the window to force it to be focused instead.
-             */
-            if (X11DRV_HasWindowManager( "Mutter" )) XSetInputFocus( data->display, None, RevertToNone, CurrentTime );
-            update_user_time( data, -1, TRUE );
-        }
+        if (data->hwnd == foreground || data->is_fullscreen) activate = TRUE;
+        window_set_user_time( data, activate ? -1 : 0, TRUE );
     }
 
     data->pending_state.wm_state = new_state;
-    data->pending_state.swp_flags = swp_flags;
+    data->pending_state.activate = activate;
     data->wm_state_serial = NextRequest( data->display );
-    TRACE( "window %p/%lx, requesting WM_STATE %#x -> %#x serial %lu, foreground %p\n", data->hwnd, data->whole_window,
-           old_state, new_state, data->wm_state_serial, NtUserGetForegroundWindow() );
-
-    if (new_state == IconicState && X11DRV_HasWindowManager( "steamcompmgr" ) && skip_iconify())
-    {
-        /* Gamescope will restore window when attempting to iconify it. Do not call XIconifyWindow() and
-         * pretend that window is already minimized for the games which depend on some windows to be minimized. */
-        WARN( "hwnd %p, skipping iconify.\n", data->hwnd );
-        data->current_state.wm_state = data->pending_state.wm_state;
-        data->wm_state_serial = 0;
-        return;
-    }
+    TRACE( "window %p/%lx, requesting WM_STATE %#x -> %#x serial %lu, foreground %p, activate %u\n", data->hwnd, data->whole_window,
+           old_state, new_state, data->wm_state_serial, NtUserGetForegroundWindow(), activate );
 
     switch (MAKELONG(old_state, new_state))
     {
@@ -1678,51 +1580,41 @@
         break;
     }
 
-    /* CW Bug 25142: Project CARS 3 (958400) fails to enter triple screen mode Mutter doesn't load
-     * _NET_WM_FULLSCREEN_MONITORS property when its value was set before a window gets mapped. Work
-     * around the Mutter issue for now by updating the property after the window gets mapped. Remove
-     * this hack after https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/4389 gets merged and
-     * widely deployed */
-    if (X11DRV_HasWindowManager( "Mutter" ) && new_state == NormalState && !data->embedded)
-        update_net_wm_fullscreen_monitors( data );
-
     /* override redirect windows won't receive WM_STATE property changes */
     if (!data->managed) data->wm_state_serial = 0;
 
-    /* Gamescope has broken ICCCM support, and never sets the WM_STATE property.
-     * Still, it changes it to NormalState on IconifyWindow, or when giving focus to a window so we will
-     * mostly only lack response for transitions to Withdrawn and shouldn't wait for it.
-     */
-    if (X11DRV_HasWindowManager( "steamcompmgr" ) && new_state == WithdrawnState) data->wm_state_serial = 0;
-
     XFlush( data->display );
 }
 
-static void window_set_managed( struct x11drv_win_data *data, BOOL new_managed, BOOL new_embedded )
+static void window_set_managed( struct x11drv_win_data *data, BOOL new_managed )
 {
-    UINT wm_state = data->desired_state.wm_state, swp_flags = data->desired_state.swp_flags;
     XSetWindowAttributes attr = {.override_redirect = !new_managed};
-    BOOL old_managed = data->managed, old_embedded = data->embedded;
+    UINT wm_state = data->desired_state.wm_state, activate = data->desired_state.activate;
+    BOOL old_managed = data->managed;
 
     if (!data->whole_window) return; /* no window, nothing to update */
-    if (old_managed == new_managed && old_embedded == new_embedded) return; /* states are the same, nothing to update */
+    if (old_managed == new_managed) return; /* states are the same, nothing to update */
+    if (!new_managed)
+    {
+        ERR( "Changing window to unmanaged is not supported\n" );
+        return;
+    }
 
-    window_set_wm_state( data, WithdrawnState, 0 ); /* no WM_STATE is pending, requested immediately */
+    window_set_wm_state( data, WithdrawnState, FALSE ); /* no WM_STATE is pending, requested immediately */
 
     data->managed = new_managed;
-    data->embedded = new_embedded;
     TRACE( "window %p/%lx, requesting override-redirect %u -> %u serial %lu\n", data->hwnd, data->whole_window,
            !old_managed, !new_managed, NextRequest( data->display ) );
     XChangeWindowAttributes( data->display, data->whole_window, CWOverrideRedirect, &attr );
 
-    window_set_wm_state( data, wm_state, swp_flags ); /* queue another WM_STATE request with the desired state */
+    window_set_wm_state( data, wm_state, activate ); /* queue another WM_STATE request with the desired state */
 }
 
 
 /***********************************************************************
  *     map_window
  */
-static void map_window( HWND hwnd, DWORD new_style, BOOL swp_flags )
+static void map_window( HWND hwnd, DWORD new_style, BOOL activate )
 {
     struct x11drv_win_data *data;
 
@@ -1730,21 +1622,7 @@
 
     if (!(data = get_win_data( hwnd ))) return;
     TRACE( "win %p/%lx\n", data->hwnd, data->whole_window );
-    window_set_wm_state( data, (new_style & WS_MINIMIZE) ? IconicState : NormalState, swp_flags );
-    release_win_data( data );
-}
-
-
-/***********************************************************************
- *     unmap_window
- */
-static void unmap_window( HWND hwnd )
-{
-    struct x11drv_win_data *data;
-
-    if (!(data = get_win_data( hwnd ))) return;
-    TRACE( "win %p/%lx\n", data->hwnd, data->whole_window );
-    window_set_wm_state( data, WithdrawnState, 0 );
+    window_set_wm_state( data, (new_style & WS_MINIMIZE) ? IconicState : NormalState, activate );
     release_win_data( data );
 }
 
@@ -1757,6 +1635,7 @@
 
     if (data->wm_state_serial) return 0; /* another WM_STATE update is pending, wait for it to complete */
     if (data->net_wm_state_serial) return 0; /* another _NET_WM_STATE update is pending, wait for it to complete */
+    if (data->mwm_hints_serial) return 0; /* another MWM_HINT update is pending, wait for it to complete */
     if (data->configure_serial) return 0; /* another config update is pending, wait for it to complete */
 
     new_style = old_style & ~(WS_VISIBLE | WS_MINIMIZE | WS_MAXIMIZE);
@@ -1764,14 +1643,9 @@
     if (data->current_state.wm_state == IconicState) new_style |= WS_MINIMIZE;
     if (data->current_state.net_wm_state & (1 << NET_WM_STATE_MAXIMIZED)) new_style |= WS_MAXIMIZE;
 
-    /* KWin sometimes combines NET_WM_STATE_FULLSCREEN with NET_WM_STATE_MAXIMIZED, but sometimes doesn't.
-     * Don't feed back the maximized state to the Win32 side as it confuses many applications.
-     */
-    if (X11DRV_HasWindowManager( "KWin" )) new_style = (new_style & ~WS_MAXIMIZE) | (old_style & WS_MAXIMIZE);
-
     if ((old_style & WS_MINIMIZE) && !(new_style & WS_MINIMIZE))
     {
-        if ((old_style & WS_CAPTION) == WS_CAPTION && (new_style & WS_MAXIMIZE))
+        if ((old_style & WS_CAPTION) == WS_CAPTION && (data->current_state.net_wm_state & (1 << NET_WM_STATE_MAXIMIZED)))
         {
             if ((old_style & WS_MAXIMIZEBOX) && !(old_style & WS_DISABLED))
             {
@@ -1801,34 +1675,26 @@
 static UINT window_update_client_config( struct x11drv_win_data *data )
 {
     static const UINT fullscreen_mask = (1 << NET_WM_STATE_MAXIMIZED) | (1 << NET_WM_STATE_FULLSCREEN);
-    UINT old_style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE ), new_style, flags;
+    UINT old_style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE ), flags;
     RECT rect, old_rect = data->rects.window, new_rect;
 
     if (!data->managed) return 0; /* unmanaged windows are managed by the Win32 side */
+    if (is_virtual_desktop()) return 0; /* ignore window manager config changes in virtual desktop mode */
     if (data->desired_state.wm_state != NormalState) return 0; /* ignore config changes on invisible/minimized windows */
 
     if (data->wm_state_serial) return 0; /* another WM_STATE update is pending, wait for it to complete */
     if (data->net_wm_state_serial) return 0; /* another _NET_WM_STATE update is pending, wait for it to complete */
+    if (data->mwm_hints_serial) return 0; /* another MWM_HINT update is pending, wait for it to complete */
     if (data->configure_serial) return 0; /* another config update is pending, wait for it to complete */
 
-    new_style = old_style & ~(WS_VISIBLE | WS_MINIMIZE | WS_MAXIMIZE);
-    if (data->current_state.wm_state != WithdrawnState) new_style |= WS_VISIBLE;
-    if (data->current_state.wm_state == IconicState) new_style |= WS_MINIMIZE;
-    if (data->current_state.net_wm_state & (1 << NET_WM_STATE_MAXIMIZED)) new_style |= WS_MAXIMIZE;
-
-    /* KWin sometimes combines NET_WM_STATE_FULLSCREEN with NET_WM_STATE_MAXIMIZED, but sometimes doesn't.
-     * Don't feed back the maximized state to the Win32 side as it confuses many applications.
-     */
-    if (X11DRV_HasWindowManager( "KWin" )) new_style = (new_style & ~WS_MAXIMIZE) | (old_style & WS_MAXIMIZE);
-
     if ((old_style & WS_CAPTION) == WS_CAPTION || !data->is_fullscreen)
     {
-        if ((new_style & WS_MAXIMIZE) && !(old_style & WS_MAXIMIZE))
+        if ((data->current_state.net_wm_state & (1 << NET_WM_STATE_MAXIMIZED)) && !(old_style & WS_MAXIMIZE))
         {
             TRACE( "window %p/%lx is maximized\n", data->hwnd, data->whole_window );
             return SC_MAXIMIZE;
         }
-        if (!(new_style & WS_MAXIMIZE) && (old_style & WS_MAXIMIZE))
+        if (!(data->current_state.net_wm_state & (1 << NET_WM_STATE_MAXIMIZED)) && (old_style & WS_MAXIMIZE))
         {
             TRACE( "window %p/%lx is no longer maximized\n", data->hwnd, data->whole_window );
             return SC_RESTORE;
@@ -1842,12 +1708,6 @@
     if (rect.right == old_rect.right && rect.bottom == old_rect.bottom) flags |= SWP_NOSIZE;
     else if (IsRectEmpty( &rect )) flags |= SWP_NOSIZE;
 
-    /* ignore window position changes if it is still fullscreen and old/new rects intersect */
-    if ((data->current_state.net_wm_state & (1 << NET_WM_STATE_FULLSCREEN)) && (flags & SWP_NOSIZE) &&
-        intersect_rect( &rect, &data->rects.visible, &data->current_state.rect ) &&
-        X11DRV_HasWindowManager( "KWin" ) /* lets keep it KWin specific for now... */)
-        flags |= SWP_NOMOVE;
-
     /* don't sync win32 position for offscreen windows */
     if ((data->is_offscreen = !is_window_rect_mapped( &new_rect ))) flags |= SWP_NOMOVE;
 
@@ -1869,17 +1729,16 @@
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data;
     HWND old_foreground;
-    Window window;
 
     *state_cmd = *config_cmd = 0;
     *foreground = 0;
 
     if (!(old_foreground = NtUserGetForegroundWindow())) old_foreground = NtUserGetDesktopWindow();
-    if (NtUserGetWindowThread( old_foreground, NULL ) == GetCurrentThreadId() && !window_has_pending_wm_state( old_foreground, NormalState ) &&
-        !thread_data->net_active_window_serial && (window = thread_data->current_net_active_window))
+    if (!is_virtual_desktop() && NtUserGetWindowThread( old_foreground, NULL ) == GetCurrentThreadId() &&
+        !window_has_pending_wm_state( old_foreground, NormalState ) && !window_is_reparenting( old_foreground ) &&
+        !thread_data->net_active_window_serial)
     {
-        *foreground = hwnd_from_window( thread_data->display, window );
-        if (*foreground == (HWND)-1) *foreground = NtUserGetDesktopWindow();
+        *foreground = hwnd_from_window( thread_data->display, thread_data->current_state.net_active_window );
         if (*foreground == old_foreground) *foreground = 0;
     }
 
@@ -1902,17 +1761,15 @@
                                  const char *prefix, const char *received, const char *reason )
 {
     if (serial < *expect_serial) reason = "old ";
-    else if (!*expect_serial && !memcmp( current, value, size )) reason = "no-op ";
-
     if (reason)
     {
         WARN( "Ignoring %s%s%s%s\n", prefix, reason, received, expected );
+        memcpy( current, value, size );
         return FALSE;
     }
 
-    if (!*expect_serial) reason = "unexpected ";
-    else if (memcmp( pending, value, size )) reason = "mismatch ";
-
+    if (!*expect_serial && memcmp( current, value, size )) reason = "unexpected ";
+    if (*expect_serial && memcmp( pending, value, size )) reason = "mismatch ";
     if (!reason) TRACE( "%s%s%s\n", prefix, received, expected );
     else
     {
@@ -1936,17 +1793,20 @@
     prefix = wine_dbg_sprintf( "window %p/%lx ", data->hwnd, data->whole_window );
     received = wine_dbg_sprintf( "WM_STATE %#x/%lu", value, serial );
     expected = *expect_serial ? wine_dbg_sprintf( ", expected %#x/%lu", *pending, *expect_serial ) : "";
+    /* ignore Metacity/Mutter transient NormalState during WithdrawnState <-> IconicState transitions */
+    if (value == NormalState && *current + *pending == IconicState) reason = "transient ";
 
     if (!handle_state_change( serial, expect_serial, sizeof(value), &value, desired, pending,
                               current, expected, prefix, received, reason ))
         return;
-    data->current_state.swp_flags = data->pending_state.swp_flags;
+    data->current_state.activate = data->pending_state.activate;
+    data->reparenting = 0;
 
     /* send any pending changes from the desired state */
-    window_set_wm_state( data, data->desired_state.wm_state, data->desired_state.swp_flags );
+    window_set_wm_state( data, data->desired_state.wm_state, data->desired_state.activate );
     window_set_net_wm_state( data, data->desired_state.net_wm_state );
-    window_set_config( data, &data->desired_state.rect, FALSE, data->desired_state.swp_flags );
-    window_set_mwm_hints( data, &data->desired_state.mwm_hints, data->desired_state.swp_flags );
+    window_set_mwm_hints( data, &data->desired_state.mwm_hints );
+    window_set_config( data, data->desired_state.rect, FALSE );
 
     if (data->current_state.wm_state == NormalState) NtUserSetProp( data->hwnd, focus_time_prop, (HANDLE)time );
     else if (!data->wm_state_serial) NtUserRemoveProp( data->hwnd, focus_time_prop );
@@ -1958,8 +1818,6 @@
     unsigned long *expect_serial = &data->net_wm_state_serial;
     const char *expected, *received, *prefix;
 
-    if (data->net_wm_state_hack) pending = desired = &value;
-
     prefix = wine_dbg_sprintf( "window %p/%lx ", data->hwnd, data->whole_window );
     received = wine_dbg_sprintf( "_NET_WM_STATE %#x/%lu", value, serial );
     expected = *expect_serial ? wine_dbg_sprintf( ", expected %#x/%lu", *pending, *expect_serial ) : "";
@@ -1967,13 +1825,12 @@
     if (!handle_state_change( serial, expect_serial, sizeof(value), &value, desired, pending,
                               current, expected, prefix, received, NULL ))
         return;
-    data->net_wm_state_hack = 0;
 
     /* send any pending changes from the desired state */
-    window_set_wm_state( data, data->desired_state.wm_state, data->desired_state.swp_flags );
+    window_set_wm_state( data, data->desired_state.wm_state, data->desired_state.activate );
     window_set_net_wm_state( data, data->desired_state.net_wm_state );
-    window_set_config( data, &data->desired_state.rect, FALSE, data->desired_state.swp_flags );
-    window_set_mwm_hints( data, &data->desired_state.mwm_hints, data->desired_state.swp_flags );
+    window_set_mwm_hints( data, &data->desired_state.mwm_hints );
+    window_set_config( data, data->desired_state.rect, FALSE );
 }
 
 void window_mwm_hints_notify( struct x11drv_win_data *data, unsigned long serial, const MwmHints *value )
@@ -1986,8 +1843,15 @@
     received = wine_dbg_sprintf( "_MOTIF_WM_HINTS %s/%lu", debugstr_mwm_hints(value), serial );
     expected = *expect_serial ? wine_dbg_sprintf( ", expected %s/%lu", debugstr_mwm_hints(pending), *expect_serial ) : "";
 
-    handle_state_change( serial, expect_serial, sizeof(*value), value, desired, pending,
-                         current, expected, prefix, received, NULL );
+    if (!handle_state_change( serial, expect_serial, sizeof(*value), value, desired, pending,
+                              current, expected, prefix, received, NULL ))
+        return;
+
+    /* send any pending changes from the desired state */
+    window_set_wm_state( data, data->desired_state.wm_state, data->desired_state.activate );
+    window_set_net_wm_state( data, data->desired_state.net_wm_state );
+    window_set_mwm_hints( data, &data->desired_state.mwm_hints );
+    window_set_config( data, data->desired_state.rect, FALSE );
 }
 
 void window_configure_notify( struct x11drv_win_data *data, unsigned long serial, const RECT *value )
@@ -2000,34 +1864,71 @@
     received = wine_dbg_sprintf( "config %s/%lu", wine_dbgstr_rect(value), serial );
     expected = *expect_serial ? wine_dbg_sprintf( ", expected %s/%lu", wine_dbgstr_rect(pending), *expect_serial ) : "";
 
-    handle_state_change( serial, expect_serial, sizeof(*value), value, desired, pending,
-                         current, expected, prefix, received, NULL );
+    /* if we've delayed some config we want to continue with it, make sure handle_state_change doesn't overwrite it */
+    if ((*expect_serial || window_needs_config_change_delay( data )) &&
+        serial >= *expect_serial && !EqualRect( desired, pending ))
+    {
+        WARN( "%spreserving delayed config %s\n", prefix, wine_dbgstr_rect(desired) );
+        desired = pending;
+    }
+
+    if (!handle_state_change( serial, expect_serial, sizeof(*value), value, desired, pending,
+                              current, expected, prefix, received, NULL ))
+        return;
+    data->pending_state.above = FALSE; /* allow requesting it again */
+
+    /* send any pending changes from the desired state */
+    window_set_wm_state( data, data->desired_state.wm_state, data->desired_state.activate );
+    window_set_net_wm_state( data, data->desired_state.net_wm_state );
+    window_set_mwm_hints( data, &data->desired_state.mwm_hints );
+    window_set_config( data, data->desired_state.rect, FALSE );
 }
 
 void net_active_window_notify( unsigned long serial, Window value, Time time )
 {
     struct x11drv_thread_data *data = x11drv_thread_data();
-    Window *desired = &data->desired_net_active_window, *pending = &data->pending_net_active_window, *current = &data->current_net_active_window;
-    HWND hwnd = hwnd_from_window( data->display, value ), expect_hwnd = hwnd_from_window( data->display, *pending );
+    Window *desired = &data->desired_state.net_active_window, *pending = &data->pending_state.net_active_window, *current = &data->current_state.net_active_window;
     unsigned long *expect_serial = &data->net_active_window_serial;
     const char *expected, *received;
+    HWND current_hwnd, pending_hwnd;
+
+    current_hwnd = hwnd_from_window( data->display, value );
+    pending_hwnd = hwnd_from_window( data->display, *pending );
+
+    received = wine_dbg_sprintf( "_NET_ACTIVE_WINDOW %p/%lx serial %lu time %lu", current_hwnd, value, serial, time );
+    expected = *expect_serial ? wine_dbg_sprintf( ", expected %p/%lx serial %lu", pending_hwnd, *pending, *expect_serial ) : "";
+    if (!handle_state_change( serial, expect_serial, sizeof(value), &value, desired, pending,
+                              current, expected, "", received, NULL ))
+        return;
+
+    NtUserPostMessage( NtUserGetForegroundWindow(), WM_WINE_WINDOW_STATE_CHANGED, 0, 0 );
+}
+
+Window get_net_active_window( Display *display )
+{
+    unsigned long count, remaining;
+    Window window = None, *value;
+    int format;
+    Atom type;
 
-    received = wine_dbg_sprintf( "_NET_ACTIVE_WINDOW %p/%lx serial %lu time %lu", hwnd, value, serial, time );
-    expected = *expect_serial ? wine_dbg_sprintf( ", expected %p/%lx serial %lu", expect_hwnd, *pending, *expect_serial ) : "";
+    if (!XGetWindowProperty( display, DefaultRootWindow( display ), x11drv_atom(_NET_ACTIVE_WINDOW), 0,
+                             65536 / sizeof(Window), False, XA_WINDOW, &type, &format, &count,
+                             &remaining, (unsigned char **)&value ))
+    {
+        if (type == XA_WINDOW && format == 32) window = *value;
+        XFree( value );
+    }
 
-    if (hwnd == (HWND)-1) value = root_window;
-    handle_state_change( serial, expect_serial, sizeof(value), &value, desired, pending,
-                         current, expected, "", received, NULL );
+    return window;
 }
 
 void net_active_window_init( struct x11drv_thread_data *data )
 {
-    Window window = get_net_active_window( data->display, &data->active_window );
+    Window window = get_net_active_window( data->display );
 
-    if (hwnd_from_window( data->display, window ) == (HWND)-1) window = root_window;
-    data->desired_net_active_window = window;
-    data->pending_net_active_window = window;
-    data->current_net_active_window = window;
+    data->desired_state.net_active_window = window;
+    data->pending_state.net_active_window = window;
+    data->current_state.net_active_window = window;
 }
 
 static BOOL window_set_pending_activate( HWND hwnd )
@@ -2036,7 +1937,7 @@
     BOOL pending;
 
     if (!(data = get_win_data( hwnd ))) return FALSE;
-    if ((pending = !!data->wm_state_serial)) data->pending_state.swp_flags &= ~SWP_NOACTIVATE;
+    if ((pending = !!data->wm_state_serial)) data->pending_state.activate = TRUE;
     release_win_data( data );
 
     return pending;
@@ -2048,9 +1949,9 @@
     Window window;
     XEvent xev;
 
-    if (!is_netwm_supported( x11drv_atom(_NET_ACTIVE_WINDOW) )) return;
+    if (!is_net_supported( x11drv_atom(_NET_ACTIVE_WINDOW) )) return;
     if (!(window = X11DRV_get_whole_window( hwnd ))) return;
-    if (data->pending_net_active_window == window) return;
+    if (data->pending_state.net_active_window == window) return;
     if (window_set_pending_activate( hwnd )) return;
 
     xev.xclient.type = ClientMessage;
@@ -2066,7 +1967,7 @@
     xev.xclient.data.l[3] = 0;
     xev.xclient.data.l[4] = 0;
 
-    data->pending_net_active_window = window;
+    data->pending_state.net_active_window = window;
     data->net_active_window_serial = NextRequest( data->display );
     TRACE( "requesting _NET_ACTIVE_WINDOW %p/%lx serial %lu\n", hwnd, window, data->net_active_window_serial );
     XSendEvent( data->display, DefaultRootWindow( data->display ), False,
@@ -2074,6 +1975,18 @@
     XFlush( data->display );
 }
 
+BOOL window_is_reparenting( HWND hwnd )
+{
+    struct x11drv_win_data *data;
+    BOOL pending;
+
+    if (!(data = get_win_data( hwnd ))) return FALSE;
+    pending = !!data->reparenting;
+    release_win_data( data );
+
+    return pending;
+}
+
 BOOL window_has_pending_wm_state( HWND hwnd, UINT state )
 {
     struct x11drv_win_data *data;
@@ -2098,7 +2011,12 @@
  */
 void make_window_embedded( struct x11drv_win_data *data )
 {
-    window_set_managed( data, TRUE, TRUE );
+    /* the window cannot be mapped before being embedded */
+    window_set_wm_state( data, WithdrawnState, FALSE );
+    if (data->managed) WARN( "Window is already managed, should wait for WithdrawnState\n" );
+    else window_set_managed( data, TRUE );
+    data->embedded = TRUE;
+    window_set_wm_state( data, NormalState, FALSE );
 }
 
 
@@ -2128,6 +2046,7 @@
     }
 
     set_size_hints( data, style );
+    set_mwm_hints( data, style, ex_style );
     update_net_wm_states( data );
 
     new_rect = data->rects.visible;
@@ -2137,8 +2056,7 @@
     if (data->is_offscreen) OffsetRect( &new_rect, window_rect.left - old_rects->window.left,
                                         window_rect.top - old_rects->window.top );
 
-    window_set_config( data, &new_rect, above, swp_flags );
-    set_mwm_hints( data, style, ex_style, swp_flags );
+    window_set_config( data, new_rect, above );
 }
 
 
@@ -2291,19 +2209,11 @@
     XDeleteContext( data->display, client_window, winContext );
 }
 
-static void set_wine_allow_flip( Window client_window, unsigned int allow_flip )
-{
-    if (client_window) XChangeProperty( gdi_display, client_window, x11drv_atom(_WINE_ALLOW_FLIP), XA_CARDINAL, 32,
-                                        PropModeReplace, (unsigned char *)&allow_flip, sizeof(allow_flip) / 4 );
-}
-
 /**********************************************************************
  *		detach_client_window
  */
 void detach_client_window( struct x11drv_win_data *data, Window client_window )
 {
-    if (client_window) set_wine_allow_flip( client_window, 0 );
-
     if (data->client_window != client_window || !client_window) return;
 
     TRACE( "%p/%lx detaching client window %lx\n", data->hwnd, data->whole_window, client_window );
@@ -2335,7 +2245,6 @@
         XReparentWindow( gdi_display, client_window, data->whole_window, data->rects.client.left - data->rects.visible.left,
                          data->rects.client.top - data->rects.visible.top );
     }
-    set_wine_allow_flip( client_window, 1 );
 
     data->client_window = client_window;
 }
@@ -2367,12 +2276,13 @@
 /**********************************************************************
  *		create_client_window
  */
-Window create_client_window( HWND hwnd, RECT client_rect, const XVisualInfo *visual, Colormap colormap )
+Window create_client_window( HWND hwnd, const XVisualInfo *visual, Colormap colormap )
 {
     struct x11drv_win_data *data = get_win_data( hwnd );
     XSetWindowAttributes attr;
     Window ret;
     int x, y, cx, cy;
+    RECT client_rect;
 
     if (!data)
     {
@@ -2394,6 +2304,8 @@
 
     x = data->rects.client.left - data->rects.visible.left;
     y = data->rects.client.top - data->rects.visible.top;
+
+    NtUserGetClientRect( hwnd, &client_rect, NtUserGetDpiForWindow( hwnd ) );
     cx = min( max( 1, client_rect.right - client_rect.left ), 65535 );
     cy = min( max( 1, client_rect.bottom - client_rect.top ), 65535 );
 
@@ -2405,7 +2317,6 @@
                                                CWBackingStore | CWColormap | CWBorderPixel, &attr );
     if (data->client_window)
     {
-        set_wine_allow_flip( data->client_window, 1 );
         XMapWindow( gdi_display, data->client_window );
         if (data->whole_window)
         {
@@ -2419,29 +2330,6 @@
 }
 
 
-void set_gamescope_overlay_prop( Display *display, Window window, HWND hwnd )
-{
-    static const WCHAR class_name[] = {'X','a','l','i','a','O','v','e','r','l','a','y','B','o','x',0};
-    WCHAR class_name_buf[16];
-    UNICODE_STRING class_name_str;
-    INT ret;
-
-    class_name_str.Buffer = class_name_buf;
-    class_name_str.MaximumLength = sizeof(class_name_buf);
-
-    ret = NtUserGetClassName( hwnd, FALSE, &class_name_str );
-
-    if (ret && !wcscmp( class_name_buf, class_name )) {
-        DWORD one = 1;
-
-        TRACE( "setting GAMESCOPE_XALIA_OVERLAY on window %lx, hwnd %p\n", window, hwnd );
-
-        XChangeProperty( display, window, x11drv_atom(GAMESCOPE_XALIA_OVERLAY), XA_CARDINAL, 32,
-                         PropModeReplace, (unsigned char *)&one, sizeof(one) / 4 );
-    }
-}
-
-
 /**********************************************************************
  *		create_whole_window
  *
@@ -2449,7 +2337,6 @@
  */
 static void create_whole_window( struct x11drv_win_data *data )
 {
-    unsigned long xhwnd = (UINT_PTR)data->hwnd;
     int cx, cy, mask;
     XSetWindowAttributes attr;
     WCHAR text[1024];
@@ -2470,7 +2357,7 @@
     if (data->vis.visualid != default_visual.visualid)
         data->whole_colormap = XCreateColormap( data->display, root_window, data->vis.visual, AllocNone );
 
-    data->managed = managed_mode;
+    data->managed = is_window_managed( data->hwnd, SWP_NOACTIVATE, FALSE );
     mask = get_window_attributes( data, &attr ) | CWOverrideRedirect;
     attr.override_redirect = !data->managed;
 
@@ -2484,25 +2371,17 @@
                                         cx, cy, 0, data->vis.depth, InputOutput,
                                         data->vis.visual, mask, &attr );
     if (!data->whole_window) goto done;
-    XChangeProperty( data->display, data->whole_window, x11drv_atom(_WINE_HWND), XA_CARDINAL, 32,
-                     PropModeReplace, (unsigned char *)&xhwnd, 1 );
-    set_wine_allow_flip( data->whole_window, 0 );
-
     SetRect( &data->current_state.rect, pos.x, pos.y, pos.x + cx, pos.y + cy );
     data->pending_state.rect = data->current_state.rect;
     data->desired_state.rect = data->current_state.rect;
 
-    /* Set override-redirect attribute only after window creation, Mutter gets confused otherwise */
-    window_set_managed( data, is_window_managed( data->hwnd, SWP_NOACTIVATE, FALSE ), FALSE );
     x11drv_xinput2_enable( data->display, data->whole_window );
     set_initial_wm_hints( data->display, data->whole_window );
-    set_wm_hints( data, 0 );
+    set_wm_hints( data );
 
     XSaveContext( data->display, data->whole_window, winContext, (char *)data->hwnd );
     NtUserSetProp( data->hwnd, whole_window_prop, (HANDLE)data->whole_window );
 
-    set_gamescope_overlay_prop( data->display, data->whole_window, data->hwnd );
-
     /* set the window text */
     if (!NtUserInternalGetWindowText( data->hwnd, text, ARRAY_SIZE( text ))) text[0] = 0;
     sync_window_text( data->display, data->whole_window, text );
@@ -2550,14 +2429,15 @@
     data->whole_window = data->client_window = 0;
     data->whole_colormap = 0;
     data->managed = FALSE;
-    data->embedded = FALSE;
 
     memset( &data->desired_state, 0, sizeof(data->desired_state) );
     memset( &data->pending_state, 0, sizeof(data->pending_state) );
     memset( &data->current_state, 0, sizeof(data->current_state) );
     data->wm_state_serial = 0;
     data->net_wm_state_serial = 0;
+    data->mwm_hints_serial = 0;
     data->configure_serial = 0;
+    data->reparenting = 0;
 
     if (data->xic)
     {
@@ -2637,7 +2517,7 @@
     if (!(data = get_win_data( hwnd ))) return;
     if (!data->whole_window) goto done;
 
-    if (offset == GWL_STYLE && (changed & WS_DISABLED)) set_wm_hints( data, 0 );
+    if (offset == GWL_STYLE && (changed & WS_DISABLED)) set_wm_hints( data );
 
     if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED)) /* changing WS_EX_LAYERED resets attributes */
     {
@@ -2670,7 +2550,6 @@
     XDeleteContext( gdi_display, (XID)hwnd, win_data_context );
     release_win_data( data );
     free( data );
-    destroy_gl_drawable( hwnd );
 }
 
 
@@ -2696,17 +2575,16 @@
 /* initialize the desktop window id in the desktop manager process */
 static BOOL create_desktop_win_data( Window win, HWND hwnd )
 {
-    static const UINT fullscreen_mask = (1 << NET_WM_STATE_MAXIMIZED) | (1 << NET_WM_STATE_FULLSCREEN);
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     Display *display = thread_data->display;
     struct x11drv_win_data *data;
 
     if (!(data = alloc_win_data( display, hwnd ))) return FALSE;
     data->whole_window = win;
-    window_set_managed( data, TRUE, FALSE );
+    window_set_managed( data, TRUE );
     NtUserSetProp( data->hwnd, whole_window_prop, (HANDLE)win );
     set_initial_wm_hints( display, win );
-    if (is_desktop_fullscreen()) window_set_net_wm_state( data, fullscreen_mask );
+    if (is_desktop_fullscreen()) window_set_net_wm_state( data, (1 << NET_WM_STATE_FULLSCREEN) );
     release_win_data( data );
     if (thread_data->clip_window) XReparentWindow( display, thread_data->clip_window, win, 0, 0 );
     return TRUE;
@@ -2755,7 +2633,7 @@
     else
     {
         Window win = (Window)NtUserGetProp( hwnd, whole_window_prop );
-        if (win && win != root_window) X11DRV_init_desktop( win );
+        if (win && win != root_window) X11DRV_init_desktop( win, width, height );
     }
 }
 
@@ -2802,22 +2680,9 @@
 {
     if (hwnd == NtUserGetDesktopWindow())
     {
-        static const WCHAR winsta0[] = {'W','i','n','S','t','a','0',0};
         struct x11drv_thread_data *data = x11drv_init_thread_data();
-        WCHAR winstation_name[64];
         XSetWindowAttributes attr;
 
-        if (NtUserGetObjectInformation( NtUserGetProcessWindowStation(), UOI_NAME, winstation_name,
-                                        sizeof(winstation_name), NULL ))
-        {
-            TRACE( "winstation name %s.\n", debugstr_w(winstation_name) );
-            if (!wcscmp( winstation_name, winsta0 ))
-            {
-                /* listen to raw xinput event in the desktop window thread */
-                data->xinput2_rawinput = TRUE;
-                x11drv_xinput2_enable( data->display, DefaultRootWindow( data->display ) );
-            }
-        }
         /* create the cursor clipping window */
         attr.override_redirect = TRUE;
         attr.event_mask = StructureNotifyMask | FocusChangeMask;
@@ -2894,11 +2759,6 @@
 
     if (NtUserGetWindowThread( hwnd, NULL ) != GetCurrentThreadId()) return NULL;
 
-    /* Recreate the parent gl_drawable now that we know there are child windows
-     * that will need clipping support.
-     */
-    sync_gl_drawable( parent, TRUE );
-
     display = thread_init_display();
     init_clip_window();  /* make sure the clip window is initialized in this thread */
 
@@ -2959,7 +2819,7 @@
 
     if ((data = get_win_data( hwnd )))
     {
-        if ((ret = data->embedded)) window_set_wm_state( data, WithdrawnState, 0 );
+        if ((ret = data->embedded)) window_set_wm_state( data, WithdrawnState, FALSE );
         release_win_data( data );
     }
 
@@ -3073,7 +2933,6 @@
 {
     struct x11drv_escape_set_drawable escape;
     struct x11drv_win_data *data;
-    int emulated_mode_offset;
 
     escape.code = X11DRV_SET_DRAWABLE;
     escape.mode = IncludeInferiors;
@@ -3088,12 +2947,6 @@
     {
         escape.drawable = data->whole_window;
         escape.visual = data->vis;
-
-        if ((emulated_mode_offset = data->rects.window.left - data->rects.visible.left) > 0)
-            OffsetRect( &escape.dc_rect, emulated_mode_offset, 0 );
-        if ((emulated_mode_offset = data->rects.window.top - data->rects.visible.top) > 0)
-            OffsetRect( &escape.dc_rect, 0, emulated_mode_offset );
-
         /* special case: when repainting the root window, clip out top-level windows */
         if (top == hwnd && data->whole_window == root_window) escape.mode = ClipByChildren;
         release_win_data( data );
@@ -3220,12 +3073,6 @@
     }
 done:
     release_win_data( data );
-    set_gl_drawable_parent( hwnd, parent );
-
-    /* Recreate the parent gl_drawable now that we know there are child windows
-     * that will need clipping support.
-     */
-    sync_gl_drawable( parent, TRUE );
 
     fetch_icon_data( hwnd, 0, 0 );
 }
@@ -3290,7 +3137,7 @@
         release_win_data( data );
     }
 
-    *style_mask = ex_style = 0;
+    *style_mask = *ex_style_mask = 0;
     if (decor & MWM_DECOR_TITLE) *style_mask |= WS_CAPTION;
     if (decor & MWM_DECOR_BORDER)
     {
@@ -3301,21 +3148,6 @@
     return TRUE;
 }
 
-static int use_force_below_hack(void)
-{
-    static int cached = -1;
-
-    if (cached == -1)
-    {
-        char const *sgi = getenv( "SteamGameId" );
-
-        cached = sgi && (
-                 !strcmp(sgi, "1293830")
-                 || !strcmp(sgi, "1551360")
-                 );
-    }
-    return cached;
-}
 
 /***********************************************************************
  *		WindowPosChanged   (X11DRV.@)
@@ -3326,12 +3158,10 @@
     struct x11drv_win_data *data;
     UINT new_style = NtUserGetWindowLongW( hwnd, GWL_STYLE ), old_style;
     struct window_rects old_rects;
-    BOOL was_fullscreen;
-
-    set_surface_window_rects( surface, new_rects );
+    BOOL was_fullscreen, activate = !(swp_flags & SWP_NOACTIVATE);
 
     if (!(data = get_win_data( hwnd ))) return;
-    if (is_window_managed( hwnd, swp_flags, fullscreen )) window_set_managed( data, TRUE, data->embedded );
+    if (is_window_managed( hwnd, swp_flags, fullscreen )) window_set_managed( data, TRUE );
 
     old_style = new_style & ~(WS_VISIBLE | WS_MINIMIZE | WS_MAXIMIZE);
     if (data->desired_state.wm_state != WithdrawnState) old_style |= WS_VISIBLE;
@@ -3343,47 +3173,33 @@
     data->rects = *new_rects;
     data->is_fullscreen = fullscreen;
 
-    TRACE( "win %p/%lx new_rects %s style %08x flags %08x fullscreen %u\n", hwnd, data->whole_window,
-           debugstr_window_rects(new_rects), new_style, swp_flags, fullscreen );
+    TRACE( "win %p/%lx new_rects %s style %08x flags %08x\n", hwnd, data->whole_window,
+           debugstr_window_rects(new_rects), new_style, swp_flags );
 
     XFlush( gdi_display );  /* make sure painting is done before we move the window */
 
-    if (use_force_below_hack())
-    {
-        if (insert_after != HWND_BOTTOM && insert_after != HWND_NOTOPMOST && insert_after != HWND_TOP && insert_after != HWND_TOPMOST)
-        {
-            WARN( "%p/%#lx setting force_below_hack.\n", hwnd, data->whole_window );
-            data->force_below_hack = 1;
-        }
-    }
-
     sync_client_position( data, &old_rects );
 
     if (!data->whole_window)
     {
         release_win_data( data );
-        sync_gl_drawable( hwnd, FALSE );
         return;
     }
 
-    release_win_data( data );
-
-    sync_gl_drawable( hwnd, FALSE );
     if (old_style & WS_VISIBLE)
     {
         if (((swp_flags & SWP_HIDEWINDOW) && !(new_style & WS_VISIBLE)) ||
             (!(new_style & WS_MINIMIZE) && !is_window_rect_mapped( &new_rects->window ) && is_window_rect_mapped( &old_rects.window )))
         {
-            unmap_window( hwnd );
+            window_set_wm_state( data, WithdrawnState, FALSE );
+            release_win_data( data );
             if (was_fullscreen) NtUserClipCursor( NULL );
+            if (!(data = get_win_data( hwnd ))) return;
         }
     }
 
-    if (!(data = get_win_data( hwnd ))) return;
-
     /* don't change position if we are about to minimize or maximize a managed window */
-    if (!(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE)))
-         || (!(new_style & WS_MINIMIZE) && X11DRV_HasWindowManager( "steamcompmgr" )))
+    if (!(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
     {
         sync_window_position( data, swp_flags, &old_rects );
 #ifdef HAVE_LIBXSHAPE
@@ -3415,17 +3231,17 @@
                 needs_map = data->layered || IsRectEmpty( &new_rects->window );
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
-            if (needs_map) map_window( hwnd, new_style, swp_flags );
+            if (needs_map) map_window( hwnd, new_style, activate );
             return;
         }
         else if ((swp_flags & SWP_STATECHANGED) && ((old_style ^ new_style) & WS_MINIMIZE))
         {
-            window_set_wm_state( data, (new_style & WS_MINIMIZE) ? IconicState : NormalState, swp_flags );
+            window_set_wm_state( data, (new_style & WS_MINIMIZE) ? IconicState : NormalState, activate );
             update_net_wm_states( data );
         }
         else
         {
-            if (swp_flags & (SWP_FRAMECHANGED|SWP_STATECHANGED)) set_wm_hints( data, swp_flags );
+            if (swp_flags & (SWP_FRAMECHANGED|SWP_STATECHANGED)) set_wm_hints( data );
             update_net_wm_states( data );
         }
     }
@@ -3516,7 +3332,7 @@
     else fetch_icon_data( hwnd, 0, icon );
 
     if (!(data = get_win_data( hwnd ))) return;
-    set_wm_hints( data, 0 );
+    set_wm_hints( data );
 done:
     release_win_data( data );
 }
@@ -3568,7 +3384,7 @@
                 ((style & WS_MINIMIZE) || is_window_rect_mapped( &data->rects.window )))
             {
                 release_win_data( data );
-                map_window( hwnd, style, 0 );
+                map_window( hwnd, style, TRUE );
                 return;
             }
         }
@@ -3590,12 +3406,16 @@
 /***********************************************************************
  *              UpdateLayeredWindow   (X11DRV.@)
  */
-void X11DRV_UpdateLayeredWindow( HWND hwnd, UINT flags )
+void X11DRV_UpdateLayeredWindow( HWND hwnd, BYTE alpha, UINT flags )
 {
     struct x11drv_win_data *data;
     BOOL mapped;
 
     if (!(data = get_win_data( hwnd ))) return;
+
+    if (data->whole_window)
+        sync_window_opacity( data->display, data->whole_window, alpha, flags );
+
     mapped = data->desired_state.wm_state != WithdrawnState;
     release_win_data( data );
 
@@ -3605,7 +3425,7 @@
         DWORD style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
 
         if ((style & WS_VISIBLE) && ((style & WS_MINIMIZE) || is_window_rect_mapped( &data->rects.window )))
-            map_window( hwnd, style, 0 );
+            map_window( hwnd, style, TRUE );
     }
 }
 
@@ -3651,8 +3471,6 @@
 {
     struct x11drv_win_data *data;
 
-    TRACE( "window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp );
-
     switch(msg)
     {
     case WM_X11DRV_UPDATE_CLIPBOARD:
@@ -3678,9 +3496,9 @@
 
 
 /***********************************************************************
- *              is_netwm_supported
+ *              is_net_supported
  */
-BOOL is_netwm_supported( Atom atom )
+BOOL is_net_supported( Atom atom )
 {
     struct x11drv_thread_data *data = x11drv_thread_data();
     BOOL supported;
@@ -3772,7 +3590,7 @@
 
     if (NtUserGetWindowLongW( hwnd, GWL_STYLE ) & WS_MAXIMIZE) goto failed;
 
-    if (!is_netwm_supported( x11drv_atom(_NET_WM_MOVERESIZE) ))
+    if (!is_net_supported( x11drv_atom(_NET_WM_MOVERESIZE) ))
     {
         TRACE( "_NET_WM_MOVERESIZE not supported\n" );
         goto failed;
@@ -3829,96 +3647,10 @@
     for (i = 0; i < NB_NET_WM_STATES; i++)
     {
         Atom atom = X11DRV_Atoms[net_wm_state_atoms[i] - FIRST_XATOM];
-        if (is_netwm_supported( atom )) data->net_wm_state_mask |= (1 << i);
+        if (is_net_supported( atom )) data->net_wm_state_mask |= (1 << i);
     }
 }
 
-static Window get_net_supporting_wm_check( Display *display, Window window )
-{
-    unsigned long count, remaining;
-    Window *tmp, support = None;
-    int format;
-    Atom type;
-
-    if (!XGetWindowProperty( display, window, x11drv_atom(_NET_SUPPORTING_WM_CHECK), 0, 65536 / sizeof(CARD32),
-                             False, XA_WINDOW, &type, &format, &count, &remaining, (unsigned char **)&tmp ) && tmp)
-    {
-        support = *tmp;
-        free( tmp );
-    }
-
-    return support;
-}
-
-
-BOOL get_window_net_wm_name( Display *display, Window window, char **name )
-{
-    unsigned long count, remaining;
-    int format, ret;
-    Atom type;
-
-    *name = NULL;
-    X11DRV_expect_error( display, host_window_error, NULL );
-    ret = XGetWindowProperty( display, window, x11drv_atom(_NET_WM_NAME), 0, 65536 / sizeof(CARD32), False, x11drv_atom(UTF8_STRING),
-                              &type, &format, &count, &remaining, (unsigned char **)name );
-    return !X11DRV_check_error() && !ret && *name;
-}
-
-static BOOL get_window_wm_name( Display *display, Window window, char **name )
-{
-    unsigned long count, remaining;
-    int format, ret;
-    Atom type;
-
-    *name = NULL;
-    X11DRV_expect_error( display, host_window_error, NULL );
-    ret = XGetWindowProperty( display, window, x11drv_atom(WM_NAME), 0, 65536 / sizeof(CARD32), False, XA_STRING,
-                              &type, &format, &count, &remaining, (unsigned char **)name );
-    return !X11DRV_check_error() && !ret && *name;
-}
-
-BOOL get_window_name( Display *display, Window window, char **name )
-{
-    return get_window_net_wm_name( display, window, name ) || get_window_wm_name( display, window, name );
-}
-
-void net_supporting_wm_check_init( struct x11drv_thread_data *data )
-{
-    Window window = None, other;
-
-    if (!(window = get_net_supporting_wm_check( data->display, DefaultRootWindow( data->display ) ))) return;
-
-    /* the window itself must have the property set too */
-    X11DRV_expect_error( data->display, host_window_error, NULL );
-    other = get_net_supporting_wm_check( data->display, window );
-    if (X11DRV_check_error() || window != other) WARN( "Invalid _NET_SUPPORTING_WM_CHECK window\n" );
-    else if (get_window_name( data->display, window, &data->window_manager ))
-    {
-        char const *sgi = getenv( "SteamGameId" );
-
-        if (!strcmp( data->window_manager, "GNOME Shell" )) strcpy( data->window_manager, "Mutter" );
-        TRACE( "Detected window manager: %s\n", debugstr_a(data->window_manager) );
-
-        /* Street Fighter V expects a certain sequence of window resizes
-           or gets stuck on startup. The AdjustWindowRect / WM_NCCALCSIZE
-           hacks confuse it completely, so let's disable them */
-        if (sgi && !strcmp(sgi, "310950"))
-        {
-            XFree( data->window_manager );
-            data->window_manager = NULL;
-        }
-    }
-}
-
-BOOL X11DRV_HasWindowManager( const char *name )
-{
-    struct x11drv_thread_data *data = x11drv_init_thread_data();
-    int opcode, event, error;
-
-    if (!strcmp( name, "xwayland" )) return XQueryExtension( gdi_display, "XWAYLAND", &opcode, &event, &error );
-    return data->window_manager && !strcmp( data->window_manager, name );
-}
-
 void init_win_context(void)
 {
     init_recursive_mutex( &win_data_mutex );
diff -urN proton_wine10.0/dlls/winex11.drv/wintab.c wine-10.15/dlls/winex11.drv/wintab.c
--- proton_wine10.0/dlls/winex11.drv/wintab.c	2025-11-16 17:00:20.249403225 +0800
+++ wine-10.15/dlls/winex11.drv/wintab.c	2025-09-13 03:36:38.000000000 +0800
@@ -35,6 +35,11 @@
 #include "wine/debug.h"
 #include "wintab.h"
 
+#ifdef SONAME_LIBXI
+
+#include <X11/Xlib.h>
+#include <X11/extensions/XInput.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(wintab32);
 
 #define WT_MAX_NAME_LEN 256
@@ -252,12 +257,6 @@
         ROTATION pkRotation; /* 1.1 */
 } WTPACKET, *LPWTPACKET;
 
-
-#ifdef SONAME_LIBXI
-
-#include <X11/Xlib.h>
-#include <X11/extensions/XInput.h>
-
 static int           motion_type;
 static int           button_press_type;
 static int           button_release_type;
@@ -843,7 +842,7 @@
             return i;
         }
 
-    ERR("Could not map device id %d to a cursor\n", (int) deviceid);
+    ERR("Could not map device id %d to a cursor\n",  deviceid);
     return -1;
 }
 
diff -urN proton_wine10.0/dlls/winex11.drv/x11drv.h wine-10.15/dlls/winex11.drv/x11drv.h
--- proton_wine10.0/dlls/winex11.drv/x11drv.h	2025-11-16 17:00:20.250403198 +0800
+++ wine-10.15/dlls/winex11.drv/x11drv.h	2025-09-13 03:36:38.000000000 +0800
@@ -163,8 +163,6 @@
 extern BOOL X11DRV_ExtFloodFill( PHYSDEV dev, INT x, INT y, COLORREF color, UINT fillType );
 extern BOOL X11DRV_FillPath( PHYSDEV dev );
 extern BOOL X11DRV_GetDeviceGammaRamp( PHYSDEV dev, LPVOID ramp );
-extern BOOL fs_hack_get_gamma_ramp( PHYSDEV dev, LPVOID ramp );
-extern BOOL X11DRV_GetICMProfile( PHYSDEV dev, BOOL allow_default, LPDWORD size, LPWSTR filename );
 extern DWORD X11DRV_GetImage( PHYSDEV dev, BITMAPINFO *info,
                               struct gdi_image_bits *bits, struct bitblt_coords *src );
 extern COLORREF X11DRV_GetNearestColor( PHYSDEV dev, COLORREF color );
@@ -190,9 +188,8 @@
 extern HPEN X11DRV_SelectPen( PHYSDEV dev, HPEN hpen, const struct brush_pattern *pattern );
 extern COLORREF X11DRV_SetDCBrushColor( PHYSDEV dev, COLORREF crColor );
 extern COLORREF X11DRV_SetDCPenColor( PHYSDEV dev, COLORREF crColor );
-extern void X11DRV_SetDeviceClipping( PHYSDEV dev, HRGN rgn, HRGN monitor_rgn );
+extern void X11DRV_SetDeviceClipping( PHYSDEV dev, HRGN rgn );
 extern BOOL X11DRV_SetDeviceGammaRamp( PHYSDEV dev, LPVOID ramp );
-extern BOOL fs_hack_set_gamma_ramp( PHYSDEV dev, LPVOID ramp );
 extern COLORREF X11DRV_SetPixel( PHYSDEV dev, INT x, INT y, COLORREF color );
 extern BOOL X11DRV_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *dst,
                                PHYSDEV src_dev, struct bitblt_coords *src, DWORD rop );
@@ -212,6 +209,7 @@
 extern void X11DRV_DestroyCursorIcon( HCURSOR handle );
 extern void X11DRV_SetCursor( HWND hwnd, HCURSOR handle );
 extern BOOL X11DRV_SetCursorPos( INT x, INT y );
+extern BOOL X11DRV_GetCursorPos( LPPOINT pos );
 extern BOOL X11DRV_ClipCursor( const RECT *clip, BOOL reset );
 extern void X11DRV_SystrayDockInit( HWND systray );
 extern BOOL X11DRV_SystrayDockInsert( HWND owner, UINT cx, UINT cy, void *icon );
@@ -224,7 +222,6 @@
 extern LRESULT X11DRV_DesktopWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp );
 extern void X11DRV_DestroyWindow( HWND hwnd );
 extern void X11DRV_FlashWindowEx( PFLASHWINFO pfinfo );
-extern BOOL X11DRV_HasWindowManager( const char *name );
 extern void X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
                           const RECT *top_rect, DWORD flags );
 extern void X11DRV_ReleaseDC( HWND hwnd, HDC hdc );
@@ -242,7 +239,7 @@
 extern LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos );
 extern LRESULT X11DRV_ClipboardWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp );
 extern void X11DRV_UpdateClipboard(void);
-extern void X11DRV_UpdateLayeredWindow( HWND hwnd, UINT flags );
+extern void X11DRV_UpdateLayeredWindow( HWND hwnd, BYTE alpha, UINT flags );
 extern LRESULT X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp );
 extern BOOL X11DRV_WindowPosChanging( HWND hwnd, UINT swp_flags, BOOL shaped, const struct window_rects *rects );
 extern BOOL X11DRV_GetWindowStyleMasks( HWND hwnd, UINT style, UINT ex_style, UINT *style_mask, UINT *ex_style_mask );
@@ -285,7 +282,7 @@
 extern BOOL shape_layered_windows;
 extern const struct gdi_dc_funcs *X11DRV_XRender_Init(void);
 
-extern struct opengl_funcs *get_glx_driver(UINT);
+extern UINT X11DRV_OpenGLInit( UINT, const struct opengl_funcs *, const struct opengl_driver_funcs ** );
 extern UINT X11DRV_VulkanInit( UINT, void *, const struct vulkan_driver_funcs ** );
 
 extern struct format_entry *import_xdnd_selection( Display *display, Window win, Atom selection,
@@ -357,11 +354,11 @@
     RECT                     dc_rect;      /* DC rectangle relative to drawable */
 };
 
-extern BOOL enable_fullscreen_hack( HWND hwnd, BOOL check_gamma );
-extern BOOL needs_offscreen_rendering( HWND hwnd, BOOL known_child, BOOL check_gamma );
+extern BOOL needs_offscreen_rendering( HWND hwnd );
 extern void set_dc_drawable( HDC hdc, Drawable drawable, const RECT *rect, int mode );
 extern Drawable get_dc_drawable( HDC hdc, RECT *rect );
 extern HRGN get_dc_monitor_region( HWND hwnd, HDC hdc );
+extern Window x11drv_client_surface_create( HWND hwnd, const XVisualInfo *visual, Colormap colormap, struct client_surface **client );
 
 /**************************************************************************
  * X11 USER driver
@@ -385,6 +382,11 @@
 extern POINT host_window_map_point( struct host_window *win, int x, int y );
 extern struct host_window *get_host_window( Window window, BOOL create );
 
+struct display_state
+{
+    Window net_active_window;
+};
+
 struct x11drv_thread_data
 {
     Display *display;
@@ -402,19 +404,16 @@
     Atom    *net_supported;        /* list of _NET_SUPPORTED atoms */
     int      net_supported_count;  /* number of _NET_SUPPORTED atoms */
     UINT     net_wm_state_mask;    /* mask of supported _NET_WM_STATE *bits */
-    char    *window_manager;       /* name of the supporting window manager */
-    char    *active_window;        /* name of the current active window */
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     XIValuatorClassInfo x_valuator;
     XIValuatorClassInfo y_valuator;
     int      xinput2_pointer;      /* XInput2 master pointer device id */
-    int      xinput2_rawinput;     /* XInput2 rawinput-only thread */
 #endif /* HAVE_X11_EXTENSIONS_XINPUT2_H */
 
-    Window        desired_net_active_window;    /* active window tracking the desired / win32 state */
-    Window        pending_net_active_window;    /* active window tracking the pending / requested state */
-    Window        current_net_active_window;    /* active window tracking the current X11 state */
-    unsigned long net_active_window_serial;     /* serial of last pending _NET_ACTIVE_WINDOW request */
+    struct display_state desired_state;       /* display state tracking the desired / win32 state */
+    struct display_state pending_state;       /* display state tracking the pending / requested state */
+    struct display_state current_state;       /* display state tracking the current X11 state */
+    unsigned long net_active_window_serial;   /* serial of last pending _NET_ACTIVE_WINDOW request */
 };
 
 extern struct x11drv_thread_data *x11drv_init_thread_data(void);
@@ -455,22 +454,20 @@
 extern unsigned int screen_bpp;
 extern BOOL usexrandr;
 extern BOOL usexvidmode;
+extern BOOL use_egl;
 extern BOOL use_take_focus;
 extern BOOL use_primary_selection;
 extern BOOL use_system_cursors;
 extern BOOL grab_fullscreen;
 extern BOOL usexcomposite;
-extern BOOL use_xfixes;
 extern BOOL managed_mode;
 extern BOOL private_color_map;
 extern int primary_monitor;
 extern int copy_default_colors;
 extern int alloc_system_colors;
 extern int xrender_error_base;
-extern int xfixes_event_base;
 extern char *process_name;
 extern Display *clipboard_display;
-extern HANDLE steam_overlay_event;
 
 /* atoms */
 
@@ -493,7 +490,6 @@
     XATOM_RAW_CAP_HEIGHT,
     XATOM_WM_PROTOCOLS,
     XATOM_WM_DELETE_WINDOW,
-    XATOM_WM_NAME,
     XATOM_WM_STATE,
     XATOM_WM_TAKE_FOCUS,
     XATOM_DndProtocol,
@@ -505,11 +501,9 @@
     XATOM__NET_STARTUP_INFO_BEGIN,
     XATOM__NET_STARTUP_INFO,
     XATOM__NET_SUPPORTED,
-    XATOM__NET_SUPPORTING_WM_CHECK,
     XATOM__NET_SYSTEM_TRAY_OPCODE,
     XATOM__NET_SYSTEM_TRAY_S0,
     XATOM__NET_SYSTEM_TRAY_VISUAL,
-    XATOM__NET_WM_BYPASS_COMPOSITOR,
     XATOM__NET_WM_FULLSCREEN_MONITORS,
     XATOM__NET_WM_ICON,
     XATOM__NET_WM_MOVERESIZE,
@@ -518,7 +512,6 @@
     XATOM__NET_WM_PING,
     XATOM__NET_WM_STATE,
     XATOM__NET_WM_STATE_ABOVE,
-    XATOM__NET_WM_STATE_BELOW,
     XATOM__NET_WM_STATE_DEMANDS_ATTENTION,
     XATOM__NET_WM_STATE_FULLSCREEN,
     XATOM__NET_WM_STATE_MAXIMIZED_HORZ,
@@ -534,12 +527,8 @@
     XATOM__NET_WM_WINDOW_TYPE_UTILITY,
     XATOM__NET_WORKAREA,
     XATOM__GTK_WORKAREAS_D0,
-    XATOM__WINE_HWND,
     XATOM__XEMBED,
     XATOM__XEMBED_INFO,
-    XATOM__WINE_ALLOW_FLIP,
-    XATOM__WINE_HWND_STYLE,
-    XATOM__WINE_HWND_EXSTYLE,
     XATOM_XdndAware,
     XATOM_XdndEnter,
     XATOM_XdndPosition,
@@ -572,8 +561,6 @@
     XATOM_text_rtf,
     XATOM_text_richtext,
     XATOM_text_uri_list,
-    XATOM_GAMESCOPE_DISPLAY_EDID_PATH,
-    XATOM_GAMESCOPE_XALIA_OVERLAY,
     NB_XATOMS
 };
 
@@ -627,20 +614,27 @@
     KDE_NET_WM_STATE_SKIP_SWITCHER,
     NET_WM_STATE_FULLSCREEN,
     NET_WM_STATE_ABOVE,
-    NET_WM_STATE_BELOW,
     NET_WM_STATE_MAXIMIZED,
     NET_WM_STATE_SKIP_PAGER,
     NET_WM_STATE_SKIP_TASKBAR,
     NB_NET_WM_STATES
 };
 
+struct monitor_indices
+{
+    unsigned int generation;
+    long indices[4];
+};
+
 struct window_state
 {
-    UINT swp_flags;
     UINT wm_state;
+    BOOL activate;
     UINT net_wm_state;
     MwmHints mwm_hints;
+    struct monitor_indices monitors;
     RECT rect;
+    BOOL above;
 };
 
 /* x11drv private window data */
@@ -662,12 +656,10 @@
     UINT        use_alpha : 1;  /* does window use an alpha channel? */
     UINT        skip_taskbar : 1; /* does window should be deleted from taskbar */
     UINT        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
-    UINT        net_wm_fullscreen_monitors_set : 1; /* is _NET_WM_FULLSCREEN_MONITORS set */
     UINT        is_fullscreen : 1; /* is the window visible rect fullscreen */
     UINT        is_offscreen : 1; /* has been moved offscreen by the window manager */
     UINT        parent_invalid : 1; /* is the parent host window possibly invalid */
-    UINT        net_wm_state_hack : 1; /* hacking around KWin sticky fullscreen windows */
-    UINT        force_below_hack : 1; /* hacking fullscreen black window which is supposed to be order after another window */
+    UINT        reparenting : 1; /* window is being reparented, likely from a decoration change */
     Window      embedder;       /* window id of embedder */
     Pixmap         icon_pixmap;
     Pixmap         icon_mask;
@@ -690,12 +682,7 @@
 extern Window X11DRV_get_whole_window( HWND hwnd );
 extern Window get_dummy_parent(void);
 
-extern void set_surface_window_rects( struct window_surface *window_surface, const struct window_rects *rects );
-extern void sync_gl_drawable( HWND hwnd, BOOL known_child );
-extern void set_gl_drawable_parent( HWND hwnd, HWND parent );
-extern void destroy_gl_drawable( HWND hwnd );
-extern void destroy_vk_surface( HWND hwnd );
-
+extern BOOL window_is_reparenting( HWND hwnd );
 extern BOOL window_should_take_focus( HWND hwnd, Time time );
 extern BOOL window_has_pending_wm_state( HWND hwnd, UINT state );
 extern void window_wm_state_notify( struct x11drv_win_data *data, unsigned long serial, UINT value, Time time );
@@ -703,20 +690,18 @@
 extern void window_mwm_hints_notify( struct x11drv_win_data *data, unsigned long serial, const MwmHints *hints );
 extern void window_configure_notify( struct x11drv_win_data *data, unsigned long serial, const RECT *rect );
 
-extern BOOL get_window_name( Display *display, Window window, char **name );
 extern void set_net_active_window( HWND hwnd, HWND previous );
+extern Window get_net_active_window( Display *display );
 extern void net_active_window_notify( unsigned long serial, Window window, Time time );
-extern Window get_net_active_window( Display *display, char **name );
 extern void net_active_window_init( struct x11drv_thread_data *data );
 extern void net_supported_init( struct x11drv_thread_data *data );
-extern void net_supporting_wm_check_init( struct x11drv_thread_data *data );
-extern BOOL is_netwm_supported( Atom atom );
+extern BOOL is_net_supported( Atom atom );
 
 extern Window init_clip_window(void);
-extern void update_user_time( struct x11drv_win_data *data, Time time, BOOL force );
+extern void window_set_user_time( struct x11drv_win_data *data, Time time, BOOL init );
 extern UINT get_window_net_wm_state( Display *display, Window window );
 extern void make_window_embedded( struct x11drv_win_data *data );
-extern Window create_client_window( HWND hwnd, RECT client_rect, const XVisualInfo *visual, Colormap colormap );
+extern Window create_client_window( HWND hwnd, const XVisualInfo *visual, Colormap colormap );
 extern void detach_client_window( struct x11drv_win_data *data, Window client_window );
 extern void attach_client_window( struct x11drv_win_data *data, Window client_window );
 extern void destroy_client_window( HWND hwnd, Window client_window );
@@ -747,9 +732,7 @@
 extern void ungrab_clipping_window(void);
 extern void move_resize_window( HWND hwnd, int dir, POINT pos );
 extern void X11DRV_InitKeyboard( Display *display );
-extern void X11DRV_InitMouse( Display *display );
 extern BOOL X11DRV_ProcessEvents( DWORD mask );
-extern HWND *build_hwnd_list(void);
 
 typedef int (*x11drv_error_callback)( Display *display, XErrorEvent *event, void *arg );
 
@@ -758,17 +741,14 @@
 extern POINT virtual_screen_to_root( INT x, INT y );
 extern POINT root_to_virtual_screen( INT x, INT y );
 extern RECT get_host_primary_monitor_rect(void);
-extern BOOL get_host_monitor_rects( RECT **ret_rects, int *ret_count );
 extern RECT get_work_area( const RECT *monitor_rect );
-extern BOOL xinerama_get_fullscreen_monitors( const RECT *rect, long *indices );
+extern void xinerama_get_fullscreen_monitors( const RECT *rect, unsigned int *generation, long *indices );
 extern void xinerama_init( unsigned int width, unsigned int height );
 extern void init_recursive_mutex( pthread_mutex_t *mutex );
+extern void init_icm_profile(void);
 
 #define DEPTH_COUNT 3
 extern const unsigned int *depths;
-extern RECT gamescope_screen_rect;
-
-void clear_emulated_fullscreen_padding( struct x11drv_win_data *data );
 
 /* Use a distinct type for the settings id, to avoid mixups other types of ids */
 typedef struct { ULONG_PTR id; } x11drv_settings_id;
@@ -822,7 +802,7 @@
 
 extern void X11DRV_Settings_SetHandler(const struct x11drv_settings_handler *handler);
 
-extern void X11DRV_init_desktop( Window win );
+extern void X11DRV_init_desktop( Window win, unsigned int width, unsigned int height );
 extern BOOL is_virtual_desktop(void);
 extern BOOL is_desktop_fullscreen(void);
 extern BOOL is_detached_mode(const DEVMODEW *);
@@ -924,7 +904,7 @@
 
 static inline BOOL lp_to_dp( HDC hdc, POINT *points, INT count )
 {
-    return NtGdiTransformPoints( hdc, points, points, count, NtGdiLPtoDPRaw );
+    return NtGdiTransformPoints( hdc, points, points, count, NtGdiLPtoDP );
 }
 
 static inline UINT get_palette_entries( HPALETTE palette, UINT start, UINT count, PALETTEENTRY *entries )
@@ -932,17 +912,6 @@
     return NtGdiDoPalette( palette, start, count, entries, NtGdiGetPaletteEntries, TRUE );
 }
 
-static inline HRGN clone_gdi_region( HRGN rgn )
-{
-    HRGN copy;
-
-    if (!rgn) return NULL;
-
-    copy = NtGdiCreateRectRgn( 0, 0, 0, 0 );
-    NtGdiCombineRgn( copy, rgn, NULL, RGN_COPY );
-    return copy;
-}
-
 /* user helpers */
 
 static inline LRESULT send_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
diff -urN proton_wine10.0/dlls/winex11.drv/x11drv_main.c wine-10.15/dlls/winex11.drv/x11drv_main.c
--- proton_wine10.0/dlls/winex11.drv/x11drv_main.c	2025-11-16 17:00:20.250403198 +0800
+++ wine-10.15/dlls/winex11.drv/x11drv_main.c	2025-09-13 03:36:38.000000000 +0800
@@ -47,7 +47,6 @@
 #include "x11drv.h"
 #include "winreg.h"
 #include "xcomposite.h"
-#include "xfixes.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "wine/list.h"
@@ -69,7 +68,7 @@
 BOOL usexvidmode = TRUE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
-BOOL use_xfixes = FALSE;
+BOOL use_egl = FALSE;
 BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
@@ -83,9 +82,7 @@
 int copy_default_colors = 128;
 int alloc_system_colors = 256;
 int xrender_error_base = 0;
-int xfixes_event_base = 0;
 char *process_name = NULL;
-HANDLE steam_overlay_event;
 
 static x11drv_error_callback err_callback;   /* current callback for error */
 static Display *err_callback_display;        /* display callback is set for */
@@ -123,7 +120,6 @@
     "RAW_CAP_HEIGHT",
     "WM_PROTOCOLS",
     "WM_DELETE_WINDOW",
-    "WM_NAME",
     "WM_STATE",
     "WM_TAKE_FOCUS",
     "DndProtocol",
@@ -135,11 +131,9 @@
     "_NET_STARTUP_INFO_BEGIN",
     "_NET_STARTUP_INFO",
     "_NET_SUPPORTED",
-    "_NET_SUPPORTING_WM_CHECK",
     "_NET_SYSTEM_TRAY_OPCODE",
     "_NET_SYSTEM_TRAY_S0",
     "_NET_SYSTEM_TRAY_VISUAL",
-    "_NET_WM_BYPASS_COMPOSITOR",
     "_NET_WM_FULLSCREEN_MONITORS",
     "_NET_WM_ICON",
     "_NET_WM_MOVERESIZE",
@@ -148,7 +142,6 @@
     "_NET_WM_PING",
     "_NET_WM_STATE",
     "_NET_WM_STATE_ABOVE",
-    "_NET_WM_STATE_BELOW",
     "_NET_WM_STATE_DEMANDS_ATTENTION",
     "_NET_WM_STATE_FULLSCREEN",
     "_NET_WM_STATE_MAXIMIZED_HORZ",
@@ -164,12 +157,8 @@
     "_NET_WM_WINDOW_TYPE_UTILITY",
     "_NET_WORKAREA",
     "_GTK_WORKAREAS_D0",
-    "_WINE_HWND",
     "_XEMBED",
     "_XEMBED_INFO",
-    "_WINE_ALLOW_FLIP",
-    "_WINE_HWND_STYLE",
-    "_WINE_HWND_EXSTYLE",
     "XdndAware",
     "XdndEnter",
     "XdndPosition",
@@ -201,9 +190,7 @@
     "text/plain",
     "text/rtf",
     "text/richtext",
-    "text/uri-list",
-    "GAMESCOPE_DISPLAY_EDID_PATH",
-    "GAMESCOPE_XALIA_OVERLAY",
+    "text/uri-list"
 };
 
 /***********************************************************************
@@ -359,12 +346,12 @@
 
         sid = ((TOKEN_USER *)sid_data)->User.Sid;
         len = sprintf( buffer, "\\Registry\\User\\S-%u-%u", sid->Revision,
-                       (int)MAKELONG( MAKEWORD( sid->IdentifierAuthority.Value[5],
-                                                sid->IdentifierAuthority.Value[4] ),
-                                      MAKEWORD( sid->IdentifierAuthority.Value[3],
-                                                sid->IdentifierAuthority.Value[2] )));
+                       MAKELONG( MAKEWORD( sid->IdentifierAuthority.Value[5],
+                                           sid->IdentifierAuthority.Value[4] ),
+                                 MAKEWORD( sid->IdentifierAuthority.Value[3],
+                                           sid->IdentifierAuthority.Value[2] )));
         for (i = 0; i < sid->SubAuthorityCount; i++)
-            len += sprintf( buffer + len, "-%u", (int)sid->SubAuthority[i] );
+            len += sprintf( buffer + len, "-%u", sid->SubAuthority[i] );
 
         ascii_to_unicode( bufferW, buffer, len );
         hkcu = reg_open_key( NULL, bufferW, len * sizeof(WCHAR) );
@@ -464,6 +451,9 @@
     if (!get_config_key( hkey, appkey, "Managed", buffer, sizeof(buffer) ))
         managed_mode = IS_OPTION_TRUE( buffer[0] );
 
+    if (!get_config_key( hkey, appkey, "UseEGL", buffer, sizeof(buffer) ))
+        use_egl = IS_OPTION_TRUE( buffer[0] );
+
     if (!get_config_key( hkey, appkey, "UseXVidMode", buffer, sizeof(buffer) ))
         usexvidmode = IS_OPTION_TRUE( buffer[0] );
 
@@ -574,67 +564,6 @@
 }
 #endif /* defined(SONAME_LIBXCOMPOSITE) */
 
-#ifdef SONAME_LIBXFIXES
-
-#define MAKE_FUNCPTR(f) typeof(f) * p##f;
-MAKE_FUNCPTR(XFixesHideCursor)
-MAKE_FUNCPTR(XFixesQueryExtension)
-MAKE_FUNCPTR(XFixesQueryVersion)
-MAKE_FUNCPTR(XFixesCreateRegion)
-MAKE_FUNCPTR(XFixesCreateRegionFromGC)
-MAKE_FUNCPTR(XFixesSelectSelectionInput)
-MAKE_FUNCPTR(XFixesShowCursor)
-#undef MAKE_FUNCPTR
-
-static void x11drv_load_xfixes(void)
-{
-    int event, error, major = 3, minor = 0;
-    void *xfixes;
-
-    if (!(xfixes = dlopen(SONAME_LIBXFIXES, RTLD_NOW)))
-    {
-        WARN("Xfixes library %s not found, disabled.\n", SONAME_LIBXFIXES);
-        return;
-    }
-
-#define LOAD_FUNCPTR(f) \
-    if (!(p##f = dlsym(xfixes, #f)))                          \
-    {                                                         \
-        WARN("Xfixes function %s not found, disabled\n", #f); \
-        dlclose(xfixes);                                      \
-        return;                                               \
-    }
-    LOAD_FUNCPTR(XFixesHideCursor)
-    LOAD_FUNCPTR(XFixesQueryExtension)
-    LOAD_FUNCPTR(XFixesQueryVersion)
-    LOAD_FUNCPTR(XFixesCreateRegion)
-    LOAD_FUNCPTR(XFixesCreateRegionFromGC)
-    LOAD_FUNCPTR(XFixesSelectSelectionInput)
-    LOAD_FUNCPTR(XFixesShowCursor)
-#undef LOAD_FUNCPTR
-
-    if (!pXFixesQueryExtension(gdi_display, &event, &error))
-    {
-        WARN("Xfixes extension not found, disabled.\n");
-        dlclose(xfixes);
-        return;
-    }
-
-    if (!pXFixesQueryVersion(gdi_display, &major, &minor) ||
-        major < 2)
-    {
-        WARN("Xfixes version 2.0 not found, disabled.\n");
-        dlclose(xfixes);
-        return;
-    }
-
-    TRACE("Xfixes, error %d, event %d, version %d.%d found\n",
-          error, event, major, minor);
-    use_xfixes = TRUE;
-    xfixes_event_base = event;
-}
-#endif /* SONAME_LIBXFIXES */
-
 static void init_visuals( Display *display, int screen )
 {
     int count;
@@ -695,19 +624,6 @@
 {
     Display *display;
     void *libx11 = dlopen( SONAME_LIBX11, RTLD_NOW|RTLD_GLOBAL );
-    OBJECT_ATTRIBUTES attr;
-    WCHAR buffer[MAX_PATH];
-    char path[MAX_PATH];
-    UNICODE_STRING str;
-
-    RtlInitUnicodeString( &str, buffer );
-    InitializeObjectAttributes( &attr, &str, OBJ_CASE_INSENSITIVE | OBJ_OPENIF, 0, NULL );
-
-    str.Length = sprintf( path, "\\Sessions\\%u\\BaseNamedObjects\\__wine_steamclient_GameOverlayActivated",
-                          (int)NtCurrentTeb()->Peb->SessionId );
-    ascii_to_unicode( buffer, path, str.Length + 1 );
-    str.Length *= sizeof(WCHAR);
-    NtCreateEvent( &steam_overlay_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE );
 
     if (!libx11)
     {
@@ -750,9 +666,6 @@
     X11DRV_XF86VM_Init();
     /* initialize XRandR */
     X11DRV_XRandR_Init();
-#ifdef SONAME_LIBXFIXES
-    x11drv_load_xfixes();
-#endif
 #ifdef SONAME_LIBXCOMPOSITE
     X11DRV_XComposite_Init();
 #endif
@@ -760,27 +673,10 @@
 
     XkbUseExtension( gdi_display, NULL, NULL );
     X11DRV_InitKeyboard( gdi_display );
-    X11DRV_InitMouse( gdi_display );
     if (use_xim) use_xim = xim_init( input_style );
 
+    init_icm_profile();
     init_user_driver();
-
-    {
-        RECT rect = NtUserGetVirtualScreenRect( MDT_DEFAULT );
-
-        if (rect.bottom <= 800)
-        {
-            NONCLIENTMETRICSW ncm;
-
-            ncm.cbSize = sizeof(ncm);
-            if (NtUserSystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 ) && ncm.iCaptionHeight > 18)
-            {
-                TRACE( "Reducing iCaptionHeight from %d to 17.\n", ncm.iCaptionHeight );
-                ncm.iCaptionHeight = 17;
-                NtUserSystemParametersInfo( SPI_SETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);
-            }
-        }
-    }
     return STATUS_SUCCESS;
 }
 
@@ -797,7 +693,6 @@
         if (data->xim) XCloseIM( data->xim );
         if (data->font_set) XFreeFontSet( data->display, data->font_set );
         if (data->net_supported) XFree( data->net_supported );
-        if (data->window_manager) XFree( data->window_manager );
         XSync( gdi_display, False ); /* make sure XReparentWindow requests have completed before closing the thread display */
         XCloseDisplay( data->display );
         free( data );
@@ -866,7 +761,6 @@
     if (use_xim) xim_thread_attach( data );
     x11drv_xinput2_init( data );
     net_supported_init( data );
-    net_supporting_wm_check_init( data );
     net_active_window_init( data );
 
     return data;
diff -urN proton_wine10.0/dlls/winex11.drv/xfixes.h wine-10.15/dlls/winex11.drv/xfixes.h
--- proton_wine10.0/dlls/winex11.drv/xfixes.h	2025-11-16 17:00:20.251403171 +0800
+++ wine-10.15/dlls/winex11.drv/xfixes.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-/*
- * Wine X11DRV Xfixes interface
- *
- * Copyright 2021 Rmi Bernon for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-#ifndef __WINE_XFIXES_H
-#define __WINE_XFIXES_H
-
-#ifndef __WINE_CONFIG_H
-# error You must include config.h to use this header
-#endif
-
-#ifdef SONAME_LIBXFIXES
-#include <X11/extensions/Xfixes.h>
-#define MAKE_FUNCPTR(f) extern typeof(f) * p##f;
-MAKE_FUNCPTR(XFixesHideCursor)
-MAKE_FUNCPTR(XFixesQueryExtension)
-MAKE_FUNCPTR(XFixesQueryVersion)
-MAKE_FUNCPTR(XFixesSelectSelectionInput)
-MAKE_FUNCPTR(XFixesShowCursor)
-#undef MAKE_FUNCPTR
-#endif /* defined(SONAME_LIBXFIXES) */
-
-#endif /* __WINE_XFIXES_H */
diff -urN proton_wine10.0/dlls/winex11.drv/xim.c wine-10.15/dlls/winex11.drv/xim.c
--- proton_wine10.0/dlls/winex11.drv/xim.c	2025-11-16 17:00:20.251403171 +0800
+++ wine-10.15/dlls/winex11.drv/xim.c	2025-09-13 03:36:38.000000000 +0800
@@ -45,6 +45,7 @@
 #endif
 
 static WCHAR *ime_comp_buf;
+static DWORD ime_comp_cursor_pos = 0;
 
 static XIMStyle input_style = 0;
 static XIMStyle input_style_req = XIMPreeditCallbacks | XIMStatusCallbacks;
@@ -168,6 +169,33 @@
     return 0;
 }
 
+static DWORD get_comp_cursor_pos( XIMPreeditDrawCallbackStruct *params )
+{
+    int i, cursor_begin = -1, cursor_end = -1;
+    XIMText *text = params->text;
+
+    if (text && text->feedback)
+    {
+        for (i = 0; i < text->length; i++)
+        {
+            if (text->feedback[i] & XIMReverse)
+            {
+                if (cursor_begin == -1) cursor_begin = i;
+                cursor_end = i + 1;
+            }
+        }
+        if (cursor_begin != -1) cursor_begin += params->chg_first;
+        if (cursor_end   != -1) cursor_end   += params->chg_first;
+    }
+
+    if (cursor_begin == cursor_end)
+        cursor_begin = cursor_end = params->caret; /* ATTR_INPUT */
+
+    TRACE( "caret %d, cursor_begin %d, cursor_end %d\n", params->caret, cursor_begin, cursor_end );
+
+    return MAKELONG( cursor_begin, cursor_end );
+}
+
 static int xic_preedit_draw( XIC xic, XPointer user, XPointer arg )
 {
     XIMPreeditDrawCallbackStruct *params = (void *)arg;
@@ -202,14 +230,14 @@
 
     if (text && str != text->string.multi_byte) free( str );
 
-    post_ime_update( hwnd, params->caret, ime_comp_buf, NULL );
+    ime_comp_cursor_pos = get_comp_cursor_pos( params );
+    post_ime_update( hwnd, ime_comp_cursor_pos, ime_comp_buf, NULL );
 
     return 0;
 }
 
 static int xic_preedit_caret( XIC xic, XPointer user, XPointer arg )
 {
-    static int xim_caret_pos;
     XIMPreeditCaretCallbackStruct *params = (void *)arg;
     HWND hwnd = (HWND)user;
     int pos;
@@ -218,7 +246,7 @@
 
     if (!params) return 0;
 
-    pos = xim_caret_pos;
+    pos = LOWORD( ime_comp_cursor_pos );
     switch (params->direction)
     {
     case XIMForwardChar:
@@ -246,9 +274,17 @@
         FIXME( "Not implemented\n" );
         break;
     }
-    params->position = xim_caret_pos = pos;
+    params->position = pos;
 
-    post_ime_update( hwnd, pos, ime_comp_buf, NULL );
+    /* uim implements the preedit_caret callback. This callback is only
+       valid when the xim is in non-converted state (ATTR_INPUT).
+     */
+    if (LOWORD( ime_comp_cursor_pos ) == HIWORD( ime_comp_cursor_pos ) &&
+        LOWORD( ime_comp_cursor_pos ) != pos)
+    {
+        ime_comp_cursor_pos = MAKELONG( pos, pos );
+        post_ime_update( hwnd, ime_comp_cursor_pos, ime_comp_buf, NULL );
+    }
 
     return 0;
 }
@@ -473,7 +509,7 @@
     XIC ret;
 
     if (!(data = get_win_data( hwnd ))) return 0;
-    x11drv_init_thread_data()->last_xic_hwnd = hwnd;
+    x11drv_thread_data()->last_xic_hwnd = hwnd;
     if (!(ret = data->xic) && (xim = x11drv_thread_data()->xim))
         ret = data->xic = xic_create( xim, hwnd, data->whole_window );
     release_win_data( data );
diff -urN proton_wine10.0/dlls/winex11.drv/xinerama.c wine-10.15/dlls/winex11.drv/xinerama.c
--- proton_wine10.0/dlls/winex11.drv/xinerama.c	2025-11-16 17:00:20.251403171 +0800
+++ wine-10.15/dlls/winex11.drv/xinerama.c	2025-09-13 03:36:38.000000000 +0800
@@ -46,6 +46,7 @@
 };
 
 static pthread_mutex_t xinerama_mutex = PTHREAD_MUTEX_INITIALIZER;
+static unsigned long xinerama_generation;
 static MONITORINFOEXW *monitors;
 static int nb_monitors;
 
@@ -124,10 +125,9 @@
 #endif  /* SONAME_LIBXINERAMA */
 
 /* Get xinerama monitor indices required for _NET_WM_FULLSCREEN_MONITORS */
-BOOL xinerama_get_fullscreen_monitors( const RECT *rect, long *indices )
+void xinerama_get_fullscreen_monitors( const RECT *rect, unsigned int *generation, long *indices )
 {
     RECT window_rect, intersected_rect, monitor_rect;
-    BOOL ret = FALSE;
     POINT offset;
     INT i;
 
@@ -135,7 +135,7 @@
     if (nb_monitors == 1)
     {
         memset( indices, 0, sizeof(*indices) * 4 );
-        ret = TRUE;
+        *generation = xinerama_generation;
         goto done;
     }
 
@@ -155,10 +155,8 @@
         offset.y = min( offset.y, monitors[i].rcMonitor.top );
     }
 
-    indices[0] = -1;
-    indices[1] = -1;
-    indices[2] = -1;
-    indices[3] = -1;
+    indices[0] = indices[1] = indices[2] = indices[3] = -1;
+    *generation = xinerama_generation;
     for (i = 0; i < nb_monitors; ++i)
     {
         SetRect( &monitor_rect, monitors[i].rcMonitor.left - offset.x,
@@ -167,27 +165,18 @@
         intersect_rect( &intersected_rect, &window_rect, &monitor_rect );
         if (EqualRect( &intersected_rect, &monitor_rect ))
         {
-            if (indices[0] == -1 || monitors[i].rcMonitor.top < monitors[indices[0]].rcMonitor.top)
-                indices[0] = i;
-            if (indices[1] == -1 || monitors[i].rcMonitor.bottom > monitors[indices[1]].rcMonitor.bottom)
-                indices[1] = i;
-            if (indices[2] == -1 || monitors[i].rcMonitor.left < monitors[indices[2]].rcMonitor.left)
-                indices[2] = i;
-            if (indices[3] == -1 || monitors[i].rcMonitor.right > monitors[indices[3]].rcMonitor.right)
-                indices[3] = i;
+            if (indices[0] == -1) indices[0] = indices[1] = indices[2] = indices[3] = i;
+            if (monitors[i].rcMonitor.top < monitors[indices[0]].rcMonitor.top) indices[0] = i;
+            if (monitors[i].rcMonitor.bottom > monitors[indices[1]].rcMonitor.bottom) indices[1] = i;
+            if (monitors[i].rcMonitor.left < monitors[indices[2]].rcMonitor.left) indices[2] = i;
+            if (monitors[i].rcMonitor.right > monitors[indices[3]].rcMonitor.right) indices[3] = i;
         }
     }
 
-    if (indices[0] == -1 || indices[1] == -1 || indices[2] == -1 || indices[3] == -1)
-        ERR("Failed to get xinerama fullscreen monitor indices.\n");
-    else
-        ret = TRUE;
+    if (indices[0] == -1) WARN("Failed to get xinerama fullscreen monitor indices.\n");
 
 done:
     pthread_mutex_unlock( &xinerama_mutex );
-    if (ret)
-        TRACE( "fullscreen monitors: %ld,%ld,%ld,%ld.\n", indices[0], indices[1], indices[2], indices[3] );
-    return ret;
 }
 
 static BOOL xinerama_get_gpus( struct x11drv_gpu **new_gpus, int *count, BOOL get_properties )
@@ -368,6 +357,7 @@
                (monitors[i].dwFlags & MONITORINFOF_PRIMARY) ? " (primary)" : "" );
     }
 
+    xinerama_generation++;
     pthread_mutex_unlock( &xinerama_mutex );
 
     handler.name = "Xinerama";
diff -urN proton_wine10.0/dlls/winex11.drv/xrandr.c wine-10.15/dlls/winex11.drv/xrandr.c
--- proton_wine10.0/dlls/winex11.drv/xrandr.c	2025-11-16 17:00:20.252403143 +0800
+++ wine-10.15/dlls/winex11.drv/xrandr.c	2025-09-13 03:36:38.000000000 +0800
@@ -32,11 +32,13 @@
 #include <X11/extensions/Xrandr.h>
 #endif
 #include <dlfcn.h>
-#include <stdlib.h>
 #include "x11drv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xrandr);
+#ifdef HAVE_XRRGETPROVIDERRESOURCES
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
+#endif
 
 #ifdef SONAME_LIBXRANDR
 
@@ -384,7 +386,7 @@
 
     if (mode->dmFields & DM_BITSPERPEL && mode->dmBitsPerPel != screen_bpp)
         WARN("Cannot change screen bit depth from %dbits to %dbits!\n",
-             screen_bpp, (int)mode->dmBitsPerPel);
+             screen_bpp, mode->dmBitsPerPel);
 
     root = DefaultRootWindow( gdi_display );
     screen_config = pXRRGetScreenInfo( gdi_display, root );
@@ -454,6 +456,7 @@
     XRRScreenResources *screen_resources;
     XRROutputInfo *output_info;
     XRRModeInfo *first_mode;
+    INT major, event, error;
     INT output_idx, i, j;
     BOOL only_one_mode;
 
@@ -504,6 +507,15 @@
 
         if (!only_one_mode)
             continue;
+
+        /* Check if it is NVIDIA proprietary driver */
+        if (XQueryExtension( gdi_display, "NV-CONTROL", &major, &event, &error ))
+        {
+            ERR_(winediag)("Broken NVIDIA RandR detected, falling back to RandR 1.0. "
+                           "Please consider using the Nouveau driver instead.\n");
+            pXRRFreeScreenResources( screen_resources );
+            return TRUE;
+        }
     }
     pXRRFreeScreenResources( screen_resources );
     return FALSE;
@@ -534,134 +546,23 @@
     }
 }
 
-static unsigned int get_edid( RROutput output, unsigned char **prop,
-                              XRROutputInfo *output_info, XRRScreenResources *screen_resources )
+static unsigned int get_edid( RROutput output, unsigned char **prop )
 {
-    unsigned int mwidth, mheight, i;
-    unsigned long bytes_after, len;
-    unsigned char *edid, *p, c;
     int result, actual_format;
-    XRRModeInfo *mode;
+    unsigned long bytes_after, len;
     Atom actual_type;
-    char *edid_path;
 
-    *prop = NULL;
     result = pXRRGetOutputProperty( gdi_display, output, x11drv_atom(EDID), 0, 128, FALSE, FALSE,
                                     AnyPropertyType, &actual_type, &actual_format, &len,
-                                    &bytes_after, &edid );
-    if (result == Success && len)
-    {
-        if (!(*prop = malloc( len )))
-        {
-            XFree( edid );
-            return 0;
-        }
-        memcpy( *prop, edid, len );
-        return len;
-    }
-
-    edid_path = NULL;
-    if ((result = XGetWindowProperty( gdi_display, DefaultRootWindow(gdi_display), x11drv_atom(GAMESCOPE_DISPLAY_EDID_PATH), 0,
-                                      PATH_MAX, False, x11drv_atom(UTF8_STRING), &actual_type, &actual_format,
-                                      &len, &bytes_after, (unsigned char **)&edid_path )) == Success
-        && actual_type == x11drv_atom(UTF8_STRING))
-    {
-        char buffer[4096];
-        FILE *f;
-
-        f = fopen( edid_path, "rb" );
-        if (f)
-        {
-            len = fread( buffer, 1, sizeof(buffer), f );
-            fclose( f );
-            if (len)
-            {
-                XFree( edid_path );
-                if (!(*prop = malloc( len ))) return 0;
-                memcpy( *prop, buffer, len );
-                return len;
-            }
-        }
-    }
-    if (edid_path) XFree( edid_path );
-
-    WARN( "Could not retrieve EDID property for output %#lx.\n", output );
-    if (!output_info->npreferred)
-    {
-        WARN( "No preferred modes for output %#lx.\n", output );
-        return 0;
-    }
-    if (output_info->npreferred > 1)
-        WARN( "%u preferred modes for output %#lx, using first one.\n", output_info->npreferred, output );
+                                    &bytes_after, prop );
 
-    for (i = 0; i < screen_resources->nmode; ++i)
-        if (screen_resources->modes[i].id == output_info->modes[0]) break;
-
-    if (i == screen_resources->nmode)
+    if (result != Success)
     {
-        ERR("Preferred mode not found for output %#lx.\n", output);
+        WARN("Could not retrieve EDID property for output %#lx.\n", output);
+        *prop = NULL;
         return 0;
     }
-
-    mode = &screen_resources->modes[i];
-
-    mwidth = mode->width / 60;   /* Fake ~150dpi. */
-    mheight = mode->height / 60;
-
-    edid = calloc( 1, 128 );
-    *prop = edid;
-    *(uint64_t *)edid = 0x00ffffffffffff00;
-    edid[18] = 1;
-    edid[19] = 4;
-    edid[20] = 0xa0; /* Digital input, 8 bit depth. */
-    edid[21] = mwidth;
-    edid[22] = mheight;
-    edid[24] = 0x6;
-    for (i = 0; i < 16; ++i) edid[38 + i] = 1;
-
-    p = edid + 54;
-    *(uint16_t *)&p[0] = mode->dotClock / 10000;
-    p[2] = mode->width;
-    p[3] = mode->hTotal - mode->width;
-    p[4] = (((mode->hTotal - mode->width) >> 8) & 0xf) | (((mode->width >> 8) & 0xf) << 4);
-    p[5] = mode->height;
-    p[6] = mode->vTotal - mode->height;
-    p[7] = (((mode->vTotal - mode->height) >> 8) & 0xf) | (((mode->height >> 8) & 0xf) << 4);
-    p[8] = mode->hSyncStart - mode->width;
-    p[9] = mode->hSyncEnd - mode->hSyncStart;
-    p[10] = (((mode->vSyncStart - mode->height) & 0xf) << 4) | ((mode->vSyncEnd - mode->vSyncStart) & 0xf);
-    p[11] = ((((mode->hSyncStart - mode->width) >> 8) & 3) << 6)
-            | ((((mode->hSyncEnd - mode->hSyncStart) >> 8) & 3) << 4)
-            | ((((mode->vSyncStart - mode->height) >> 4) & 3) << 2)
-            | (((mode->vSyncEnd - mode->vSyncStart) >> 4) & 3);
-    p[12] = mwidth;
-    p[13] = mheight;
-    p[14] = (((mwidth >> 8) & 0xf) << 4) | ((mheight >> 8) & 0xf);
-    if (mode->modeFlags & RR_Interlace)
-        p[17] |= 0x80;
-    p[17] |= 3 << 3;
-    if (mode->modeFlags & RR_HSyncPositive)
-        p[17] |= 2;
-    if (mode->modeFlags & RR_VSyncPositive)
-        p[17] |= 4;
-
-    if (mode->modeFlags & (RR_DoubleScan | RR_PixelMultiplex | RR_DoubleClock | RR_ClockDivideBy2))
-        FIXME( "Unsupported flags %#lx.\n", mode->modeFlags );
-
-    p += 18;
-    p[3] = 0xfc;
-    strcpy( (char *)p + 5, "Default" );
-
-    p += 18;
-    p[3] = 0x10;
-    p += 18;
-    p[3] = 0x10;
-
-    c = 0;
-    for (i = 0; i < 127; ++i)
-        c += edid[i];
-    edid[127] = 256 - c;
-    return 128;
+    return len;
 }
 
 static void set_screen_size( int width, int height )
@@ -1221,8 +1122,7 @@
     /* Inactive but attached monitor, no need to check for mirrored/replica monitors */
     if (!output_info->crtc || !crtc_info->mode)
     {
-        monitors[monitor_count].edid_len = get_edid( adapter_id, &monitors[monitor_count].edid,
-                                                     output_info, screen_resources );
+        monitors[monitor_count].edid_len = get_edid( adapter_id, &monitors[monitor_count].edid );
         monitor_count = 1;
     }
     /* Active monitors, need to find other monitors with the same coordinates as mirrored */
@@ -1273,8 +1173,7 @@
                         primary_index = monitor_count;
 
                     monitors[monitor_count].edid_len = get_edid( screen_resources->outputs[i],
-                                                                 &monitors[monitor_count].edid,
-                                                                 enum_output_info, screen_resources );
+                                                                 &monitors[monitor_count].edid );
                     monitor_count++;
                 }
 
@@ -1318,7 +1217,7 @@
         for (i = 0; i < monitor_count; i++)
         {
             if (monitors[i].edid)
-                free( monitors[i].edid );
+                XFree( monitors[i].edid );
         }
         free( monitors );
         ERR("Failed to get monitors\n");
@@ -1333,7 +1232,7 @@
     for (i = 0; i < count; i++)
     {
         if (monitors[i].edid)
-            free( monitors[i].edid );
+            XFree( monitors[i].edid );
     }
     free( monitors );
 }
@@ -1703,7 +1602,7 @@
 
     if (mode->dmFields & DM_BITSPERPEL && mode->dmBitsPerPel != screen_bpp)
         WARN("Cannot change screen color depth from %ubits to %ubits!\n",
-             screen_bpp, (int)mode->dmBitsPerPel);
+             screen_bpp, mode->dmBitsPerPel);
 
     screen_resources = xrandr_get_screen_resources();
     if (!screen_resources)
diff -urN proton_wine10.0/dlls/winex11.drv/xrender.c wine-10.15/dlls/winex11.drv/xrender.c
--- proton_wine10.0/dlls/winex11.drv/xrender.c	2025-11-16 17:00:20.253403116 +0800
+++ wine-10.15/dlls/winex11.drv/xrender.c	2025-09-13 03:36:38.000000000 +0800
@@ -845,7 +845,7 @@
     }
 
     TRACE("h=%d w=%d weight=%d it=%d charset=%d name=%s\n",
-          (int)lfsz.lf.lfHeight, (int)lfsz.lf.lfWidth, (int)lfsz.lf.lfWeight,
+          lfsz.lf.lfHeight, lfsz.lf.lfWidth, lfsz.lf.lfWeight,
           lfsz.lf.lfItalic, lfsz.lf.lfCharSet, debugstr_w(lfsz.lf.lfFaceName));
     lfsz.lf.lfWidth = abs( lfsz.lf.lfWidth );
     lfsz.devsize.cx = X11DRV_XWStoDS( dev->hdc, lfsz.lf.lfWidth );
@@ -959,7 +959,6 @@
     struct xrender_physdev *physdev = get_xrender_dev( dev );
 
     free_xrender_picture( physdev );
-    if (physdev->region) NtGdiDeleteObjectApp( physdev->region );
 
     pthread_mutex_lock( &xrender_mutex );
     if (physdev->cache_index != -1) dec_ref_cache( physdev->cache_index );
@@ -1015,16 +1014,15 @@
 /***********************************************************************
  *           xrenderdrv_SetDeviceClipping
  */
-static void xrenderdrv_SetDeviceClipping( PHYSDEV dev, HRGN rgn, HRGN monitor_rgn )
+static void xrenderdrv_SetDeviceClipping( PHYSDEV dev, HRGN rgn )
 {
     struct xrender_physdev *physdev = get_xrender_dev( dev );
 
-    if (physdev->region) NtGdiDeleteObjectApp( physdev->region );
-    physdev->region = clone_gdi_region( monitor_rgn );
+    physdev->region = rgn;
     physdev->update_clip = TRUE;
 
     dev = GET_NEXT_PHYSDEV( dev, pSetDeviceClipping );
-    dev->funcs->pSetDeviceClipping( dev, rgn, monitor_rgn );
+    dev->funcs->pSetDeviceClipping( dev, rgn );
 }
 
 
@@ -1132,7 +1130,7 @@
     TRACE("buflen = %d. Got metrics: %dx%d adv=%d,%d origin=%d,%d\n",
 	  buflen,
 	  gm.gmBlackBoxX, gm.gmBlackBoxY, gm.gmCellIncX, gm.gmCellIncY,
-	  (int)gm.gmptGlyphOrigin.x, (int)gm.gmptGlyphOrigin.y);
+	  gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y);
 
     gi.width = gm.gmBlackBoxX;
     gi.height = gm.gmBlackBoxY;
@@ -1371,7 +1369,7 @@
     }
 
     TRACE("Writing %s at %d,%d\n", debugstr_wn(wstr,count),
-          (int)(physdev->x11dev->dc_rect.left + x), (int)(physdev->x11dev->dc_rect.top + y));
+           physdev->x11dev->dc_rect.left + x, physdev->x11dev->dc_rect.top + y);
 
     elts = malloc( sizeof(XGlyphElt16) * count );
 
@@ -2105,7 +2103,7 @@
             rc.bottom = max( pt[0].y, pt[1].y );
 
             TRACE( "%u gradient %s colors %04x,%04x,%04x,%04x -> %04x,%04x,%04x,%04x\n",
-                   (int)mode, wine_dbgstr_rect( &rc ),
+                   mode, wine_dbgstr_rect( &rc ),
                    colors[0].red, colors[0].green, colors[0].blue, colors[0].alpha,
                    colors[1].red, colors[1].green, colors[1].blue, colors[1].alpha );
 
@@ -2205,7 +2203,6 @@
     NULL,                               /* pGetFontUnicodeRanges */
     NULL,                               /* pGetGlyphIndices */
     NULL,                               /* pGetGlyphOutline */
-    NULL,                               /* pGetICMProfile */
     NULL,                               /* pGetImage */
     NULL,                               /* pGetKerningPairs */
     NULL,                               /* pGetNearestColor */
diff -urN proton_wine10.0/dlls/winex11.drv/xvidmode.c wine-10.15/dlls/winex11.drv/xvidmode.c
--- proton_wine10.0/dlls/winex11.drv/xvidmode.c	2025-11-16 17:00:20.253403116 +0800
+++ wine-10.15/dlls/winex11.drv/xvidmode.c	2025-09-13 03:36:38.000000000 +0800
@@ -228,7 +228,7 @@
 
     if (mode->dmFields & DM_BITSPERPEL && mode->dmBitsPerPel != screen_bpp)
         WARN("Cannot change screen bit depth from %dbits to %dbits!\n",
-             screen_bpp, (int)mode->dmBitsPerPel);
+             screen_bpp, mode->dmBitsPerPel);
 
     assert(mode->dmDriverExtra == sizeof(XF86VidModeModeInfo *));
     memcpy(&xf86vm_mode, (BYTE *)mode + sizeof(*mode), sizeof(xf86vm_mode));
