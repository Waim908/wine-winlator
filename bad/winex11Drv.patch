diff -urN wine-9.2/dlls/winex11.drv/keyboard.c wine-9.2-custom-main/dlls/winex11.drv/keyboard.c
--- wine-9.2/dlls/winex11.drv/keyboard.c	2024-02-10 05:46:52.000000000 +0800
+++ wine-9.2-custom-main/dlls/winex11.drv/keyboard.c	2025-07-31 04:11:27.000000000 +0800
@@ -34,7 +34,6 @@
 #include <X11/Xlib.h>
 #include <X11/Xresource.h>
 #include <X11/Xutil.h>
-#include <X11/XKBlib.h>
 
 #include <ctype.h>
 #include <stdarg.h>
@@ -62,6 +61,7 @@
 static const unsigned int ControlMask = 1 << 2;
 
 static int min_keycode, max_keycode, keysyms_per_keycode;
+static KeySym *key_mapping;
 static WORD keyc2vkey[256], keyc2scan[256];
 
 static int NumLockMask, ScrollLockMask, AltGrMask; /* mask in the XKeyEvent state */
@@ -1083,6 +1083,11 @@
     0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
 };
 
+static inline KeySym keycode_to_keysym( Display *display, KeyCode keycode, int index )
+{
+    return key_mapping[(keycode - min_keycode) * keysyms_per_keycode + index];
+}
+
 /* Returns the Windows virtual key code associated with the X event <e> */
 /* kbd_section must be held */
 static WORD EVENT_event_to_vkey( XIC xic, XKeyEvent *e)
@@ -1391,16 +1396,6 @@
 
     pthread_mutex_lock( &kbd_mutex );
 
-    /* If XKB extensions are used, the state mask for AltGr will use the group
-       index instead of the modifier mask. The group index is set in bits
-       13-14 of the state field in the XKeyEvent structure. So if AltGr is
-       pressed, look if the group index is different than 0. From XKB
-       extension documentation, the group index for AltGr should be 2
-       (event->state = 0x2000). It's probably better to not assume a
-       predefined group index and find it dynamically
-
-       Ref: X Keyboard Extension: Library specification (section 14.1.1 and 17.1.1) */
-    /* Save also all possible modifier states. */
     AltGrMask = event->state & (0x6000 | Mod1Mask | Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask);
 
     if (TRACE_ON(key)){
@@ -1467,19 +1462,11 @@
   for (keyc = min_keycode; keyc <= max_keycode; keyc++) {
       /* get data for keycode from X server */
       for (i = 0; i < syms; i++) {
-        if (!(keysym = XkbKeycodeToKeysym( display, keyc, 0, i ))) continue;
+        if (!(keysym = keycode_to_keysym( display, keyc, i ))) continue;
 	/* Allow both one-byte and two-byte national keysyms */
 	if ((keysym < 0x8000) && (keysym != ' '))
         {
-            if (!XkbTranslateKeySym(display, &keysym, 0, &ckey[keyc][i], 1, NULL))
-            {
-                TRACE("XKB could not translate keysym %04lx\n", keysym);
-                /* FIXME: query what keysym is used as Mode_switch, fill XKeyEvent
-                 * with appropriate ShiftMask and Mode_switch, use XLookupString
-                 * to get character in the local encoding.
-                 */
-                ckey[keyc][i] = keysym & 0xFF;
-            }
+            ckey[keyc][i] = keysym & 0xFF;
         }
 	else {
 	  ckey[keyc][i] = KEYBOARD_MapDeadKeysym(keysym);
@@ -1586,7 +1573,8 @@
 
     pthread_mutex_lock( &kbd_mutex );
     XDisplayKeycodes(display, &min_keycode, &max_keycode);
-    XFree( XGetKeyboardMapping( display, min_keycode, max_keycode + 1 - min_keycode, &keysyms_per_keycode ) );
+    if (key_mapping) XFree( key_mapping );
+    key_mapping = XGetKeyboardMapping( display, min_keycode, max_keycode + 1 - min_keycode, &keysyms_per_keycode );
 
     mmp = XGetModifierMapping(display);
     kcp = mmp->modifiermap;
@@ -1600,12 +1588,12 @@
 		int k;
 
 		for (k = 0; k < keysyms_per_keycode; k += 1)
-                    if (XkbKeycodeToKeysym( display, *kcp, 0, k ) == XK_Num_Lock)
+                    if (keycode_to_keysym( display, *kcp, k ) == XK_Num_Lock)
 		    {
                         NumLockMask = 1 << i;
                         TRACE_(key)("NumLockMask is %x\n", NumLockMask);
 		    }
-                    else if (XkbKeycodeToKeysym( display, *kcp, 0, k ) == XK_Scroll_Lock)
+                    else if (keycode_to_keysym( display, *kcp, k ) == XK_Scroll_Lock)
 		    {
                         ScrollLockMask = 1 << i;
                         TRACE_(key)("ScrollLockMask is %x\n", ScrollLockMask);
@@ -1657,19 +1645,12 @@
 	      /* we seem to need to search the layout-dependent scancodes */
 	      int maxlen=0,maxval=-1,ok;
 	      for (i=0; i<syms; i++) {
-		keysym = XkbKeycodeToKeysym( display, keyc, 0, i );
+		keysym = keycode_to_keysym( display, keyc, i );
 		if ((keysym<0x8000) && (keysym!=' '))
-                {
-                    if (!XkbTranslateKeySym(display, &keysym, 0, &ckey[i], 1, NULL))
-                    {
-                        /* FIXME: query what keysym is used as Mode_switch, fill XKeyEvent
-                         * with appropriate ShiftMask and Mode_switch, use XLookupString
-                         * to get character in the local encoding.
-                         */
-                        ckey[i] = (keysym <= 0x7F) ? keysym : 0;
-                    }
+        {
+            ckey[i] = (keysym <= 0x7F) ? keysym : 0;
 		} else {
-		  ckey[i] = KEYBOARD_MapDeadKeysym(keysym);
+            ckey[i] = KEYBOARD_MapDeadKeysym(keysym);
 		}
 	      }
 	      /* find key with longest match streak */
@@ -1807,7 +1788,7 @@
     for (scan = 0x60, keyc = min_keycode; keyc <= max_keycode; keyc++)
       if (keyc2vkey[keyc]&&!keyc2scan[keyc]) {
 	const char *ksname;
-	keysym = XkbKeycodeToKeysym( display, keyc, 0, 0 );
+	keysym = keycode_to_keysym( display, keyc, 0 );
 	ksname = XKeysymToString(keysym);
 	if (!ksname) ksname = "NoSymbol";
 
@@ -1915,7 +1896,7 @@
     }
 
     for (index = 0; index < 4; index++) /* find shift state */
-        if (XkbKeycodeToKeysym( display, keycode, 0, index ) == keysym) break;
+        if (keycode_to_keysym( display, keycode, index ) == keysym) break;
 
     pthread_mutex_unlock( &kbd_mutex );
 
@@ -2165,7 +2146,7 @@
       INT rc;
 
       keyc = (KeyCode) keyi;
-      keys = XkbKeycodeToKeysym( display, keyc, 0, 0 );
+      keys = keycode_to_keysym( display, keyc, 0 );
       name = XKeysymToString(keys);
 
       if (name && (vkey == VK_SHIFT || vkey == VK_CONTROL || vkey == VK_MENU))
diff -urN wine-9.2/dlls/winex11.drv/vulkan.c wine-9.2-custom-main/dlls/winex11.drv/vulkan.c
--- wine-9.2/dlls/winex11.drv/vulkan.c	2024-02-10 05:46:52.000000000 +0800
+++ wine-9.2-custom-main/dlls/winex11.drv/vulkan.c	2025-07-31 04:11:27.000000000 +0800
@@ -307,13 +307,6 @@
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-    /* TODO: support child window rendering. */
-    if (create_info->hwnd && NtUserGetAncestor(create_info->hwnd, GA_PARENT) != NtUserGetDesktopWindow())
-    {
-        FIXME("Application requires child window rendering, which is not implemented yet!\n");
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-
     x11_surface = calloc(1, sizeof(*x11_surface));
     if (!x11_surface)
         return VK_ERROR_OUT_OF_HOST_MEMORY;
diff -urN wine-9.2/dlls/winex11.drv/window.c wine-9.2-custom-main/dlls/winex11.drv/window.c
--- wine-9.2/dlls/winex11.drv/window.c	2024-02-10 05:46:52.000000000 +0800
+++ wine-9.2-custom-main/dlls/winex11.drv/window.c	2025-07-31 04:11:27.000000000 +0800
@@ -484,73 +484,6 @@
 
 
 /***********************************************************************
- *              get_bitmap_argb
- *
- * Return the bitmap bits in ARGB format. Helper for setting icon hints.
- */
-static unsigned long *get_bitmap_argb( HDC hdc, HBITMAP color, HBITMAP mask, unsigned int *size )
-{
-    char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
-    BITMAPINFO *info = (BITMAPINFO *)buffer;
-    BITMAP bm;
-    unsigned int *ptr, *bits = NULL;
-    unsigned char *mask_bits = NULL;
-    int i, j;
-    BOOL has_alpha = FALSE;
-
-    if (!NtGdiExtGetObjectW( color, sizeof(bm), &bm )) return NULL;
-    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-    info->bmiHeader.biWidth = bm.bmWidth;
-    info->bmiHeader.biHeight = -bm.bmHeight;
-    info->bmiHeader.biPlanes = 1;
-    info->bmiHeader.biBitCount = 32;
-    info->bmiHeader.biCompression = BI_RGB;
-    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
-    info->bmiHeader.biXPelsPerMeter = 0;
-    info->bmiHeader.biYPelsPerMeter = 0;
-    info->bmiHeader.biClrUsed = 0;
-    info->bmiHeader.biClrImportant = 0;
-    *size = bm.bmWidth * bm.bmHeight + 2;
-    if (!(bits = malloc( *size * sizeof(long) ))) goto failed;
-    if (!NtGdiGetDIBitsInternal( hdc, color, 0, bm.bmHeight, bits + 2, info, DIB_RGB_COLORS, 0, 0 ))
-        goto failed;
-
-    bits[0] = bm.bmWidth;
-    bits[1] = bm.bmHeight;
-
-    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
-        if ((has_alpha = (bits[i + 2] & 0xff000000) != 0)) break;
-
-    if (!has_alpha)
-    {
-        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
-        /* generate alpha channel from the mask */
-        info->bmiHeader.biBitCount = 1;
-        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
-        if (!(mask_bits = malloc( info->bmiHeader.biSizeImage ))) goto failed;
-        if (!NtGdiGetDIBitsInternal( hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS, 0, 0 ))
-            goto failed;
-        ptr = bits + 2;
-        for (i = 0; i < bm.bmHeight; i++)
-            for (j = 0; j < bm.bmWidth; j++, ptr++)
-                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
-        free( mask_bits );
-    }
-
-    /* convert to array of longs */
-    if (bits && sizeof(long) > sizeof(int))
-        for (i = *size - 1; i >= 0; i--) ((unsigned long *)bits)[i] = bits[i];
-
-    return (unsigned long *)bits;
-
-failed:
-    free( bits );
-    free( mask_bits );
-    return NULL;
-}
-
-
-/***********************************************************************
  *              create_icon_pixmaps
  */
 static BOOL create_icon_pixmaps( HDC hdc, const ICONINFO *icon, Pixmap *icon_ret, Pixmap *mask_ret )
@@ -619,10 +552,8 @@
 static void fetch_icon_data( HWND hwnd, HICON icon_big, HICON icon_small )
 {
     struct x11drv_win_data *data;
-    ICONINFO ii, ii_small;
+    ICONINFO ii;
     HDC hDC;
-    unsigned int size;
-    unsigned long *bits;
     Pixmap icon_pixmap, mask_pixmap;
 
     icon_big = get_icon_info( icon_big, &ii );
@@ -639,38 +570,9 @@
         }
     }
 
-    icon_small = get_icon_info( icon_small, &ii_small );
-    if (!icon_small)
-    {
-        icon_small = get_icon_info( (HICON)send_message( hwnd, WM_GETICON, ICON_SMALL, 0 ), &ii_small );
-        if (!icon_small)
-            icon_small = get_icon_info( (HICON)NtUserGetClassLongPtrW( hwnd, GCLP_HICONSM ), &ii_small );
-    }
-
     if (!icon_big) return;
 
     hDC = NtGdiCreateCompatibleDC(0);
-    bits = get_bitmap_argb( hDC, ii.hbmColor, ii.hbmMask, &size );
-    if (bits && icon_small)
-    {
-        unsigned int size_small;
-        unsigned long *bits_small, *new;
-
-        if ((bits_small = get_bitmap_argb( hDC, ii_small.hbmColor, ii_small.hbmMask, &size_small )) &&
-            (bits_small[0] != bits[0] || bits_small[1] != bits[1]))  /* size must be different */
-        {
-            if ((new = realloc( bits, (size + size_small) * sizeof(unsigned long) )))
-            {
-                bits = new;
-                memcpy( bits + size, bits_small, size_small * sizeof(unsigned long) );
-                size += size_small;
-            }
-        }
-        free( bits_small );
-        NtGdiDeleteObjectApp( ii_small.hbmColor );
-        NtGdiDeleteObjectApp( ii_small.hbmMask );
-    }
-
     if (!create_icon_pixmaps( hDC, &ii, &icon_pixmap, &mask_pixmap )) icon_pixmap = mask_pixmap = 0;
 
     NtGdiDeleteObjectApp( ii.hbmColor );
@@ -681,18 +583,14 @@
     {
         if (data->icon_pixmap) XFreePixmap( gdi_display, data->icon_pixmap );
         if (data->icon_mask) XFreePixmap( gdi_display, data->icon_mask );
-        free( data->icon_bits );
         data->icon_pixmap = icon_pixmap;
         data->icon_mask = mask_pixmap;
-        data->icon_bits = bits;
-        data->icon_size = size;
         release_win_data( data );
     }
     else
     {
         if (icon_pixmap) XFreePixmap( gdi_display, icon_pixmap );
         if (mask_pixmap) XFreePixmap( gdi_display, mask_pixmap );
-        free( bits );
     }
 }
 
@@ -794,6 +692,7 @@
     HWND owner = NtUserGetWindowRelative( data->hwnd, GW_OWNER );
     Window owner_win = 0;
     XWMHints *wm_hints;
+    int WindowLayeredHint = data->layered ? (1 << 16) : 0;
     Atom window_type;
 
     if (owner)
@@ -822,7 +721,7 @@
 
     if ((wm_hints = XAllocWMHints()))
     {
-        wm_hints->flags = InputHint | StateHint | WindowGroupHint;
+        wm_hints->flags = InputHint | StateHint | WindowGroupHint | WindowLayeredHint;
         wm_hints->input = !use_take_focus && !(style & WS_DISABLED);
         wm_hints->initial_state = (style & WS_MINIMIZE) ? IconicState : NormalState;
         wm_hints->window_group = group_leader;
@@ -835,14 +734,6 @@
         XSetWMHints( data->display, data->whole_window, wm_hints );
         XFree( wm_hints );
     }
-
-    if (data->icon_bits)
-        XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_ICON),
-                         XA_CARDINAL, 32, PropModeReplace,
-                         (unsigned char *)data->icon_bits, data->icon_size );
-    else
-        XDeleteProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_ICON) );
-
 }
 
 
@@ -851,12 +742,15 @@
  *
  * Set the window manager hints that don't change over the lifetime of a window.
  */
-static void set_initial_wm_hints( Display *display, Window window )
+static void set_initial_wm_hints( Display *display, Window window, HWND hwnd )
 {
     long i;
+    DWORD pid = 0;
     Atom protocols[3];
+    BOOL is_wow64 = FALSE;
     Atom dndVersion = WINE_XDND_VERSION;
     XClassHint *class_hints;
+    ULONG_PTR pbi;
 
     /* wm protocols */
     i = 0;
@@ -876,11 +770,15 @@
     }
 
     /* set the WM_CLIENT_MACHINE and WM_LOCALE_NAME properties */
-    XSetWMProperties(display, window, NULL, NULL, NULL, 0, NULL, NULL, NULL);
-    /* set the pid. together, these properties are needed so the window manager can kill us if we freeze */
-    i = getpid();
-    XChangeProperty(display, window, x11drv_atom(_NET_WM_PID),
-                    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&i, 1);
+    XSetWMProperties( display, window, NULL, NULL, NULL, 0, NULL, NULL, NULL );
+
+    pid = GetCurrentProcessId();
+    XChangeProperty( display, window, x11drv_atom(_NET_WM_PID ),
+                    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&pid, 1);
+                    
+    if (!NtQueryInformationProcess( GetCurrentProcess(), ProcessWow64Information, &pbi, sizeof(pbi), NULL )) is_wow64 = !!pbi;
+    XChangeProperty( display, window, x11drv_atom(_NET_WM_WOW64),
+                     XA_CARDINAL, 8, PropModeReplace, (unsigned char *)&is_wow64, 1 );
 
     XChangeProperty( display, window, x11drv_atom(XdndAware),
                      XA_ATOM, 32, PropModeReplace, (unsigned char*)&dndVersion, 1 );
@@ -889,6 +787,9 @@
     if (user_time_window)
         XChangeProperty( display, window, x11drv_atom(_NET_WM_USER_TIME_WINDOW),
                          XA_WINDOW, 32, PropModeReplace, (unsigned char *)&user_time_window, 1 );
+                         
+    XChangeProperty( display, window, x11drv_atom(_NET_WM_HWND),
+                     XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&hwnd, 2 );
 }
 
 
@@ -1657,6 +1558,10 @@
                                                CWBackingStore | CWColormap | CWBorderPixel, &attr );
     if (data->client_window)
     {
+        const BOOL is_surface = TRUE;
+        XChangeProperty( gdi_display, data->client_window, x11drv_atom(_NET_WM_SURFACE),
+                         XA_CARDINAL, 8, PropModeReplace, (unsigned char *)&is_surface, 1 );
+        
         XSaveContext( data->display, data->client_window, winContext, (char *)data->hwnd );
         XMapWindow( gdi_display, data->client_window );
         if (data->whole_window)
@@ -1718,7 +1623,7 @@
                                         data->vis.visual, mask, &attr );
     if (!data->whole_window) goto done;
 
-    set_initial_wm_hints( data->display, data->whole_window );
+    set_initial_wm_hints( data->display, data->whole_window, data->hwnd );
     set_wm_hints( data );
 
     XSaveContext( data->display, data->whole_window, winContext, (char *)data->hwnd );
@@ -1892,7 +1797,6 @@
     if (data->icon_pixmap) XFreePixmap( gdi_display, data->icon_pixmap );
     if (data->icon_mask) XFreePixmap( gdi_display, data->icon_mask );
     if (data->client_colormap) XFreeColormap( data->display, data->client_colormap );
-    free( data->icon_bits );
     XDeleteContext( gdi_display, (XID)hwnd, win_data_context );
     release_win_data( data );
     free( data );
@@ -1931,7 +1835,7 @@
     data->whole_window = win;
     data->managed = TRUE;
     NtUserSetProp( data->hwnd, whole_window_prop, (HANDLE)win );
-    set_initial_wm_hints( display, win );
+    set_initial_wm_hints( display, win, data->hwnd );
     release_win_data( data );
     if (thread_data->clip_window) XReparentWindow( display, thread_data->clip_window, win, 0, 0 );
     return TRUE;
diff -urN wine-9.2/dlls/winex11.drv/x11drv.h wine-9.2-custom-main/dlls/winex11.drv/x11drv.h
--- wine-9.2/dlls/winex11.drv/x11drv.h	2024-02-10 05:46:52.000000000 +0800
+++ wine-9.2-custom-main/dlls/winex11.drv/x11drv.h	2025-07-31 04:11:27.000000000 +0800
@@ -550,6 +550,9 @@
     XATOM_text_rtf,
     XATOM_text_richtext,
     XATOM_text_uri_list,
+    XATOM__NET_WM_HWND,
+    XATOM__NET_WM_WOW64,
+    XATOM__NET_WM_SURFACE,
     NB_XATOMS
 };
 
@@ -636,8 +639,6 @@
     struct window_surface *surface;
     Pixmap         icon_pixmap;
     Pixmap         icon_mask;
-    unsigned long *icon_bits;
-    unsigned int   icon_size;
 };
 
 extern struct x11drv_win_data *get_win_data( HWND hwnd );
diff -urN wine-9.2/dlls/winex11.drv/x11drv_main.c wine-9.2-custom-main/dlls/winex11.drv/x11drv_main.c
--- wine-9.2/dlls/winex11.drv/x11drv_main.c	2024-02-10 05:46:52.000000000 +0800
+++ wine-9.2-custom-main/dlls/winex11.drv/x11drv_main.c	2025-07-31 04:11:27.000000000 +0800
@@ -36,7 +36,6 @@
 #include <dlfcn.h>
 #include <X11/cursorfont.h>
 #include <X11/Xlib.h>
-#include <X11/XKBlib.h>
 #ifdef HAVE_X11_EXTENSIONS_XRENDER_H
 #include <X11/extensions/Xrender.h>
 #endif
@@ -215,7 +214,10 @@
     "text/plain",
     "text/rtf",
     "text/richtext",
-    "text/uri-list"
+    "text/uri-list",
+    "_NET_WM_HWND",
+    "_NET_WM_WOW64",
+    "_NET_WM_SURFACE"
 };
 
 /***********************************************************************
@@ -699,7 +701,6 @@
 #endif
     X11DRV_XInput2_Init();
 
-    XkbUseExtension( gdi_display, NULL, NULL );
     X11DRV_InitKeyboard( gdi_display );
     if (use_xim) use_xim = xim_init( input_style );
 
@@ -778,8 +779,6 @@
 
     fcntl( ConnectionNumber(data->display), F_SETFD, 1 ); /* set close on exec flag */
 
-    XkbUseExtension( data->display, NULL, NULL );
-    XkbSetDetectableAutoRepeat( data->display, True, NULL );
     if (TRACE_ON(synchronous)) XSynchronize( data->display, True );
 
     set_queue_display_fd( data->display );
