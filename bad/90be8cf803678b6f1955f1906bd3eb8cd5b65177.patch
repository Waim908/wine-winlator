From 90be8cf803678b6f1955f1906bd3eb8cd5b65177 Mon Sep 17 00:00:00 2001
From: BrunoSX <brunodeveloper85@gmail.com>
Date: Sat, 15 Mar 2025 16:58:52 -0300
Subject: [PATCH] Apply ntdll-Syscall_Emulation patch

---
 dlls/ntdll/unix/signal_x86_64.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 405ac49e..73fdcdee 100755
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -65,6 +65,10 @@
 # include <mach/mach.h>
 #endif
 
+#include <sys/prctl.h>
+#include <errno.h>
+#include <fcntl.h>
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -1783,6 +1787,25 @@ static inline DWORD is_privileged_instr( CONTEXT *context )
     return 0;
 }
 
+static void sigsys_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    extern const void *__wine_syscall_dispatcher_prolog_end_ptr;
+    struct syscall_frame *frame = amd64_thread_data()->syscall_frame;
+    ucontext_t *ctx = sigcontext;
+
+    TRACE_(seh)( "SIGSYS, rax %#llx, rip %#llx.\n", ctx->uc_mcontext.gregs[REG_RAX],
+            ctx->uc_mcontext.gregs[REG_RIP] );
+
+    frame->rip = ctx->uc_mcontext.gregs[REG_RIP] + 0xb;
+    frame->rcx = ctx->uc_mcontext.gregs[REG_RIP];
+    frame->eflags = ctx->uc_mcontext.gregs[REG_EFL];
+    frame->restore_flags = 0;
+    ctx->uc_mcontext.gregs[REG_RCX] = (ULONG_PTR)frame;
+    ctx->uc_mcontext.gregs[REG_R11] = frame->eflags;
+    ctx->uc_mcontext.gregs[REG_EFL] &= ~0x100;  /* clear single-step flag */
+    ctx->uc_mcontext.gregs[REG_RIP] = (ULONG64)__wine_syscall_dispatcher_prolog_end_ptr;
+}
+
 
 /***********************************************************************
  *           handle_interrupt
@@ -2460,6 +2483,8 @@ void signal_init_process(void)
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = sigsys_handler;
+    if (sigaction( SIGSYS, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
