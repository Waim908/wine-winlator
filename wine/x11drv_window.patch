diff -urN wine-10.15/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
--- wine-10.15/dlls/winex11.drv/window.c	2025-09-13 03:36:38.000000000 +0800
+++ b/dlls/winex11.drv/window.c	2025-11-10 20:15:59.112376243 +0800
@@ -648,78 +648,6 @@
     free( buffer );
 }
 
-
-/***********************************************************************
- *              get_bitmap_argb
- *
- * Return the bitmap bits in ARGB format. Helper for setting icon hints.
- */
-static unsigned long *get_bitmap_argb( HDC hdc, HBITMAP color, HBITMAP mask, unsigned int *size )
-{
-    char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
-    BITMAPINFO *info = (BITMAPINFO *)buffer;
-    BITMAP bm;
-    unsigned long *bits = NULL;
-    unsigned int *ptr;
-    unsigned char *mask_bits = NULL;
-    int i, j;
-    BOOL has_alpha = FALSE;
-
-    if (!NtGdiExtGetObjectW( color, sizeof(bm), &bm )) return NULL;
-    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-    info->bmiHeader.biWidth = bm.bmWidth;
-    info->bmiHeader.biHeight = -bm.bmHeight;
-    info->bmiHeader.biPlanes = 1;
-    info->bmiHeader.biBitCount = 32;
-    info->bmiHeader.biCompression = BI_RGB;
-    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
-    info->bmiHeader.biXPelsPerMeter = 0;
-    info->bmiHeader.biYPelsPerMeter = 0;
-    info->bmiHeader.biClrUsed = 0;
-    info->bmiHeader.biClrImportant = 0;
-    *size = bm.bmWidth * bm.bmHeight + 2;
-    if (!(bits = malloc( *size * sizeof(*bits) ))) goto failed;
-    ptr = (unsigned int *)bits;
-    if (!NtGdiGetDIBitsInternal( hdc, color, 0, bm.bmHeight, ptr + 2, info, DIB_RGB_COLORS, 0, 0 ))
-        goto failed;
-
-    ptr[0] = bm.bmWidth;
-    ptr[1] = bm.bmHeight;
-
-    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
-        if ((has_alpha = (ptr[i + 2] & 0xff000000) != 0)) break;
-
-    if (!has_alpha)
-    {
-        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
-        /* generate alpha channel from the mask */
-        info->bmiHeader.biBitCount = 1;
-        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
-        if (!(mask_bits = malloc( info->bmiHeader.biSizeImage ))) goto failed;
-        if (!NtGdiGetDIBitsInternal( hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS, 0, 0 ))
-            goto failed;
-        ptr = (unsigned int *)bits + 2;
-        for (i = 0; i < bm.bmHeight; i++)
-            for (j = 0; j < bm.bmWidth; j++, ptr++)
-                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
-        free( mask_bits );
-    }
-
-    /* convert to array of longs */
-    if (bits && sizeof(long) > sizeof(int))
-    {
-        ptr = (unsigned int *)bits;
-        for (i = *size - 1; i >= 0; i--) bits[i] = ptr[i];
-    }
-    return bits;
-
-failed:
-    free( bits );
-    free( mask_bits );
-    return NULL;
-}
-
-
 /***********************************************************************
  *              create_icon_pixmaps
  */
@@ -789,10 +717,8 @@
 static void fetch_icon_data( HWND hwnd, HICON icon_big, HICON icon_small )
 {
     struct x11drv_win_data *data;
-    ICONINFO ii, ii_small;
+    ICONINFO ii;
     HDC hDC;
-    unsigned int size;
-    unsigned long *bits;
     Pixmap icon_pixmap, mask_pixmap;
 
     icon_big = get_icon_info( icon_big, &ii );
@@ -809,37 +735,9 @@
         }
     }
 
-    icon_small = get_icon_info( icon_small, &ii_small );
-    if (!icon_small)
-    {
-        icon_small = get_icon_info( (HICON)send_message( hwnd, WM_GETICON, ICON_SMALL, 0 ), &ii_small );
-        if (!icon_small)
-            icon_small = get_icon_info( (HICON)NtUserGetClassLongPtrW( hwnd, GCLP_HICONSM ), &ii_small );
-    }
-
     if (!icon_big) return;
 
     hDC = NtGdiCreateCompatibleDC(0);
-    bits = get_bitmap_argb( hDC, ii.hbmColor, ii.hbmMask, &size );
-    if (bits && icon_small)
-    {
-        unsigned int size_small;
-        unsigned long *bits_small, *new;
-
-        if ((bits_small = get_bitmap_argb( hDC, ii_small.hbmColor, ii_small.hbmMask, &size_small )) &&
-            (bits_small[0] != bits[0] || bits_small[1] != bits[1]))  /* size must be different */
-        {
-            if ((new = realloc( bits, (size + size_small) * sizeof(unsigned long) )))
-            {
-                bits = new;
-                memcpy( bits + size, bits_small, size_small * sizeof(unsigned long) );
-                size += size_small;
-            }
-        }
-        free( bits_small );
-        NtGdiDeleteObjectApp( ii_small.hbmColor );
-        NtGdiDeleteObjectApp( ii_small.hbmMask );
-    }
 
     if (!create_icon_pixmaps( hDC, &ii, &icon_pixmap, &mask_pixmap )) icon_pixmap = mask_pixmap = 0;
 
@@ -851,18 +749,14 @@
     {
         if (data->icon_pixmap) XFreePixmap( gdi_display, data->icon_pixmap );
         if (data->icon_mask) XFreePixmap( gdi_display, data->icon_mask );
-        free( data->icon_bits );
         data->icon_pixmap = icon_pixmap;
         data->icon_mask = mask_pixmap;
-        data->icon_bits = bits;
-        data->icon_size = size;
         release_win_data( data );
     }
     else
     {
         if (icon_pixmap) XFreePixmap( gdi_display, icon_pixmap );
         if (mask_pixmap) XFreePixmap( gdi_display, mask_pixmap );
-        free( bits );
     }
 }
 
@@ -1023,6 +917,7 @@
     HWND owner = NtUserGetWindowRelative( data->hwnd, GW_OWNER );
     Window owner_win = 0;
     XWMHints *wm_hints;
+    int WindowLayeredHint = data->layered ? (1 << 16) : 0;
     Atom window_type;
 
     if (owner)
@@ -1053,7 +948,7 @@
 
     if ((wm_hints = XAllocWMHints()))
     {
-        wm_hints->flags = InputHint | StateHint | WindowGroupHint;
+        wm_hints->flags = InputHint | StateHint | WindowGroupHint | WindowLayeredHint;
         wm_hints->input = !use_take_focus && !(style & WS_DISABLED);
         wm_hints->initial_state = (style & WS_MINIMIZE) ? IconicState : NormalState;
         wm_hints->window_group = group_leader;
@@ -1069,22 +964,6 @@
         XSetWMHints( data->display, data->whole_window, wm_hints );
         XFree( wm_hints );
     }
-
-    if (data->icon_bits)
-    {
-        TRACE( "window %p/%lx requesting _NET_WM_ICON, serial %lu\n", data->hwnd,
-               data->whole_window, NextRequest( data->display ) );
-        XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_ICON),
-                         XA_CARDINAL, 32, PropModeReplace,
-                         (unsigned char *)data->icon_bits, data->icon_size );
-    }
-    else
-    {
-        TRACE( "window %p/%lx deleting _NET_WM_ICON, serial %lu\n", data->hwnd,
-               data->whole_window, NextRequest( data->display ) );
-        XDeleteProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_ICON) );
-    }
-
 }
 
 
@@ -1093,12 +972,15 @@
  *
  * Set the window manager hints that don't change over the lifetime of a window.
  */
-static void set_initial_wm_hints( Display *display, Window window )
+static void set_initial_wm_hints( Display *display, Window window , HWND hwnd )
 {
     long i;
+    DWORD pid = 0;
     Atom protocols[3];
+    BOOL is_wow64 = FALSE;
     Atom dndVersion = WINE_XDND_VERSION;
     XClassHint *class_hints;
+    ULONG_PTR pbi;
 
     /* wm protocols */
     i = 0;
@@ -1118,14 +1000,19 @@
     }
 
     /* set the WM_CLIENT_MACHINE and WM_LOCALE_NAME properties */
-    XSetWMProperties(display, window, NULL, NULL, NULL, 0, NULL, NULL, NULL);
-    /* set the pid. together, these properties are needed so the window manager can kill us if we freeze */
-    i = getpid();
-    XChangeProperty(display, window, x11drv_atom(_NET_WM_PID),
-                    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&i, 1);
+    XSetWMProperties( display, window, NULL, NULL, NULL, 0, NULL, NULL, NULL );
 
+    pid = GetCurrentProcessId();
+    XChangeProperty( display, window, x11drv_atom(_NET_WM_PID ),
+                    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&pid, 1);
+                    
+    if (!NtQueryInformationProcess( GetCurrentProcess(), ProcessWow64Information, &pbi, sizeof(pbi), NULL )) is_wow64 = !!pbi;
+    XChangeProperty( display, window, x11drv_atom(_NET_WM_WOW64),
+                     XA_CARDINAL, 8, PropModeReplace, (unsigned char *)&is_wow64, 1 );
     XChangeProperty( display, window, x11drv_atom(XdndAware),
                      XA_ATOM, 32, PropModeReplace, (unsigned char*)&dndVersion, 1 );
+    XChangeProperty( display, window, x11drv_atom(_NET_WM_HWND),
+		     XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&hwnd, 2 );
 }
 
 
@@ -2317,6 +2204,10 @@
                                                CWBackingStore | CWColormap | CWBorderPixel, &attr );
     if (data->client_window)
     {
+        const BOOL is_surface = TRUE;
+        XChangeProperty( gdi_display, data->client_window, x11drv_atom(_NET_WM_SURFACE),
+                         XA_CARDINAL, 8, PropModeReplace, (unsigned char *)&is_surface, 1 );
+
         XMapWindow( gdi_display, data->client_window );
         if (data->whole_window)
         {
@@ -2376,7 +2267,7 @@
     data->desired_state.rect = data->current_state.rect;
 
     x11drv_xinput2_enable( data->display, data->whole_window );
-    set_initial_wm_hints( data->display, data->whole_window );
+    set_initial_wm_hints( data->display, data->whole_window, data->hwnd );
     set_wm_hints( data );
 
     XSaveContext( data->display, data->whole_window, winContext, (char *)data->hwnd );
@@ -2546,7 +2437,6 @@
     if (data->icon_pixmap) XFreePixmap( gdi_display, data->icon_pixmap );
     if (data->icon_mask) XFreePixmap( gdi_display, data->icon_mask );
     if (data->parent) host_window_release( data->parent );
-    free( data->icon_bits );
     XDeleteContext( gdi_display, (XID)hwnd, win_data_context );
     release_win_data( data );
     free( data );
@@ -2583,7 +2473,7 @@
     data->whole_window = win;
     window_set_managed( data, TRUE );
     NtUserSetProp( data->hwnd, whole_window_prop, (HANDLE)win );
-    set_initial_wm_hints( display, win );
+    set_initial_wm_hints( display, win, data->hwnd );
     if (is_desktop_fullscreen()) window_set_net_wm_state( data, (1 << NET_WM_STATE_FULLSCREEN) );
     release_win_data( data );
     if (thread_data->clip_window) XReparentWindow( display, thread_data->clip_window, win, 0, 0 );
