--- ValveSoftware-winegit/dlls/midimap/midimap.c	2025-10-28 16:50:44.071251343 +0000
+++ midi/dlls/midimap/midimap.c	2025-10-28 23:50:40.513621818 +0000
@@ -1,7 +1,8 @@
 /*
  * Wine MIDI mapper driver
  *
- * Copyright 	1999, 2000, 2001 Eric Pouech
+ * Copyright 1999, 2000, 2001 Eric Pouech
+ * Copyright 2025 BrunoSX
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -17,9 +18,6 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  *
- * TODO:
- *	notification has to be implemented
- *	IDF file loading
  */
 
 #include <stdarg.h>
@@ -32,377 +30,191 @@
 #include "mmddk.h"
 #include "winreg.h"
 #include "wine/debug.h"
-
-/*
- * Here's how Windows stores the midiOut mapping information.
- *
- * Windows XP form (in HKU) is:
- *
- * [Software\\Microsoft\\Windows\\CurrentVersion\\Multimedia\\MIDIMap]
- * "szPname"="TiMidity port 0"
- * (incomplete)
- *
- * szPname:             name of midiOut device to use.
- *
- * If szPname isn't defined, we use Windows 2000 form (also in HKU):
- *
- * [Software\\Microsoft\\Windows\\CurrentVersion\\Multimedia\\MIDIMap] 988836060
- * "AutoScheme"=dword:00000000
- * "ConfigureCount"=dword:00000004
- * "CurrentInstrument"="Wine OSS midi"
- * "CurrentScheme"="epp"
- * "DriverList"=""
- * "UseScheme"=dword:00000000
- *
- * AutoScheme: 		?
- * CurrentInstrument: 	name of midiOut device to use when UseScheme is 0. Wine uses an extension
- *			of the form #n to link to n'th midiOut device of the system
- * CurrentScheme:	when UseScheme is non null, it's the scheme to use (see below)
- * DriverList:		?
- * UseScheme:		trigger for simple/complex mapping
- *
- * A scheme is defined (in HKLM) as:
- *
- * [System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Midi\\Schemes\\<nameScheme>]
- * <nameScheme>:	one key for each defined scheme (system wide)
- * under each one of these <nameScheme> keys, there's:
- * [...\\<nameScheme>\\<idxDevice>]
- * "Channels"="<bitMask>"
- * (the default value of this key also refers to the name of the device).
- *
- * this defines, for each midiOut device (identified by its index in <idxDevice>), which
- * channels have to be mapped onto it. The <bitMask> defines the channels (from 0 to 15)
- * will be mapped (mapping occurs for channel <ch> if bit <ch> is set in <bitMask>
- *
- * Further mapping information can also be defined in:
- * [System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Midi\\Ports\\<nameDevice>\\Instruments\\<idx>]
- * "Definition"="<.idf file>"
- * "FriendlyName"="#for .idx file#"
- * "Port"="<idxPort>"
- *
- * This last part isn't implemented (.idf file support).
- */
+#include "winsock2.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(midi);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
-typedef struct tagMIDIOUTPORT
+#define MIDI_OUT_PORT 7950
+#define MIDI_IN_PORT 7951
+#define MIDI_OPEN_PORT 7947
+
+#define REQUEST_CODE_MIDI_OPEN 16
+#define REQUEST_CODE_MIDI_CLOSE 17
+
+typedef struct tagMIDIINDEV
 {
-    WCHAR		name[MAXPNAMELEN];
-    int			loaded;
-    HMIDIOUT		hMidi;
-    unsigned short	uDevID;
-    LPBYTE		lpbPatch;
-    unsigned int	aChn[16];
-} MIDIOUTPORT;
-
-typedef	struct tagMIDIMAPDATA
-{
-    struct tagMIDIMAPDATA*	self;
-    MIDIOUTPORT*	ChannelMap[16];
-    MIDIOPENDESC	midiDesc;
-    BYTE		runningStatus;
-    WORD		wCbFlags;
-} MIDIMAPDATA;
-
-static	MIDIOUTPORT*	midiOutPorts;
-static  unsigned	numMidiOutPorts;
-
-static	BOOL	MIDIMAP_IsBadData(MIDIMAPDATA* mm)
-{
-    if (!IsBadReadPtr(mm, sizeof(MIDIMAPDATA)) && mm->self == mm)
-	return FALSE;
-    TRACE("Bad midimap data (%p)\n", mm);
-    return TRUE;
-}
+    BOOL running;
+    HANDLE thread;
+    LPMIDIOPENDESC midiDesc;
+    WORD wCbFlags;
+} MIDIINDEV;
+
+typedef	struct tagMIDIOUTDEV
+{
+    LPMIDIOPENDESC midiDesc;
+    BYTE runningStatus;
+    WORD wCbFlags;
+} MIDIOUTDEV;
+
+static MIDIOUTDEV midiOutDev = {0};
+static MIDIINDEV midiInDev = {0};
+
+static SOCKET serverSock = INVALID_SOCKET;
+static BOOL winsockLoaded = FALSE;
 
-static BOOL	MIDIMAP_FindPort(const WCHAR* name, unsigned* dev)
+static void closeServerSocket(void)
 {
-    for (*dev = 0; *dev < numMidiOutPorts; (*dev)++)
+    if (serverSock != INVALID_SOCKET)
     {
-	TRACE("%s\n", wine_dbgstr_w(midiOutPorts[*dev].name));
-	if (lstrcmpW(midiOutPorts[*dev].name, name) == 0)
-	    return TRUE;
+        closesocket(serverSock);
+        serverSock = INVALID_SOCKET;
     }
-    /* try the form #nnn */
-    if (*name == '#' && name[1] >= '0' && name[1] <= '9')
+
+    if (winsockLoaded)
     {
-        const WCHAR*  ptr = name + 1;
-        *dev = 0;
-        do 
-        {
-            *dev = *dev * 10 + *ptr - '0';
-            ptr++;
-        } while (*ptr >= '0' && *ptr <= '9');
-	if (*dev < numMidiOutPorts)
-	    return TRUE;
+        WSACleanup();
+        winsockLoaded = FALSE;
     }
-    return FALSE;
 }
 
-static BOOL	MIDIMAP_LoadSettingsDefault(MIDIMAPDATA* mom, const WCHAR* port)
+static BOOL createServerSocket(void)
 {
-    unsigned i, dev = 0;
+    WSADATA wsaData;
+    struct sockaddr_in serverAddr;
+    const UINT reuseAddr = 1;
+    ULONG nonBlocking = 1;
+    int res;
 
-    if (port != NULL && !MIDIMAP_FindPort(port, &dev))
-    {
-	ERR("Registry glitch: couldn't find midi out (%s)\n", wine_dbgstr_w(port));
-	dev = 0;
-    }
+    closeServerSocket();
+
+    winsockLoaded = WSAStartup(MAKEWORD(2,2), &wsaData) == NO_ERROR;
+    if (!winsockLoaded) return FALSE;
+
+    serverAddr.sin_family = AF_INET;
+    serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    serverAddr.sin_port = htons(MIDI_IN_PORT);
 
-    /* this is necessary when no midi out ports are present */
-    if (dev >= numMidiOutPorts)
-	return FALSE;
-    /* sets default */
-    for (i = 0; i < 16; i++) mom->ChannelMap[i] = &midiOutPorts[dev];
+    serverSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (serverSock == INVALID_SOCKET) return FALSE;
+
+    res = setsockopt(serverSock, SOL_SOCKET, SO_REUSEADDR, (const char *)&reuseAddr, sizeof(reuseAddr));
+    if (res == SOCKET_ERROR) return FALSE;
+
+    ioctlsocket(serverSock, FIONBIO, &nonBlocking);
+
+    res = bind(serverSock, (struct sockaddr*)&serverAddr, sizeof(serverAddr));
+    if (res == SOCKET_ERROR) return FALSE;
 
     return TRUE;
 }
 
-static BOOL	MIDIMAP_LoadSettingsScheme(MIDIMAPDATA* mom, const WCHAR* scheme)
+static void midiOpenRequest(BOOL isMidiOut)
 {
-    HKEY	hSchemesKey, hKey, hPortKey;
-    unsigned	i, idx, dev;
-    WCHAR       buffer[256], port[256];
-    DWORD	type, size, mask;
-
-    for (i = 0; i < 16; i++)	mom->ChannelMap[i] = NULL;
-
-    if (RegOpenKeyA(HKEY_LOCAL_MACHINE,
-		    "System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Midi\\Schemes",
-		    &hSchemesKey))
-    {
-	return FALSE;
-    }
-    if (RegOpenKeyW(hSchemesKey, scheme, &hKey))
-    {
-	RegCloseKey(hSchemesKey);
-	return FALSE;
-    }
-
-    for (idx = 0; !RegEnumKeyW(hKey, idx, buffer, ARRAY_SIZE(buffer)); idx++)
-    {
-	if (RegOpenKeyW(hKey, buffer, &hPortKey)) continue;
+    char buffer[64] = {0};
+    struct sockaddr_in clientAddr;
 
-	size = sizeof(port);
-	if (RegQueryValueExW(hPortKey, NULL, 0, &type, (void*)port, &size)) continue;
+    clientAddr.sin_family = AF_INET;
+    clientAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    clientAddr.sin_port = htons(MIDI_OPEN_PORT);
 
-	if (!MIDIMAP_FindPort(port, &dev)) continue;
+    buffer[0] = REQUEST_CODE_MIDI_OPEN;
+    buffer[1] = isMidiOut ? 1 : 0;
+    sendto(serverSock, buffer, 64, 0, (struct sockaddr*)&clientAddr, sizeof(clientAddr));
+}
 
-	size = sizeof(mask);
-	if (RegQueryValueExA(hPortKey, "Channels", 0, &type, (void*)&mask, &size))
-	    continue;
-
-	for (i = 0; i < 16; i++)
-	{
-	    if (mask & (1 << i))
-	    {
-		if (mom->ChannelMap[i])
-		    ERR("Quirks in registry, channel %u is mapped twice\n", i);
-		mom->ChannelMap[i] = &midiOutPorts[dev];
-	    }
-	}
-    }
+static void midiCloseRequest(BOOL isMidiOut)
+{
+    char buffer[64] = {0};
+    struct sockaddr_in clientAddr;
 
-    RegCloseKey(hSchemesKey);
-    RegCloseKey(hKey);
+    clientAddr.sin_family = AF_INET;
+    clientAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    clientAddr.sin_port = htons(MIDI_OPEN_PORT);
 
-    return TRUE;
+    buffer[0] = REQUEST_CODE_MIDI_CLOSE;
+    buffer[1] = isMidiOut ? 1 : 0;
+    sendto(serverSock, buffer, 64, 0, (struct sockaddr*)&clientAddr, sizeof(clientAddr));
 }
 
-static BOOL	MIDIMAP_LoadSettings(MIDIMAPDATA* mom)
+static DWORD midiSendDataMsg(DWORD_PTR dwParam)
 {
-    HKEY 	hKey;
-    BOOL	ret;
-
-    if (RegOpenKeyA(HKEY_CURRENT_USER,
-		    "Software\\Microsoft\\Windows\\CurrentVersion\\Multimedia\\MIDIMap", &hKey))
-    {
-	ret = MIDIMAP_LoadSettingsDefault(mom, NULL);
-    }
-    else
-    {
-	DWORD	type, size, out;
-	WCHAR	buffer[256];
+    char buffer[16] = {0};
+    struct sockaddr_in clientAddr;
 
-	size = sizeof(buffer);
-	if (!RegQueryValueExW(hKey, L"szPname", 0, &type, (void*)buffer, &size))
-	{
-	    ret = MIDIMAP_LoadSettingsDefault(mom, buffer);
-	}
-	else
-	{
-	    ret = 2;
-	    size = sizeof(out);
-	    if (!RegQueryValueExA(hKey, "UseScheme", 0, &type, (void*)&out, &size) && out)
-	    {
-		size = sizeof(buffer);
-		if (!RegQueryValueExW(hKey, L"CurrentScheme", 0, &type, (void*)buffer, &size))
-		{
-		    if (!(ret = MIDIMAP_LoadSettingsScheme(mom, buffer)))
-			ret = MIDIMAP_LoadSettingsDefault(mom, NULL);
-		}
-		else
-		{
-		    ERR("Wrong registry: UseScheme is active, but no CurrentScheme found\n");
-		}
-	    }
-	    if (ret == 2)
-	    {
-		size = sizeof(buffer);
-		if (!RegQueryValueExW(hKey, L"CurrentInstrument", 0, &type, (void*)buffer, &size) && *buffer)
-		{
-		    ret = MIDIMAP_LoadSettingsDefault(mom, buffer);
-		}
-		else
-		{
-		    ret = MIDIMAP_LoadSettingsDefault(mom, NULL);
-		}
-	    }
-	}
-    }
-    RegCloseKey(hKey);
+    clientAddr.sin_family = AF_INET;
+    clientAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    clientAddr.sin_port = htons(MIDI_OUT_PORT);
 
-    if (ret && TRACE_ON(midi))
-    {
-	unsigned	i;
+    buffer[0] = 1; /* SHORT DATA */
+    *(DWORD_PTR*)(buffer + 1) = dwParam;
 
-	for (i = 0; i < 16; i++)
-	{
-	    TRACE("chnMap[%2d] => %d\n",
-		  i, mom->ChannelMap[i] ? mom->ChannelMap[i]->uDevID : -1);
-	}
-    }
-    return ret;
+    sendto(serverSock, buffer, 16, 0, (struct sockaddr*)&clientAddr, sizeof(clientAddr));
+    return MMSYSERR_NOERROR;
 }
 
-static void MIDIMAP_NotifyClient(MIDIMAPDATA* mom, WORD wMsg,
-				 DWORD_PTR dwParam1, DWORD_PTR dwParam2)
+static void MIDIMAP_NotifyClient(WORD wMsg, LPMIDIOPENDESC lpDesc, WORD wCbFlags, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
 {
-    DriverCallback(mom->midiDesc.dwCallback, mom->wCbFlags, (HDRVR)mom->midiDesc.hMidi,
-		   wMsg, mom->midiDesc.dwInstance, dwParam1, dwParam2);
+    DriverCallback(lpDesc->dwCallback, wCbFlags, (HDRVR)lpDesc->hMidi, wMsg, lpDesc->dwInstance, dwParam1, dwParam2);
 }
 
-static DWORD modOpen(DWORD_PTR *lpdwUser, LPMIDIOPENDESC lpDesc, DWORD dwFlags)
+static DWORD modOpen(LPMIDIOPENDESC lpDesc, DWORD dwFlags)
 {
-    MIDIMAPDATA*	mom = HeapAlloc(GetProcessHeap(), 0, sizeof(MIDIMAPDATA));
+    if (!lpDesc)
+        return MMSYSERR_INVALPARAM;
 
-    TRACE("(%p %p %08lx)\n", lpdwUser, lpDesc, dwFlags);
+    if (midiOutDev.midiDesc)
+        return MMSYSERR_ALLOCATED;
 
-    if (!mom) return MMSYSERR_NOMEM;
-    if (!lpDesc) {
-	HeapFree(GetProcessHeap(), 0, mom);
-	return MMSYSERR_INVALPARAM;
-    }
+    midiOutDev.midiDesc = lpDesc;
+    midiOutDev.wCbFlags = HIWORD(dwFlags & CALLBACK_TYPEMASK);
+    midiOutDev.runningStatus = 0;
 
-    if (MIDIMAP_LoadSettings(mom))
-    {
-	UINT chn;
-	*lpdwUser = (DWORD_PTR)mom;
-	mom->self = mom;
-	mom->wCbFlags = HIWORD(dwFlags & CALLBACK_TYPEMASK);
-	mom->midiDesc = *lpDesc;
-	mom->runningStatus = 0;
-
-	for (chn = 0; chn < 16; chn++)
-	{
-	    if (mom->ChannelMap[chn]->loaded) continue;
-	    if (midiOutOpen(&mom->ChannelMap[chn]->hMidi, mom->ChannelMap[chn]->uDevID,
-			    0L, 0L, CALLBACK_NULL) == MMSYSERR_NOERROR)
-		mom->ChannelMap[chn]->loaded = 1;
-	    else
-		mom->ChannelMap[chn]->loaded = -1;
-	    /* FIXME: should load here the IDF midi data... and allow channel and
-	     * patch mappings
-	     */
-	}
-	MIDIMAP_NotifyClient(mom, MOM_OPEN, 0L, 0L);
-	return MMSYSERR_NOERROR;
-    }
-    HeapFree(GetProcessHeap(), 0, mom);
-    return MIDIERR_INVALIDSETUP;
+    midiOpenRequest(TRUE);
+    MIDIMAP_NotifyClient(MOM_OPEN, midiOutDev.midiDesc, midiOutDev.wCbFlags, 0L, 0L);
+    return MMSYSERR_NOERROR;
 }
 
-static	DWORD	modClose(MIDIMAPDATA* mom)
+static DWORD modClose(void)
 {
-    UINT	i;
-    DWORD	ret = MMSYSERR_NOERROR;
-
-    if (MIDIMAP_IsBadData(mom)) 	return MMSYSERR_ERROR;
+    if (!midiOutDev.midiDesc)
+        return MMSYSERR_ERROR;
 
-    for (i = 0; i < 16; i++)
-    {
-	DWORD	t;
-	if (mom->ChannelMap[i] && mom->ChannelMap[i]->loaded > 0)
-	{
-	    t = midiOutClose(mom->ChannelMap[i]->hMidi);
-	    if (t == MMSYSERR_NOERROR)
-	    {
-		mom->ChannelMap[i]->loaded = 0;
-		mom->ChannelMap[i]->hMidi = 0;
-	    }
-	    else if (ret == MMSYSERR_NOERROR)
-		ret = t;
-	}
-    }
-    if (ret == MMSYSERR_NOERROR) {
-	MIDIMAP_NotifyClient(mom, MOM_CLOSE, 0L, 0L);
-	HeapFree(GetProcessHeap(), 0, mom);
-    }
-    return ret;
+    midiCloseRequest(TRUE);
+    MIDIMAP_NotifyClient(MOM_CLOSE, midiOutDev.midiDesc, midiOutDev.wCbFlags, 0L, 0L);
+    midiOutDev.midiDesc = NULL;
+    return MMSYSERR_NOERROR;
 }
 
-static DWORD modLongData(MIDIMAPDATA* mom, LPMIDIHDR lpMidiHdr, DWORD_PTR dwParam2)
+static DWORD modLongData(LPMIDIHDR lpMidiHdr, DWORD_PTR dwParam2)
 {
-    WORD	chn;
-    DWORD	ret = MMSYSERR_NOERROR;
-    MIDIHDR	mh;
+    DWORD ret = MMSYSERR_NOERROR;
 
-    if (MIDIMAP_IsBadData(mom))
-	return MMSYSERR_ERROR;
     if (!(lpMidiHdr->dwFlags & MHDR_PREPARED))
-	return MIDIERR_UNPREPARED;
+        return MIDIERR_UNPREPARED;
+
     if (lpMidiHdr->dwFlags & MHDR_INQUEUE)
-	return MIDIERR_STILLPLAYING;
+        return MIDIERR_STILLPLAYING;
 
-    mh = *lpMidiHdr;
-    lpMidiHdr->dwFlags &= ~MHDR_DONE;
-    lpMidiHdr->dwFlags |= MHDR_INQUEUE;
-    for (chn = 0; chn < 16; chn++)
-    {
-	if (mom->ChannelMap[chn] && mom->ChannelMap[chn]->loaded > 0)
-	{
-	    mh.dwFlags = 0;
-	    midiOutPrepareHeader(mom->ChannelMap[chn]->hMidi, &mh, sizeof(mh));
-	    ret = midiOutLongMsg(mom->ChannelMap[chn]->hMidi, &mh, sizeof(mh));
-	    /* As of 2009, wineXYZ.drv's LongData handlers are synchronous */
-	    if (!ret && !(mh.dwFlags & MHDR_DONE))
-		FIXME("wait until MHDR_DONE\n");
-	    midiOutUnprepareHeader(mom->ChannelMap[chn]->hMidi, &mh, sizeof(mh));
-	    if (ret != MMSYSERR_NOERROR) break;
-	}
-    }
-    mom->runningStatus = 0;
+    FIXME("midi long data not implemented yet\n");
+
+    midiOutDev.runningStatus = 0;
     lpMidiHdr->dwFlags &= ~MHDR_INQUEUE;
     lpMidiHdr->dwFlags |= MHDR_DONE;
-    MIDIMAP_NotifyClient(mom, MOM_DONE, (DWORD_PTR)lpMidiHdr, 0L);
+    MIDIMAP_NotifyClient(MOM_DONE, midiOutDev.midiDesc, midiOutDev.wCbFlags, (DWORD_PTR)lpMidiHdr, 0L);
     return ret;
 }
 
-static DWORD modData(MIDIMAPDATA* mom, DWORD_PTR dwParam)
+static DWORD modData(DWORD_PTR dwParam)
 {
-    BYTE	status = LOBYTE(LOWORD(dwParam));
-    WORD	chn;
-    DWORD	ret = MMSYSERR_NOERROR;
-
-    if (MIDIMAP_IsBadData(mom))
-	return MMSYSERR_ERROR;
+    BYTE status = LOBYTE(LOWORD(dwParam));
+    DWORD ret = MMSYSERR_NOERROR;
 
     if (status < 0x80)
     {
-        if (mom->runningStatus)
+        if (midiOutDev.runningStatus)
         {
-            status = mom->runningStatus;
+            status = midiOutDev.runningStatus;
             dwParam = ((LOWORD(dwParam) << 8) | status);
         }
         else
@@ -411,90 +223,52 @@
             return MMSYSERR_NOERROR;
         }
     }
-    chn = status & 0x0F;
 
-    if (!mom->ChannelMap[chn]) return MMSYSERR_NOERROR;
+    ret = midiSendDataMsg(dwParam);
 
-    switch (status & 0xF0)
-    {
-    case 0x80:
-    case 0x90:
-    case 0xA0:
-    case 0xB0:
-    case 0xC0:
-    case 0xD0:
-    case 0xE0:
-	if (mom->ChannelMap[chn]->loaded > 0)
-	{
-	    /* change channel */
-	    dwParam &= ~0x0F;
-	    dwParam |= mom->ChannelMap[chn]->aChn[chn];
-
-	    if ((LOBYTE(LOWORD(dwParam)) & 0xF0) == 0xC0 /* program change */ &&
-		mom->ChannelMap[chn]->lpbPatch)
-	    {
-		BYTE patch = HIBYTE(LOWORD(dwParam));
-
-		/* change patch */
-		dwParam &= ~0x0000FF00;
-		dwParam |= mom->ChannelMap[chn]->lpbPatch[patch];
-	    }
-	    ret = midiOutShortMsg(mom->ChannelMap[chn]->hMidi, dwParam);
-	}
-	mom->runningStatus = status;
-	break;
-    case 0xF0:
-	for (chn = 0; chn < 16; chn++)
-	{
-	    if (mom->ChannelMap[chn]->loaded > 0)
-		ret = midiOutShortMsg(mom->ChannelMap[chn]->hMidi, dwParam);
-	}
-	/* system common message */
-	if (status <= 0xF7)
-	    mom->runningStatus = 0;
-	break;
-    default:
-	FIXME("ooch %Ix\n", dwParam);
-    }
+    /* system common message */
+    if (status <= 0xF7)
+        midiOutDev.runningStatus = 0;
 
     return ret;
 }
 
-static DWORD modPrepare(MIDIMAPDATA* mom, LPMIDIHDR lpMidiHdr, DWORD_PTR dwSize)
+static DWORD modPrepare(LPMIDIHDR lpMidiHdr, DWORD_PTR dwSize)
 {
-    if (MIDIMAP_IsBadData(mom)) return MMSYSERR_ERROR;
     if (dwSize < offsetof(MIDIHDR,dwOffset) || lpMidiHdr == 0 || lpMidiHdr->lpData == 0)
-	return MMSYSERR_INVALPARAM;
+        return MMSYSERR_INVALPARAM;
+
     if (lpMidiHdr->dwFlags & MHDR_PREPARED)
-	return MMSYSERR_NOERROR;
+        return MMSYSERR_NOERROR;
 
     lpMidiHdr->dwFlags |= MHDR_PREPARED;
-    lpMidiHdr->dwFlags &= ~(MHDR_DONE|MHDR_INQUEUE); /* flags cleared since w2k */
+    lpMidiHdr->dwFlags &= ~(MHDR_DONE | MHDR_INQUEUE); /* flags cleared since w2k */
     return MMSYSERR_NOERROR;
 }
 
-static DWORD modUnprepare(MIDIMAPDATA* mom, LPMIDIHDR lpMidiHdr, DWORD_PTR dwSize)
+static DWORD modUnprepare(LPMIDIHDR lpMidiHdr, DWORD_PTR dwSize)
 {
-    if (MIDIMAP_IsBadData(mom)) return MMSYSERR_ERROR;
     if (dwSize < offsetof(MIDIHDR,dwOffset) || lpMidiHdr == 0 || lpMidiHdr->lpData == 0)
-	return MMSYSERR_INVALPARAM;
+        return MMSYSERR_INVALPARAM;
+
     if (!(lpMidiHdr->dwFlags & MHDR_PREPARED))
-	return MMSYSERR_NOERROR;
+        return MMSYSERR_NOERROR;
+
     if (lpMidiHdr->dwFlags & MHDR_INQUEUE)
-	return MIDIERR_STILLPLAYING;
+        return MIDIERR_STILLPLAYING;
 
     lpMidiHdr->dwFlags &= ~MHDR_PREPARED;
     return MMSYSERR_NOERROR;
 }
 
-static DWORD modGetVolume(MIDIMAPDATA* mom, DWORD* lpdwVolume)
+static DWORD modGetVolume(DWORD* lpdwVolume)
 {
     if (!lpdwVolume) return MMSYSERR_INVALPARAM;
     *lpdwVolume = 0xFFFFFFFF; /* tests show this initial value */
     return MMSYSERR_NOERROR;
 }
 
-static DWORD modSetVolume(MIDIMAPDATA* mom, DWORD dwVolume)
+static DWORD modSetVolume(DWORD dwVolume)
 {
     /* Native forwards it to some underlying device
      * GetVolume returns what was last set here. */
@@ -502,40 +276,165 @@
     return MMSYSERR_NOERROR;
 }
 
-static DWORD modGetDevCaps(UINT wDevID, MIDIMAPDATA* mom, LPMIDIOUTCAPSW lpMidiCaps, DWORD_PTR size)
+static DWORD modGetDevCaps(LPMIDIOUTCAPSW lpCaps, DWORD_PTR size)
+{
+    static const MIDIOUTCAPSW tmpCaps = {
+        0x00FF, 0x0001, 0x0100, /* Manufacturer and Product ID */
+        L"Wine Midi-Out", MOD_MAPPER, 0, 0, 0xFFFF,
+        MIDICAPS_VOLUME|MIDICAPS_LRVOLUME /* Native returns volume caps of underlying device + MIDICAPS_STREAM */
+    };
+
+    if (!lpCaps)
+        return MMSYSERR_INVALPARAM;
+
+    memcpy(lpCaps, &tmpCaps, min(size, sizeof(*lpCaps)));
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD modReset(void)
+{
+    midiOutDev.runningStatus = 0;
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD WINAPI MidThreadProc(void *param)
+{
+    int res;
+    char buffer[8];
+
+    while (midiInDev.running)
+    {
+        res = recvfrom(serverSock, buffer, 8, 0, NULL, NULL);
+        if (res <= 0)
+        {
+            if (WSAGetLastError() != WSAEWOULDBLOCK) break;
+            Sleep(16);
+            continue;
+        }
+
+        MIDIMAP_NotifyClient(MIM_DATA, midiInDev.midiDesc, midiInDev.wCbFlags, *(DWORD*)(buffer), 0L);
+    }
+
+    return 0;
+}
+
+static DWORD midGetDevCaps(LPMIDIINCAPSW lpCaps, DWORD_PTR size)
 {
-    static const MIDIOUTCAPSW mappercaps = {
-	0x00FF, 0x0001, 0x0100, /* Manufacturer and Product ID */
-        L"Wine midi mapper", MOD_MAPPER, 0, 0, 0xFFFF,
-	/* Native returns volume caps of underlying device + MIDICAPS_STREAM */
-	MIDICAPS_VOLUME|MIDICAPS_LRVOLUME
+    static const MIDIINCAPSW tmpCaps = {
+        0x00FF, 0x0001, 0x0100,
+        L"Wine Midi-In",
+        MIDICAPS_VOLUME|MIDICAPS_LRVOLUME
     };
-    if (lpMidiCaps == NULL) return MMSYSERR_INVALPARAM;
-    if (!numMidiOutPorts) return MMSYSERR_BADDEVICEID;
 
-    memcpy(lpMidiCaps, &mappercaps, min(size, sizeof(*lpMidiCaps)));
+    if (!lpCaps)
+        return MMSYSERR_INVALPARAM;
+
+    memcpy(lpCaps, &tmpCaps, min(size, sizeof(*lpCaps)));
     return MMSYSERR_NOERROR;
 }
 
-static	DWORD	modReset(MIDIMAPDATA* mom)
+static DWORD midOpen(LPMIDIOPENDESC lpDesc, DWORD dwFlags)
 {
-    WORD	chn;
-    DWORD	ret = MMSYSERR_NOERROR;
+    if (!lpDesc)
+        return MMSYSERR_INVALPARAM;
 
-    if (MIDIMAP_IsBadData(mom))
-	return MMSYSERR_ERROR;
+    if (midiInDev.midiDesc)
+        return MMSYSERR_ALLOCATED;
 
-    for (chn = 0; chn < 16; chn++)
+    midiInDev.running = TRUE;
+
+	midiInDev.thread = CreateThread(NULL, 0, MidThreadProc, NULL, 0, NULL);
+	if (!midiInDev.thread)
     {
-	if (mom->ChannelMap[chn] && mom->ChannelMap[chn]->loaded > 0)
-	{
-	    ret = midiOutReset(mom->ChannelMap[chn]->hMidi);
-	    if (ret != MMSYSERR_NOERROR) break;
+        midiInDev.running = FALSE;
+	    WARN("Failed to create thread for midi-in\n");
+	    return MMSYSERR_ERROR;
 	}
+
+    midiInDev.midiDesc = lpDesc;
+    midiInDev.wCbFlags = HIWORD(dwFlags & CALLBACK_TYPEMASK);
+
+    midiOpenRequest(FALSE);
+    MIDIMAP_NotifyClient(MIM_OPEN, midiInDev.midiDesc, midiInDev.wCbFlags, 0L, 0L);
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD midClose(void)
+{
+    if (!midiInDev.midiDesc)
+        return MMSYSERR_ERROR;
+
+    midiInDev.running = FALSE;
+    if (midiInDev.thread)
+    {
+        WaitForSingleObject(midiInDev.thread, INFINITE);
+        midiInDev.thread = NULL;
     }
-    mom->runningStatus = 0;
 
-    return ret;
+    midiCloseRequest(FALSE);
+    MIDIMAP_NotifyClient(MIM_CLOSE, midiInDev.midiDesc, midiInDev.wCbFlags, 0L, 0L);
+    midiInDev.midiDesc = NULL;
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD midStart(void)
+{
+    FIXME("stub\n");
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD midStop(void)
+{
+    FIXME("stub\n");
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD midPrepare(LPMIDIHDR lpMidiHdr, DWORD dwSize)
+{
+    if (dwSize < offsetof(MIDIHDR,dwOffset) || !lpMidiHdr || lpMidiHdr->lpData == 0)
+        return MMSYSERR_INVALPARAM;
+
+    if (lpMidiHdr->dwFlags & MHDR_PREPARED)
+        return MMSYSERR_NOERROR;
+
+    lpMidiHdr->dwFlags |= MHDR_PREPARED;
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD midUnprepare(LPMIDIHDR lpMidiHdr, DWORD dwSize)
+{
+    if (dwSize < offsetof(MIDIHDR,dwOffset) || !lpMidiHdr || lpMidiHdr->lpData == 0)
+        return MMSYSERR_INVALPARAM;
+
+    if (!(lpMidiHdr->dwFlags & MHDR_PREPARED))
+        return MMSYSERR_NOERROR;
+
+    if (lpMidiHdr->dwFlags & MHDR_INQUEUE)
+        return MIDIERR_STILLPLAYING;
+
+    lpMidiHdr->dwFlags &= ~MHDR_PREPARED;
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD midAddBuffer(LPMIDIHDR lpMidiHdr, DWORD dwSize)
+{
+    if (dwSize < offsetof(MIDIHDR,dwOffset) || !lpMidiHdr || lpMidiHdr->lpData == 0)
+        return MMSYSERR_INVALPARAM;
+
+    if (!(lpMidiHdr->dwFlags & MHDR_PREPARED))
+        return MMSYSERR_NOERROR;
+
+    if (lpMidiHdr->dwFlags & MHDR_INQUEUE)
+        return MIDIERR_STILLPLAYING;
+
+    FIXME("stub\n");
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD midReset(void)
+{
+    FIXME("stub\n");
+    return MMSYSERR_NOERROR;
 }
 
 static LRESULT MIDIMAP_drvOpen(void);
@@ -545,37 +444,68 @@
  * 				modMessage (MIDIMAP.@)
  */
 DWORD WINAPI MIDIMAP_modMessage(UINT wDevID, UINT wMsg, DWORD_PTR dwUser,
-				DWORD_PTR dwParam1, DWORD_PTR dwParam2)
+                                DWORD_PTR dwParam1, DWORD_PTR dwParam2)
 {
-    TRACE("(%u, %04X, %08IX, %08IX, %08IX);\n",
-	  wDevID, wMsg, dwUser, dwParam1, dwParam2);
+    TRACE("(%u, %04X, %08IX, %08IX, %08IX);\n", wDevID, wMsg, dwUser, dwParam1, dwParam2);
+
+    switch (wMsg)
+    {
+        case DRVM_INIT: return MIDIMAP_drvOpen();
+        case DRVM_EXIT: return MIDIMAP_drvClose();
+        case DRVM_ENABLE:
+        case DRVM_DISABLE:
+            /* FIXME: Pretend this is supported */
+            return 0;
+
+        case MODM_OPEN: return modOpen((LPMIDIOPENDESC)dwParam1, dwParam2);
+        case MODM_CLOSE: return modClose();
+
+        case MODM_DATA: return modData(dwParam1);
+        case MODM_LONGDATA:	return modLongData((LPMIDIHDR)dwParam1, dwParam2);
+        case MODM_PREPARE: return modPrepare((LPMIDIHDR)dwParam1, dwParam2);
+        case MODM_UNPREPARE: return modUnprepare((LPMIDIHDR)dwParam1, dwParam2);
+        case MODM_RESET: return modReset();
+
+        case MODM_GETDEVCAPS: return modGetDevCaps((LPMIDIOUTCAPSW)dwParam1, dwParam2);
+        case MODM_GETNUMDEVS: return 1;
+        case MODM_GETVOLUME: return modGetVolume((DWORD*)dwParam1);
+        case MODM_SETVOLUME: return modSetVolume(dwParam1);
+        default:
+            FIXME("unknown message %d!\n", wMsg);
+    }
+    return MMSYSERR_NOTSUPPORTED;
+}
+
+/**************************************************************************
+ * 				midMessage (MIDIMAP.@)
+ */
+DWORD WINAPI MIDIMAP_midMessage(UINT wDevID, UINT wMsg, DWORD_PTR dwUser,
+                                DWORD_PTR dwParam1, DWORD_PTR dwParam2)
+                                {
+    TRACE("(%u, %04X, %08IX, %08IX, %08IX);\n", wDevID, wMsg, dwUser, dwParam1, dwParam2);
 
     switch (wMsg)
     {
-    case DRVM_INIT:
-        return MIDIMAP_drvOpen();
-    case DRVM_EXIT:
-        return MIDIMAP_drvClose();
-    case DRVM_ENABLE:
-    case DRVM_DISABLE:
-	/* FIXME: Pretend this is supported */
-	return 0;
-
-    case MODM_OPEN: return modOpen((DWORD_PTR *)dwUser, (LPMIDIOPENDESC)dwParam1, dwParam2);
-    case MODM_CLOSE:	 	return modClose		((MIDIMAPDATA*)dwUser);
-
-    case MODM_DATA:		return modData		((MIDIMAPDATA*)dwUser, dwParam1);
-    case MODM_LONGDATA:		return modLongData      ((MIDIMAPDATA*)dwUser, (LPMIDIHDR)dwParam1,     dwParam2);
-    case MODM_PREPARE:	 	return modPrepare	((MIDIMAPDATA*)dwUser, (LPMIDIHDR)dwParam1, 	dwParam2);
-    case MODM_UNPREPARE: 	return modUnprepare	((MIDIMAPDATA*)dwUser, (LPMIDIHDR)dwParam1, 	dwParam2);
-    case MODM_RESET:		return modReset		((MIDIMAPDATA*)dwUser);
-
-    case MODM_GETDEVCAPS:	return modGetDevCaps	(wDevID, (MIDIMAPDATA*)dwUser, (LPMIDIOUTCAPSW)dwParam1,dwParam2);
-    case MODM_GETNUMDEVS:	return 1;
-    case MODM_GETVOLUME:	return modGetVolume	((MIDIMAPDATA*)dwUser, (DWORD*)dwParam1);
-    case MODM_SETVOLUME:	return modSetVolume	((MIDIMAPDATA*)dwUser, dwParam1);
-    default:
-	FIXME("unknown message %d!\n", wMsg);
+        case DRVM_INIT: return MIDIMAP_drvOpen();
+        case DRVM_EXIT: return MIDIMAP_drvClose();
+        case DRVM_ENABLE:
+        case DRVM_DISABLE:
+            /* FIXME: Pretend this is supported */
+            return 0;
+        case MIDM_OPEN: return midOpen((LPMIDIOPENDESC)dwParam1, dwParam2);
+        case MIDM_CLOSE: return midClose();
+
+        case MIDM_START: return midStart();
+        case MIDM_STOP: return midStop();
+        case MIDM_PREPARE: return midPrepare((LPMIDIHDR)dwParam1, dwParam2);
+        case MIDM_UNPREPARE: return midUnprepare((LPMIDIHDR)dwParam1, dwParam2);
+        case MIDM_ADDBUFFER: return midAddBuffer((LPMIDIHDR)dwParam1, dwParam2);
+        case MIDM_RESET: return midReset();
+
+        case MIDM_GETDEVCAPS: return midGetDevCaps((LPMIDIINCAPSW)dwParam1, dwParam2);
+        case MIDM_GETNUMDEVS: return 1;
+        default:
+            FIXME("unknown message %d!\n", wMsg);
     }
     return MMSYSERR_NOTSUPPORTED;
 }
@@ -589,40 +519,8 @@
  */
 static LRESULT MIDIMAP_drvOpen(void)
 {
-    MIDIOUTCAPSW	moc;
-    unsigned		dev, i;
-    BOOL                found_valid_port = FALSE;
-
-    if (midiOutPorts)
-	return 0;
-
-    numMidiOutPorts = midiOutGetNumDevs();
-    midiOutPorts = HeapAlloc(GetProcessHeap(), 0,
-			     numMidiOutPorts * sizeof(MIDIOUTPORT));
-    for (dev = 0; dev < numMidiOutPorts; dev++)
-    {
-	if (midiOutGetDevCapsW(dev, &moc, sizeof(moc)) == 0L)
-	{
-	    lstrcpyW(midiOutPorts[dev].name, moc.szPname);
-	    midiOutPorts[dev].loaded = 0;
-	    midiOutPorts[dev].hMidi = 0;
-	    midiOutPorts[dev].uDevID = dev;
-	    midiOutPorts[dev].lpbPatch = NULL;
-	    for (i = 0; i < 16; i++)
-		midiOutPorts[dev].aChn[i] = i;
-            if (wcsncmp(midiOutPorts[dev].name, L"Midi Through", lstrlenW(L"Midi Through")) != 0)
-	        found_valid_port = TRUE;
-	}
-	else
-	{
-	    midiOutPorts[dev].loaded = -1;
-	}
-    }
-
-    if (!found_valid_port)
-        ERR_(winediag)("No software synthesizer midi port found, Midi sound output probably won't work.\n");
-
-    return 1;
+    createServerSocket();
+    return MMSYSERR_NOERROR;
 }
 
 /**************************************************************************
@@ -630,13 +528,8 @@
  */
 static LRESULT MIDIMAP_drvClose(void)
 {
-    if (midiOutPorts)
-    {
-	HeapFree(GetProcessHeap(), 0, midiOutPorts);
-	midiOutPorts = NULL;
-	return 1;
-    }
-    return 0;
+    closeServerSocket();
+    return MMSYSERR_NOERROR;
 }
 
 /**************************************************************************
@@ -645,22 +538,24 @@
 LRESULT CALLBACK MIDIMAP_DriverProc(DWORD_PTR dwDevID, HDRVR hDriv, UINT wMsg,
                                     LPARAM dwParam1, LPARAM dwParam2)
 {
-/* EPP     TRACE("(%08lX, %04X, %08lX, %08lX, %08lX)\n",  */
-/* EPP 	  dwDevID, hDriv, wMsg, dwParam1, dwParam2); */
+    /*
+    TRACE("(%08lX, %04X, %08lX, %08lX, %08lX)\n",
+        dwDevID, hDriv, wMsg, dwParam1, dwParam2);
+    */
 
     switch (wMsg)
     {
-    case DRV_LOAD:		return 1;
-    case DRV_FREE:		return 1;
-    case DRV_OPEN:		return 1;
-    case DRV_CLOSE:		return 1;
-    case DRV_ENABLE:		return 1;
-    case DRV_DISABLE:		return 1;
-    case DRV_QUERYCONFIGURE:	return 1;
-    case DRV_CONFIGURE:		MessageBoxA(0, "MIDIMAP MultiMedia Driver !", "OSS Driver", MB_OK);	return 1;
-    case DRV_INSTALL:		return DRVCNF_RESTART;
-    case DRV_REMOVE:		return DRVCNF_RESTART;
-    default:
-	return DefDriverProc(dwDevID, hDriv, wMsg, dwParam1, dwParam2);
+        case DRV_LOAD: return 1;
+        case DRV_FREE: return 1;
+        case DRV_OPEN: return 1;
+        case DRV_CLOSE:	return 1;
+        case DRV_ENABLE: return 1;
+        case DRV_DISABLE: return 1;
+        case DRV_QUERYCONFIGURE: return 1;
+        case DRV_CONFIGURE:	MessageBoxA(0, "MIDIMAP MultiMedia Driver!", "OSS Driver", MB_OK);	return 1;
+        case DRV_INSTALL: return DRVCNF_RESTART;
+        case DRV_REMOVE: return DRVCNF_RESTART;
+        default:
+            return DefDriverProc(dwDevID, hDriv, wMsg, dwParam1, dwParam2);
     }
 }
